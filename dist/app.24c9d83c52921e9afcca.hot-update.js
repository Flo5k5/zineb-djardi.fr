self["webpackHotUpdatezinebdjardi"]("app",{

/***/ "./node_modules/@barba/core/dist/barba.umd.js":
/*!****************************************************!*\
  !*** ./node_modules/@barba/core/dist/barba.umd.js ***!
  \****************************************************/
/***/ (function(module) {

!function (t, n) {
   true ? module.exports = n() : 0;
}(this, function () {
  function t(t, n) {
    for (var r = 0; r < n.length; r++) {
      var e = n[r];
      e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(t, e.key, e);
    }
  }

  function n(n, r, e) {
    return r && t(n.prototype, r), e && t(n, e), n;
  }

  function r() {
    return (r = Object.assign || function (t) {
      for (var n = 1; n < arguments.length; n++) {
        var r = arguments[n];

        for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (t[e] = r[e]);
      }

      return t;
    }).apply(this, arguments);
  }

  function e(t, n) {
    t.prototype = Object.create(n.prototype), t.prototype.constructor = t, t.__proto__ = n;
  }

  function i(t) {
    return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    })(t);
  }

  function o(t, n) {
    return (o = Object.setPrototypeOf || function (t, n) {
      return t.__proto__ = n, t;
    })(t, n);
  }

  function u(t, n, r) {
    return (u = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;

      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;
      } catch (t) {
        return !1;
      }
    }() ? Reflect.construct : function (t, n, r) {
      var e = [null];
      e.push.apply(e, n);
      var i = new (Function.bind.apply(t, e))();
      return r && o(i, r.prototype), i;
    }).apply(null, arguments);
  }

  function f(t) {
    var n = "function" == typeof Map ? new Map() : void 0;
    return (f = function (t) {
      if (null === t || -1 === Function.toString.call(t).indexOf("[native code]")) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");

      if (void 0 !== n) {
        if (n.has(t)) return n.get(t);
        n.set(t, r);
      }

      function r() {
        return u(t, arguments, i(this).constructor);
      }

      return r.prototype = Object.create(t.prototype, {
        constructor: {
          value: r,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), o(r, t);
    })(t);
  }

  function s(t, n) {
    try {
      var r = t();
    } catch (t) {
      return n(t);
    }

    return r && r.then ? r.then(void 0, n) : r;
  }

  "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));

  var c,
      a = "2.9.7",
      h = function () {};

  !function (t) {
    t[t.off = 0] = "off", t[t.error = 1] = "error", t[t.warning = 2] = "warning", t[t.info = 3] = "info", t[t.debug = 4] = "debug";
  }(c || (c = {}));

  var v = c.off,
      l = function () {
    function t(t) {
      this.t = t;
    }

    t.getLevel = function () {
      return v;
    }, t.setLevel = function (t) {
      return v = c[t];
    };
    var n = t.prototype;
    return n.error = function () {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];

      this.i(console.error, c.error, n);
    }, n.warn = function () {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];

      this.i(console.warn, c.warning, n);
    }, n.info = function () {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];

      this.i(console.info, c.info, n);
    }, n.debug = function () {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];

      this.i(console.log, c.debug, n);
    }, n.i = function (n, r, e) {
      r <= t.getLevel() && n.apply(console, ["[" + this.t + "] "].concat(e));
    }, t;
  }(),
      d = O,
      m = E,
      p = g,
      w = x,
      b = T,
      y = "/",
      P = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");

  function g(t, n) {
    for (var r, e = [], i = 0, o = 0, u = "", f = n && n.delimiter || y, s = n && n.whitelist || void 0, c = !1; null !== (r = P.exec(t));) {
      var a = r[0],
          h = r[1],
          v = r.index;
      if (u += t.slice(o, v), o = v + a.length, h) u += h[1], c = !0;else {
        var l = "",
            d = r[2],
            m = r[3],
            p = r[4],
            w = r[5];

        if (!c && u.length) {
          var b = u.length - 1,
              g = u[b];
          (!s || s.indexOf(g) > -1) && (l = g, u = u.slice(0, b));
        }

        u && (e.push(u), u = "", c = !1);
        var E = m || p,
            x = l || f;
        e.push({
          name: d || i++,
          prefix: l,
          delimiter: x,
          optional: "?" === w || "*" === w,
          repeat: "+" === w || "*" === w,
          pattern: E ? A(E) : "[^" + k(x === f ? x : x + f) + "]+?"
        });
      }
    }

    return (u || o < t.length) && e.push(u + t.substr(o)), e;
  }

  function E(t, n) {
    return function (r, e) {
      var i = t.exec(r);
      if (!i) return !1;

      for (var o = i[0], u = i.index, f = {}, s = e && e.decode || decodeURIComponent, c = 1; c < i.length; c++) if (void 0 !== i[c]) {
        var a = n[c - 1];
        f[a.name] = a.repeat ? i[c].split(a.delimiter).map(function (t) {
          return s(t, a);
        }) : s(i[c], a);
      }

      return {
        path: o,
        index: u,
        params: f
      };
    };
  }

  function x(t, n) {
    for (var r = new Array(t.length), e = 0; e < t.length; e++) "object" == typeof t[e] && (r[e] = new RegExp("^(?:" + t[e].pattern + ")$", R(n)));

    return function (n, e) {
      for (var i = "", o = e && e.encode || encodeURIComponent, u = !e || !1 !== e.validate, f = 0; f < t.length; f++) {
        var s = t[f];

        if ("string" != typeof s) {
          var c,
              a = n ? n[s.name] : void 0;

          if (Array.isArray(a)) {
            if (!s.repeat) throw new TypeError('Expected "' + s.name + '" to not repeat, but got array');

            if (0 === a.length) {
              if (s.optional) continue;
              throw new TypeError('Expected "' + s.name + '" to not be empty');
            }

            for (var h = 0; h < a.length; h++) {
              if (c = o(a[h], s), u && !r[f].test(c)) throw new TypeError('Expected all "' + s.name + '" to match "' + s.pattern + '"');
              i += (0 === h ? s.prefix : s.delimiter) + c;
            }
          } else if ("string" != typeof a && "number" != typeof a && "boolean" != typeof a) {
            if (!s.optional) throw new TypeError('Expected "' + s.name + '" to be ' + (s.repeat ? "an array" : "a string"));
          } else {
            if (c = o(String(a), s), u && !r[f].test(c)) throw new TypeError('Expected "' + s.name + '" to match "' + s.pattern + '", but got "' + c + '"');
            i += s.prefix + c;
          }
        } else i += s;
      }

      return i;
    };
  }

  function k(t) {
    return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
  }

  function A(t) {
    return t.replace(/([=!:$/()])/g, "\\$1");
  }

  function R(t) {
    return t && t.sensitive ? "" : "i";
  }

  function T(t, n, r) {
    for (var e = (r = r || {}).strict, i = !1 !== r.start, o = !1 !== r.end, u = r.delimiter || y, f = [].concat(r.endsWith || []).map(k).concat("$").join("|"), s = i ? "^" : "", c = 0; c < t.length; c++) {
      var a = t[c];
      if ("string" == typeof a) s += k(a);else {
        var h = a.repeat ? "(?:" + a.pattern + ")(?:" + k(a.delimiter) + "(?:" + a.pattern + "))*" : a.pattern;
        n && n.push(a), s += a.optional ? a.prefix ? "(?:" + k(a.prefix) + "(" + h + "))?" : "(" + h + ")?" : k(a.prefix) + "(" + h + ")";
      }
    }

    if (o) e || (s += "(?:" + k(u) + ")?"), s += "$" === f ? "$" : "(?=" + f + ")";else {
      var v = t[t.length - 1],
          l = "string" == typeof v ? v[v.length - 1] === u : void 0 === v;
      e || (s += "(?:" + k(u) + "(?=" + f + "))?"), l || (s += "(?=" + k(u) + "|" + f + ")");
    }
    return new RegExp(s, R(r));
  }

  function O(t, n, r) {
    return t instanceof RegExp ? function (t, n) {
      if (!n) return t;
      var r = t.source.match(/\((?!\?)/g);
      if (r) for (var e = 0; e < r.length; e++) n.push({
        name: e,
        prefix: null,
        delimiter: null,
        optional: !1,
        repeat: !1,
        pattern: null
      });
      return t;
    }(t, n) : Array.isArray(t) ? function (t, n, r) {
      for (var e = [], i = 0; i < t.length; i++) e.push(O(t[i], n, r).source);

      return new RegExp("(?:" + e.join("|") + ")", R(r));
    }(t, n, r) : function (t, n, r) {
      return T(g(t, r), n, r);
    }(t, n, r);
  }

  d.match = function (t, n) {
    var r = [];
    return E(O(t, r, n), r);
  }, d.regexpToFunction = m, d.parse = p, d.compile = function (t, n) {
    return x(g(t, n), n);
  }, d.tokensToFunction = w, d.tokensToRegExp = b;

  var S = {
    container: "container",
    history: "history",
    namespace: "namespace",
    prefix: "data-barba",
    prevent: "prevent",
    wrapper: "wrapper"
  },
      j = new (function () {
    function t() {
      this.o = S, this.u = new DOMParser();
    }

    var n = t.prototype;
    return n.toString = function (t) {
      return t.outerHTML;
    }, n.toDocument = function (t) {
      return this.u.parseFromString(t, "text/html");
    }, n.toElement = function (t) {
      var n = document.createElement("div");
      return n.innerHTML = t, n;
    }, n.getHtml = function (t) {
      return void 0 === t && (t = document), this.toString(t.documentElement);
    }, n.getWrapper = function (t) {
      return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]');
    }, n.getContainer = function (t) {
      return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]');
    }, n.removeContainer = function (t) {
      document.body.contains(t) && t.parentNode.removeChild(t);
    }, n.addContainer = function (t, n) {
      var r = this.getContainer();
      r ? this.s(t, r) : n.appendChild(t);
    }, n.getNamespace = function (t) {
      void 0 === t && (t = document);
      var n = t.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
      return n ? n.getAttribute(this.o.prefix + "-" + this.o.namespace) : null;
    }, n.getHref = function (t) {
      if (t.tagName && "a" === t.tagName.toLowerCase()) {
        if ("string" == typeof t.href) return t.href;
        var n = t.getAttribute("href") || t.getAttribute("xlink:href");
        if (n) return this.resolveUrl(n.baseVal || n);
      }

      return null;
    }, n.resolveUrl = function () {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];

      var e = n.length;
      if (0 === e) throw new Error("resolveUrl requires at least one argument; got none.");
      var i = document.createElement("base");
      if (i.href = arguments[0], 1 === e) return i.href;
      var o = document.getElementsByTagName("head")[0];
      o.insertBefore(i, o.firstChild);

      for (var u, f = document.createElement("a"), s = 1; s < e; s++) f.href = arguments[s], i.href = u = f.href;

      return o.removeChild(i), u;
    }, n.s = function (t, n) {
      n.parentNode.insertBefore(t, n.nextSibling);
    }, t;
  }())(),
      M = new (function () {
    function t() {
      this.h = [], this.v = -1;
    }

    var e = t.prototype;
    return e.init = function (t, n) {
      this.l = "barba";
      var r = {
        ns: n,
        scroll: {
          x: window.scrollX,
          y: window.scrollY
        },
        url: t
      };
      this.h.push(r), this.v = 0;
      var e = {
        from: this.l,
        index: 0,
        states: [].concat(this.h)
      };
      window.history && window.history.replaceState(e, "", t);
    }, e.change = function (t, n, r) {
      if (r && r.state) {
        var e = r.state,
            i = e.index;
        n = this.m(this.v - i), this.replace(e.states), this.v = i;
      } else this.add(t, n);

      return n;
    }, e.add = function (t, n) {
      var r = this.size,
          e = this.p(n),
          i = {
        ns: "tmp",
        scroll: {
          x: window.scrollX,
          y: window.scrollY
        },
        url: t
      };
      this.h.push(i), this.v = r;
      var o = {
        from: this.l,
        index: r,
        states: [].concat(this.h)
      };

      switch (e) {
        case "push":
          window.history && window.history.pushState(o, "", t);
          break;

        case "replace":
          window.history && window.history.replaceState(o, "", t);
      }
    }, e.update = function (t, n) {
      var e = n || this.v,
          i = r({}, this.get(e), {}, t);
      this.set(e, i);
    }, e.remove = function (t) {
      t ? this.h.splice(t, 1) : this.h.pop(), this.v--;
    }, e.clear = function () {
      this.h = [], this.v = -1;
    }, e.replace = function (t) {
      this.h = t;
    }, e.get = function (t) {
      return this.h[t];
    }, e.set = function (t, n) {
      return this.h[t] = n;
    }, e.p = function (t) {
      var n = "push",
          r = t,
          e = S.prefix + "-" + S.history;
      return r.hasAttribute && r.hasAttribute(e) && (n = r.getAttribute(e)), n;
    }, e.m = function (t) {
      return Math.abs(t) > 1 ? t > 0 ? "forward" : "back" : 0 === t ? "popstate" : t > 0 ? "back" : "forward";
    }, n(t, [{
      key: "current",
      get: function () {
        return this.h[this.v];
      }
    }, {
      key: "state",
      get: function () {
        return this.h[this.h.length - 1];
      }
    }, {
      key: "previous",
      get: function () {
        return this.v < 1 ? null : this.h[this.v - 1];
      }
    }, {
      key: "size",
      get: function () {
        return this.h.length;
      }
    }]), t;
  }())(),
      L = function (t, n) {
    try {
      var r = function () {
        if (!n.next.html) return Promise.resolve(t).then(function (t) {
          var r = n.next;

          if (t) {
            var e = j.toElement(t);
            r.namespace = j.getNamespace(e), r.container = j.getContainer(e), r.html = t, M.update({
              ns: r.namespace
            });
            var i = j.toDocument(t);
            document.title = i.title;
          }
        });
      }();

      return Promise.resolve(r && r.then ? r.then(function () {}) : void 0);
    } catch (t) {
      return Promise.reject(t);
    }
  },
      $ = d,
      _ = {
    __proto__: null,
    update: L,
    nextTick: function () {
      return new Promise(function (t) {
        window.requestAnimationFrame(t);
      });
    },
    pathToRegexp: $
  },
      q = function () {
    return window.location.origin;
  },
      B = function (t) {
    return void 0 === t && (t = window.location.href), U(t).port;
  },
      U = function (t) {
    var n,
        r = t.match(/:\d+/);
    if (null === r) /^http/.test(t) && (n = 80), /^https/.test(t) && (n = 443);else {
      var e = r[0].substring(1);
      n = parseInt(e, 10);
    }
    var i,
        o = t.replace(q(), ""),
        u = {},
        f = o.indexOf("#");
    f >= 0 && (i = o.slice(f + 1), o = o.slice(0, f));
    var s = o.indexOf("?");
    return s >= 0 && (u = D(o.slice(s + 1)), o = o.slice(0, s)), {
      hash: i,
      path: o,
      port: n,
      query: u
    };
  },
      D = function (t) {
    return t.split("&").reduce(function (t, n) {
      var r = n.split("=");
      return t[r[0]] = r[1], t;
    }, {});
  },
      F = function (t) {
    return void 0 === t && (t = window.location.href), t.replace(/(\/#.*|\/|#.*)$/, "");
  },
      H = {
    __proto__: null,
    getHref: function () {
      return window.location.href;
    },
    getOrigin: q,
    getPort: B,
    getPath: function (t) {
      return void 0 === t && (t = window.location.href), U(t).path;
    },
    parse: U,
    parseQuery: D,
    clean: F
  };

  function I(t, n, r) {
    return void 0 === n && (n = 2e3), new Promise(function (e, i) {
      var o = new XMLHttpRequest();
      o.onreadystatechange = function () {
        if (o.readyState === XMLHttpRequest.DONE) if (200 === o.status) e(o.responseText);else if (o.status) {
          var n = {
            status: o.status,
            statusText: o.statusText
          };
          r(t, n), i(n);
        }
      }, o.ontimeout = function () {
        var e = new Error("Timeout error [" + n + "]");
        r(t, e), i(e);
      }, o.onerror = function () {
        var n = new Error("Fetch error");
        r(t, n), i(n);
      }, o.open("GET", t), o.timeout = n, o.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), o.setRequestHeader("x-barba", "yes"), o.send();
    });
  }

  var C = function (t) {
    return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then;
  };

  function N(t, n) {
    return void 0 === n && (n = {}), function () {
      for (var r = arguments.length, e = new Array(r), i = 0; i < r; i++) e[i] = arguments[i];

      var o = !1,
          u = new Promise(function (r, i) {
        n.async = function () {
          return o = !0, function (t, n) {
            t ? i(t) : r(n);
          };
        };

        var u = t.apply(n, e);
        o || (C(u) ? u.then(r, i) : r(u));
      });
      return u;
    };
  }

  var X = new (function (t) {
    function n() {
      var n;
      return (n = t.call(this) || this).logger = new l("@barba/core"), n.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], n.registered = new Map(), n.init(), n;
    }

    e(n, t);
    var r = n.prototype;
    return r.init = function () {
      var t = this;
      this.registered.clear(), this.all.forEach(function (n) {
        t[n] || (t[n] = function (r, e) {
          t.registered.has(n) || t.registered.set(n, new Set()), t.registered.get(n).add({
            ctx: e || {},
            fn: r
          });
        });
      });
    }, r.do = function (t) {
      for (var n = this, r = arguments.length, e = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) e[i - 1] = arguments[i];

      if (this.registered.has(t)) {
        var o = Promise.resolve();
        return this.registered.get(t).forEach(function (t) {
          o = o.then(function () {
            return N(t.fn, t.ctx).apply(void 0, e);
          });
        }), o.catch(function (r) {
          n.logger.debug("Hook error [" + t + "]"), n.logger.error(r);
        });
      }

      return Promise.resolve();
    }, r.clear = function () {
      var t = this;
      this.all.forEach(function (n) {
        delete t[n];
      }), this.init();
    }, r.help = function () {
      this.logger.info("Available hooks: " + this.all.join(","));
      var t = [];
      this.registered.forEach(function (n, r) {
        return t.push(r);
      }), this.logger.info("Registered hooks: " + t.join(","));
    }, n;
  }(h))(),
      z = function () {
    function t(t) {
      if (this.P = [], "boolean" == typeof t) this.g = t;else {
        var n = Array.isArray(t) ? t : [t];
        this.P = n.map(function (t) {
          return $(t);
        });
      }
    }

    return t.prototype.checkHref = function (t) {
      if ("boolean" == typeof this.g) return this.g;
      var n = U(t).path;
      return this.P.some(function (t) {
        return null !== t.exec(n);
      });
    }, t;
  }(),
      G = function (t) {
    function n(n) {
      var r;
      return (r = t.call(this, n) || this).k = new Map(), r;
    }

    e(n, t);
    var i = n.prototype;
    return i.set = function (t, n, r) {
      return this.k.set(t, {
        action: r,
        request: n
      }), {
        action: r,
        request: n
      };
    }, i.get = function (t) {
      return this.k.get(t);
    }, i.getRequest = function (t) {
      return this.k.get(t).request;
    }, i.getAction = function (t) {
      return this.k.get(t).action;
    }, i.has = function (t) {
      return !this.checkHref(t) && this.k.has(t);
    }, i.delete = function (t) {
      return this.k.delete(t);
    }, i.update = function (t, n) {
      var e = r({}, this.k.get(t), {}, n);
      return this.k.set(t, e), e;
    }, n;
  }(z),
      Q = function () {
    return !window.history.pushState;
  },
      W = function (t) {
    return !t.el || !t.href;
  },
      J = function (t) {
    var n = t.event;
    return n.which > 1 || n.metaKey || n.ctrlKey || n.shiftKey || n.altKey;
  },
      K = function (t) {
    var n = t.el;
    return n.hasAttribute("target") && "_blank" === n.target;
  },
      V = function (t) {
    var n = t.el;
    return void 0 !== n.protocol && window.location.protocol !== n.protocol || void 0 !== n.hostname && window.location.hostname !== n.hostname;
  },
      Y = function (t) {
    var n = t.el;
    return void 0 !== n.port && B() !== B(n.href);
  },
      Z = function (t) {
    var n = t.el;
    return n.getAttribute && "string" == typeof n.getAttribute("download");
  },
      tt = function (t) {
    return t.el.hasAttribute(S.prefix + "-" + S.prevent);
  },
      nt = function (t) {
    return Boolean(t.el.closest("[" + S.prefix + "-" + S.prevent + '="all"]'));
  },
      rt = function (t) {
    var n = t.href;
    return F(n) === F() && B(n) === B();
  },
      et = function (t) {
    function n(n) {
      var r;
      return (r = t.call(this, n) || this).suite = [], r.tests = new Map(), r.init(), r;
    }

    e(n, t);
    var r = n.prototype;
    return r.init = function () {
      this.add("pushState", Q), this.add("exists", W), this.add("newTab", J), this.add("blank", K), this.add("corsDomain", V), this.add("corsPort", Y), this.add("download", Z), this.add("preventSelf", tt), this.add("preventAll", nt), this.add("sameUrl", rt, !1);
    }, r.add = function (t, n, r) {
      void 0 === r && (r = !0), this.tests.set(t, n), r && this.suite.push(t);
    }, r.run = function (t, n, r, e) {
      return this.tests.get(t)({
        el: n,
        event: r,
        href: e
      });
    }, r.checkLink = function (t, n, r) {
      var e = this;
      return this.suite.some(function (i) {
        return e.run(i, t, n, r);
      });
    }, n;
  }(z),
      it = function (t) {
    function n(r, e) {
      var i;
      void 0 === e && (e = "Barba error");

      for (var o = arguments.length, u = new Array(o > 2 ? o - 2 : 0), f = 2; f < o; f++) u[f - 2] = arguments[f];

      return (i = t.call.apply(t, [this].concat(u)) || this).error = r, i.label = e, Error.captureStackTrace && Error.captureStackTrace(function (t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t;
      }(i), n), i.name = "BarbaError", i;
    }

    return e(n, t), n;
  }(f(Error)),
      ot = function () {
    function t(t) {
      void 0 === t && (t = []), this.logger = new l("@barba/core"), this.all = [], this.page = [], this.once = [], this.A = [{
        name: "namespace",
        type: "strings"
      }, {
        name: "custom",
        type: "function"
      }], t && (this.all = this.all.concat(t)), this.update();
    }

    var n = t.prototype;
    return n.add = function (t, n) {
      switch (t) {
        case "rule":
          this.A.splice(n.position || 0, 0, n.value);
          break;

        case "transition":
        default:
          this.all.push(n);
      }

      this.update();
    }, n.resolve = function (t, n) {
      var r = this;
      void 0 === n && (n = {});
      var e = n.once ? this.once : this.page;
      e = e.filter(n.self ? function (t) {
        return t.name && "self" === t.name;
      } : function (t) {
        return !t.name || "self" !== t.name;
      });
      var i = new Map(),
          o = e.find(function (e) {
        var o = !0,
            u = {};
        return !(!n.self || "self" !== e.name) || (r.A.reverse().forEach(function (n) {
          o && (o = r.R(e, n, t, u), e.from && e.to && (o = r.R(e, n, t, u, "from") && r.R(e, n, t, u, "to")), e.from && !e.to && (o = r.R(e, n, t, u, "from")), !e.from && e.to && (o = r.R(e, n, t, u, "to")));
        }), i.set(e, u), o);
      }),
          u = i.get(o),
          f = [];

      if (f.push(n.once ? "once" : "page"), n.self && f.push("self"), u) {
        var s,
            c = [o];
        Object.keys(u).length > 0 && c.push(u), (s = this.logger).info.apply(s, ["Transition found [" + f.join(",") + "]"].concat(c));
      } else this.logger.info("No transition found [" + f.join(",") + "]");

      return o;
    }, n.update = function () {
      var t = this;
      this.all = this.all.map(function (n) {
        return t.T(n);
      }).sort(function (t, n) {
        return t.priority - n.priority;
      }).reverse().map(function (t) {
        return delete t.priority, t;
      }), this.page = this.all.filter(function (t) {
        return void 0 !== t.leave || void 0 !== t.enter;
      }), this.once = this.all.filter(function (t) {
        return void 0 !== t.once;
      });
    }, n.R = function (t, n, r, e, i) {
      var o = !0,
          u = !1,
          f = t,
          s = n.name,
          c = s,
          a = s,
          h = s,
          v = i ? f[i] : f,
          l = "to" === i ? r.next : r.current;

      if (i ? v && v[s] : v[s]) {
        switch (n.type) {
          case "strings":
          default:
            var d = Array.isArray(v[c]) ? v[c] : [v[c]];
            l[c] && -1 !== d.indexOf(l[c]) && (u = !0), -1 === d.indexOf(l[c]) && (o = !1);
            break;

          case "object":
            var m = Array.isArray(v[a]) ? v[a] : [v[a]];
            l[a] ? (l[a].name && -1 !== m.indexOf(l[a].name) && (u = !0), -1 === m.indexOf(l[a].name) && (o = !1)) : o = !1;
            break;

          case "function":
            v[h](r) ? u = !0 : o = !1;
        }

        u && (i ? (e[i] = e[i] || {}, e[i][s] = f[i][s]) : e[s] = f[s]);
      }

      return o;
    }, n.O = function (t, n, r) {
      var e = 0;
      return (t[n] || t.from && t.from[n] || t.to && t.to[n]) && (e += Math.pow(10, r), t.from && t.from[n] && (e += 1), t.to && t.to[n] && (e += 2)), e;
    }, n.T = function (t) {
      var n = this;
      t.priority = 0;
      var r = 0;
      return this.A.forEach(function (e, i) {
        r += n.O(t, e.name, i + 1);
      }), t.priority = r, t;
    }, t;
  }(),
      ut = function () {
    function t(t) {
      void 0 === t && (t = []), this.logger = new l("@barba/core"), this.S = !1, this.store = new ot(t);
    }

    var r = t.prototype;
    return r.get = function (t, n) {
      return this.store.resolve(t, n);
    }, r.doOnce = function (t) {
      var n = t.data,
          r = t.transition;

      try {
        var e = function () {
          i.S = !1;
        },
            i = this,
            o = r || {};

        i.S = !0;
        var u = s(function () {
          return Promise.resolve(i.j("beforeOnce", n, o)).then(function () {
            return Promise.resolve(i.once(n, o)).then(function () {
              return Promise.resolve(i.j("afterOnce", n, o)).then(function () {});
            });
          });
        }, function (t) {
          i.S = !1, i.logger.debug("Transition error [before/after/once]"), i.logger.error(t);
        });
        return Promise.resolve(u && u.then ? u.then(e) : e());
      } catch (t) {
        return Promise.reject(t);
      }
    }, r.doPage = function (t) {
      var n = t.data,
          r = t.transition,
          e = t.page,
          i = t.wrapper;

      try {
        var o = function (t) {
          if (u) return t;
          f.S = !1;
        },
            u = !1,
            f = this,
            c = r || {},
            a = !0 === c.sync || !1;

        f.S = !0;
        var h = s(function () {
          function t() {
            return Promise.resolve(f.j("before", n, c)).then(function () {
              var t = !1;

              function r(r) {
                return t ? r : Promise.resolve(f.remove(n)).then(function () {
                  return Promise.resolve(f.j("after", n, c)).then(function () {});
                });
              }

              var o = function () {
                if (a) return s(function () {
                  return Promise.resolve(f.add(n, i)).then(function () {
                    return Promise.resolve(f.j("beforeLeave", n, c)).then(function () {
                      return Promise.resolve(f.j("beforeEnter", n, c)).then(function () {
                        return Promise.resolve(Promise.all([f.leave(n, c), f.enter(n, c)])).then(function () {
                          return Promise.resolve(f.j("afterLeave", n, c)).then(function () {
                            return Promise.resolve(f.j("afterEnter", n, c)).then(function () {});
                          });
                        });
                      });
                    });
                  });
                }, function (t) {
                  if (f.M(t)) throw new it(t, "Transition error [sync]");
                });

                var r = function (r) {
                  return t ? r : s(function () {
                    var t = function () {
                      if (!1 !== o) return Promise.resolve(f.add(n, i)).then(function () {
                        return Promise.resolve(f.j("beforeEnter", n, c)).then(function () {
                          return Promise.resolve(f.enter(n, c, o)).then(function () {
                            return Promise.resolve(f.j("afterEnter", n, c)).then(function () {});
                          });
                        });
                      });
                    }();

                    if (t && t.then) return t.then(function () {});
                  }, function (t) {
                    if (f.M(t)) throw new it(t, "Transition error [before/after/enter]");
                  });
                },
                    o = !1,
                    u = s(function () {
                  return Promise.resolve(f.j("beforeLeave", n, c)).then(function () {
                    return Promise.resolve(Promise.all([f.leave(n, c), L(e, n)]).then(function (t) {
                      return t[0];
                    })).then(function (t) {
                      return o = t, Promise.resolve(f.j("afterLeave", n, c)).then(function () {});
                    });
                  });
                }, function (t) {
                  if (f.M(t)) throw new it(t, "Transition error [before/after/leave]");
                });

                return u && u.then ? u.then(r) : r(u);
              }();

              return o && o.then ? o.then(r) : r(o);
            });
          }

          var r = function () {
            if (a) return Promise.resolve(L(e, n)).then(function () {});
          }();

          return r && r.then ? r.then(t) : t();
        }, function (t) {
          if (f.S = !1, t.name && "BarbaError" === t.name) throw f.logger.debug(t.label), f.logger.error(t.error), t;
          throw f.logger.debug("Transition error [page]"), f.logger.error(t), t;
        });
        return Promise.resolve(h && h.then ? h.then(o) : o(h));
      } catch (t) {
        return Promise.reject(t);
      }
    }, r.once = function (t, n) {
      try {
        return Promise.resolve(X.do("once", t, n)).then(function () {
          return n.once ? N(n.once, n)(t) : Promise.resolve();
        });
      } catch (t) {
        return Promise.reject(t);
      }
    }, r.leave = function (t, n) {
      try {
        return Promise.resolve(X.do("leave", t, n)).then(function () {
          return n.leave ? N(n.leave, n)(t) : Promise.resolve();
        });
      } catch (t) {
        return Promise.reject(t);
      }
    }, r.enter = function (t, n, r) {
      try {
        return Promise.resolve(X.do("enter", t, n)).then(function () {
          return n.enter ? N(n.enter, n)(t, r) : Promise.resolve();
        });
      } catch (t) {
        return Promise.reject(t);
      }
    }, r.add = function (t, n) {
      try {
        return j.addContainer(t.next.container, n), X.do("nextAdded", t), Promise.resolve();
      } catch (t) {
        return Promise.reject(t);
      }
    }, r.remove = function (t) {
      try {
        return j.removeContainer(t.current.container), X.do("currentRemoved", t), Promise.resolve();
      } catch (t) {
        return Promise.reject(t);
      }
    }, r.M = function (t) {
      return t.message ? !/Timeout error|Fetch error/.test(t.message) : !t.status;
    }, r.j = function (t, n, r) {
      try {
        return Promise.resolve(X.do(t, n, r)).then(function () {
          return r[t] ? N(r[t], r)(n) : Promise.resolve();
        });
      } catch (t) {
        return Promise.reject(t);
      }
    }, n(t, [{
      key: "isRunning",
      get: function () {
        return this.S;
      },
      set: function (t) {
        this.S = t;
      }
    }, {
      key: "hasOnce",
      get: function () {
        return this.store.once.length > 0;
      }
    }, {
      key: "hasSelf",
      get: function () {
        return this.store.all.some(function (t) {
          return "self" === t.name;
        });
      }
    }, {
      key: "shouldWait",
      get: function () {
        return this.store.all.some(function (t) {
          return t.to && !t.to.route || t.sync;
        });
      }
    }]), t;
  }(),
      ft = function () {
    function t(t) {
      var n = this;
      this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map(), 0 !== t.length && (t.forEach(function (t) {
        n.byNamespace.set(t.namespace, t);
      }), this.names.forEach(function (t) {
        X[t](n.L(t));
      }));
    }

    return t.prototype.L = function (t) {
      var n = this;
      return function (r) {
        var e = t.match(/enter/i) ? r.next : r.current,
            i = n.byNamespace.get(e.namespace);
        return i && i[t] ? N(i[t], i)(r) : Promise.resolve();
      };
    }, t;
  }();

  Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (t) {
    var n = this;

    do {
      if (n.matches(t)) return n;
      n = n.parentElement || n.parentNode;
    } while (null !== n && 1 === n.nodeType);

    return null;
  });
  var st = {
    container: null,
    html: "",
    namespace: "",
    url: {
      hash: "",
      href: "",
      path: "",
      port: null,
      query: {}
    }
  };
  return new (function () {
    function t() {
      this.version = a, this.schemaPage = st, this.Logger = l, this.logger = new l("@barba/core"), this.plugins = [], this.hooks = X, this.dom = j, this.helpers = _, this.history = M, this.request = I, this.url = H;
    }

    var e = t.prototype;
    return e.use = function (t, n) {
      var r = this.plugins;
      r.indexOf(t) > -1 ? this.logger.warn("Plugin [" + t.name + "] already installed.") : "function" == typeof t.install ? (t.install(this, n), r.push(t)) : this.logger.warn("Plugin [" + t.name + '] has no "install" method.');
    }, e.init = function (t) {
      var n = void 0 === t ? {} : t,
          e = n.transitions,
          i = void 0 === e ? [] : e,
          o = n.views,
          u = void 0 === o ? [] : o,
          f = n.schema,
          s = void 0 === f ? S : f,
          c = n.requestError,
          a = n.timeout,
          h = void 0 === a ? 2e3 : a,
          v = n.cacheIgnore,
          d = void 0 !== v && v,
          m = n.prefetchIgnore,
          p = void 0 !== m && m,
          w = n.preventRunning,
          b = void 0 !== w && w,
          y = n.prevent,
          P = void 0 === y ? null : y,
          g = n.debug,
          E = n.logLevel;
      if (l.setLevel(!0 === (void 0 !== g && g) ? "debug" : void 0 === E ? "off" : E), this.logger.info(this.version), Object.keys(s).forEach(function (t) {
        S[t] && (S[t] = s[t]);
      }), this.$ = c, this.timeout = h, this.cacheIgnore = d, this.prefetchIgnore = p, this.preventRunning = b, this._ = this.dom.getWrapper(), !this._) throw new Error("[@barba/core] No Barba wrapper found");
      this._.setAttribute("aria-live", "polite"), this.q();
      var x = this.data.current;
      if (!x.container) throw new Error("[@barba/core] No Barba container found");

      if (this.cache = new G(d), this.prevent = new et(p), this.transitions = new ut(i), this.views = new ft(u), null !== P) {
        if ("function" != typeof P) throw new Error("[@barba/core] Prevent should be a function");
        this.prevent.add("preventCustom", P);
      }

      this.history.init(x.url.href, x.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach(function (t) {
        return t.init();
      });
      var k = this.data;
      k.trigger = "barba", k.next = k.current, k.current = r({}, this.schemaPage), this.hooks.do("ready", k), this.once(k), this.q();
    }, e.destroy = function () {
      this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = [];
    }, e.force = function (t) {
      window.location.assign(t);
    }, e.go = function (t, n, r) {
      var e;
      if (void 0 === n && (n = "barba"), this.transitions.isRunning) this.force(t);else if (!(e = "popstate" === n ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) : this.prevent.run("sameUrl", null, null, t)) || this.transitions.hasSelf) return n = this.history.change(t, n, r), r && (r.stopPropagation(), r.preventDefault()), this.page(t, n, e);
    }, e.once = function (t) {
      try {
        var n = this;
        return Promise.resolve(n.hooks.do("beforeEnter", t)).then(function () {
          function r() {
            return Promise.resolve(n.hooks.do("afterEnter", t)).then(function () {});
          }

          var e = function () {
            if (n.transitions.hasOnce) {
              var r = n.transitions.get(t, {
                once: !0
              });
              return Promise.resolve(n.transitions.doOnce({
                transition: r,
                data: t
              })).then(function () {});
            }
          }();

          return e && e.then ? e.then(r) : r();
        });
      } catch (t) {
        return Promise.reject(t);
      }
    }, e.page = function (t, n, e) {
      try {
        var i = function () {
          var t = o.data;
          return Promise.resolve(o.hooks.do("page", t)).then(function () {
            var n = s(function () {
              var n = o.transitions.get(t, {
                once: !1,
                self: e
              });
              return Promise.resolve(o.transitions.doPage({
                data: t,
                page: u,
                transition: n,
                wrapper: o._
              })).then(function () {
                o.q();
              });
            }, function () {
              0 === l.getLevel() && o.force(t.current.url.href);
            });
            if (n && n.then) return n.then(function () {});
          });
        },
            o = this;

        o.data.next.url = r({
          href: t
        }, o.url.parse(t)), o.data.trigger = n;

        var u = o.cache.has(t) ? o.cache.update(t, {
          action: "click"
        }).request : o.cache.set(t, o.request(t, o.timeout, o.onRequestError.bind(o, n)), "click").request,
            f = function () {
          if (o.transitions.shouldWait) return Promise.resolve(L(u, o.data)).then(function () {});
        }();

        return Promise.resolve(f && f.then ? f.then(i) : i());
      } catch (t) {
        return Promise.reject(t);
      }
    }, e.onRequestError = function (t) {
      this.transitions.isRunning = !1;

      for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), e = 1; e < n; e++) r[e - 1] = arguments[e];

      var i = r[0],
          o = r[1],
          u = this.cache.getAction(i);
      return this.cache.delete(i), !(this.$ && !1 === this.$(t, u, i, o) || ("click" === u && this.force(i), 1));
    }, e.prefetch = function (t) {
      var n = this;
      this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, "barba")).catch(function (t) {
        n.logger.error(t);
      }), "prefetch");
    }, e.F = function () {
      !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B), document.addEventListener("touchstart", this.B)), document.addEventListener("click", this.U), window.addEventListener("popstate", this.D);
    }, e.H = function () {
      !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B), document.removeEventListener("touchstart", this.B)), document.removeEventListener("click", this.U), window.removeEventListener("popstate", this.D);
    }, e.B = function (t) {
      var n = this,
          r = this.I(t);

      if (r) {
        var e = this.dom.getHref(r);
        this.prevent.checkHref(e) || this.cache.has(e) || this.cache.set(e, this.request(e, this.timeout, this.onRequestError.bind(this, r)).catch(function (t) {
          n.logger.error(t);
        }), "enter");
      }
    }, e.U = function (t) {
      var n = this.I(t);
      if (n) return this.transitions.isRunning && this.preventRunning ? (t.preventDefault(), void t.stopPropagation()) : void this.go(this.dom.getHref(n), n, t);
    }, e.D = function (t) {
      this.go(this.url.getHref(), "popstate", t);
    }, e.I = function (t) {
      for (var n = t.target; n && !this.dom.getHref(n);) n = n.parentNode;

      if (n && !this.prevent.checkLink(n, t, this.dom.getHref(n))) return n;
    }, e.q = function () {
      var t = this.url.getHref(),
          n = {
        container: this.dom.getContainer(),
        html: this.dom.getHtml(),
        namespace: this.dom.getNamespace(),
        url: r({
          href: t
        }, this.url.parse(t))
      };
      this.C = {
        current: n,
        next: r({}, this.schemaPage),
        trigger: void 0
      }, this.hooks.do("reset", this.data);
    }, n(t, [{
      key: "data",
      get: function () {
        return this.C;
      }
    }, {
      key: "wrapper",
      get: function () {
        return this._;
      }
    }]), t;
  }())();
});

/***/ }),

/***/ "./node_modules/@maeertin/medialoaded/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@maeertin/medialoaded/index.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;

(function (window, factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return factory(window);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(typeof window !== 'undefined' ? window : this, function factory(window) {
  function makeArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    var isArrayLike = typeof value === 'object' && typeof value.length === 'number';

    if (isArrayLike) {
      return Array.prototype.slice.call(value);
    }

    return [value];
  }

  function mediaLoaded(el, onComplete) {
    var elements = el;

    if (typeof el === 'string') {
      elements = document.querySelectorAll(el);
    }

    if (!elements) {
      console.error('mediaLoaded: Invalid element', el);
      return;
    }

    elements = makeArray(elements);
    var images = [];
    var videos = [];
    var posters = []; // Find all videos & images

    elements.forEach(function (element) {
      if (element.tagName === 'IMG') {
        images.unshift(element);
      } else if (element.tagName === 'VIDEO') {
        videos.unshift(element);
      } else {
        images = images.concat(makeArray(element.getElementsByTagName('img')));
        videos = videos.concat(makeArray(element.getElementsByTagName('video')));
      }
    }); // Find all posters

    videos.forEach(function (video) {
      if (video.poster) {
        var poster = new Image();
        poster.src = video.poster;
        posters.push(poster);
      }
    }); // With all posters found, filter out non autoplay videos for touch devices
    // as video events won't trigger until user interaction.

    var isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    if (isTouch) {
      videos = videos.filter(function (video) {
        return video.autoplay;
      });
    }

    var total = images.length + videos.length + posters.length;
    var hasBroken = false;
    var count = 0;

    function complete() {
      if (onComplete) {
        onComplete({
          images: images,
          videos: videos,
          posters: posters,
          hasBroken: hasBroken,
          total: total
        });
      }
    }

    function handleMediaLoaded(event) {
      if (event) {
        event.target.removeEventListener(event.type, handleMediaLoaded);

        if (event.type === 'error') {
          hasBroken = true;
        }
      }

      count += 1;

      if (total === count) {
        complete();
      }
    } // Complete if no media found.


    if (total === 0) {
      complete();
      return;
    }

    images.concat(posters).forEach(function (image) {
      // Check for non-zero, non-undefined naturalWidth
      if (!image.complete || !image.naturalWidth) {
        image.addEventListener('load', handleMediaLoaded);
        image.addEventListener('error', handleMediaLoaded);
      } else {
        handleMediaLoaded();
      }
    });
    videos.forEach(function (video) {
      if (video.readyState < 2) {
        video.addEventListener('loadeddata', handleMediaLoaded);
        video.addEventListener('error', handleMediaLoaded);
      } else {
        handleMediaLoaded();
      }
    });
  }

  return mediaLoaded;
});

/***/ }),

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSPlugin": () => (/* binding */ CSSPlugin),
/* harmony export */   "_createElement": () => (/* binding */ _createElement),
/* harmony export */   "_getBBox": () => (/* binding */ _getBBox),
/* harmony export */   "checkPrefix": () => (/* binding */ _checkPropPrefix),
/* harmony export */   "default": () => (/* binding */ CSSPlugin)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.10.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; // ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
  var cap = 360,
      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;

        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + "") || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else {
            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }

        props.push(p);
      }
    }

    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": () => (/* binding */ Animation),
/* harmony export */   "Back": () => (/* binding */ Back),
/* harmony export */   "Bounce": () => (/* binding */ Bounce),
/* harmony export */   "Circ": () => (/* binding */ Circ),
/* harmony export */   "Cubic": () => (/* binding */ Cubic),
/* harmony export */   "Elastic": () => (/* binding */ Elastic),
/* harmony export */   "Expo": () => (/* binding */ Expo),
/* harmony export */   "GSCache": () => (/* binding */ GSCache),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Power0": () => (/* binding */ Power0),
/* harmony export */   "Power1": () => (/* binding */ Power1),
/* harmony export */   "Power2": () => (/* binding */ Power2),
/* harmony export */   "Power3": () => (/* binding */ Power3),
/* harmony export */   "Power4": () => (/* binding */ Power4),
/* harmony export */   "PropTween": () => (/* binding */ PropTween),
/* harmony export */   "Quad": () => (/* binding */ Quad),
/* harmony export */   "Quart": () => (/* binding */ Quart),
/* harmony export */   "Quint": () => (/* binding */ Quint),
/* harmony export */   "Sine": () => (/* binding */ Sine),
/* harmony export */   "SteppedEase": () => (/* binding */ SteppedEase),
/* harmony export */   "Strong": () => (/* binding */ Strong),
/* harmony export */   "Timeline": () => (/* binding */ Timeline),
/* harmony export */   "TimelineLite": () => (/* binding */ Timeline),
/* harmony export */   "TimelineMax": () => (/* binding */ Timeline),
/* harmony export */   "Tween": () => (/* binding */ Tween),
/* harmony export */   "TweenLite": () => (/* binding */ Tween),
/* harmony export */   "TweenMax": () => (/* binding */ Tween),
/* harmony export */   "_checkPlugin": () => (/* binding */ _checkPlugin),
/* harmony export */   "_colorExp": () => (/* binding */ _colorExp),
/* harmony export */   "_colorStringFilter": () => (/* binding */ _colorStringFilter),
/* harmony export */   "_config": () => (/* binding */ _config),
/* harmony export */   "_forEachName": () => (/* binding */ _forEachName),
/* harmony export */   "_getCache": () => (/* binding */ _getCache),
/* harmony export */   "_getProperty": () => (/* binding */ _getProperty),
/* harmony export */   "_getSetter": () => (/* binding */ _getSetter),
/* harmony export */   "_isString": () => (/* binding */ _isString),
/* harmony export */   "_isUndefined": () => (/* binding */ _isUndefined),
/* harmony export */   "_missingPlugin": () => (/* binding */ _missingPlugin),
/* harmony export */   "_numExp": () => (/* binding */ _numExp),
/* harmony export */   "_numWithUnitExp": () => (/* binding */ _numWithUnitExp),
/* harmony export */   "_parseRelative": () => (/* binding */ _parseRelative),
/* harmony export */   "_plugins": () => (/* binding */ _plugins),
/* harmony export */   "_relExp": () => (/* binding */ _relExp),
/* harmony export */   "_removeLinkedListItem": () => (/* binding */ _removeLinkedListItem),
/* harmony export */   "_renderComplexString": () => (/* binding */ _renderComplexString),
/* harmony export */   "_replaceRandom": () => (/* binding */ _replaceRandom),
/* harmony export */   "_round": () => (/* binding */ _round),
/* harmony export */   "_roundModifier": () => (/* binding */ _roundModifier),
/* harmony export */   "_setDefaults": () => (/* binding */ _setDefaults),
/* harmony export */   "_sortPropTweensByPriority": () => (/* binding */ _sortPropTweensByPriority),
/* harmony export */   "_ticker": () => (/* binding */ _ticker),
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "default": () => (/* binding */ gsap),
/* harmony export */   "distribute": () => (/* binding */ distribute),
/* harmony export */   "getUnit": () => (/* binding */ getUnit),
/* harmony export */   "gsap": () => (/* binding */ gsap),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "mapRange": () => (/* binding */ mapRange),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "pipe": () => (/* binding */ pipe),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "selector": () => (/* binding */ selector),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "snap": () => (/* binding */ snap),
/* harmony export */   "splitColor": () => (/* binding */ splitColor),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "unitize": () => (/* binding */ unitize),
/* harmony export */   "wrap": () => (/* binding */ wrap),
/* harmony export */   "wrapYoyo": () => (/* binding */ wrapYoyo)
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_parseRelative = function _parseRelative(start, value) {
  var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function (t, d, f, v) {
        callback(t, d, f, v);

        _self.remove(func);
      } : callback;

      _self.remove(callback);

      _listeners[prioritize ? "unshift" : "push"](func);

      _wake();

      return func;
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return _recacheAncestors(this);
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_forceAllPropTweens,
    _initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);

    if (prevStartAt) {
      _removeFromParent(prevStartAt.render(-1, true));

      prevStartAt._lazy = 0;
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      lookup,
      i;

  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;

    while (i--) {
      pt = lookup[i][property];

      if (pt && pt.d && pt.d._pt) {
        // it's a plugin, so find the nested PropTween
        pt = pt.d._pt;

        while (pt && pt.p !== property) {
          pt = pt._next;
        }
      }

      if (!pt) {
        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

        tween.vars[property] = "+=0";

        _initTween(tween, time);

        _forceAllPropTweens = 0;
        return 1;
      }

      ptCache.push(pt);
    }
  }

  i = ptCache.length;

  while (i--) {
    pt = ptCache[i];
    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    pt.e && (pt.e = _round(value) + getUnit(pt.e)); // mainly for CSSPlugin (end value)

    pt.b && (pt.b = pt.s + getUnit(pt.b)); // (beginning value)
  }
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (prevTime !== this._time) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
      return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}


    _alignPlayhead(this, 0);

    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge2;

    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
        func = function func(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };

    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.10.4";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Back": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),
/* harmony export */   "Bounce": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),
/* harmony export */   "CSSPlugin": () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),
/* harmony export */   "Circ": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),
/* harmony export */   "Cubic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),
/* harmony export */   "Elastic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),
/* harmony export */   "Expo": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),
/* harmony export */   "Linear": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),
/* harmony export */   "Power0": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),
/* harmony export */   "Power1": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),
/* harmony export */   "Power2": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),
/* harmony export */   "Power3": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),
/* harmony export */   "Power4": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),
/* harmony export */   "Quad": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),
/* harmony export */   "Quart": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),
/* harmony export */   "Quint": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),
/* harmony export */   "Sine": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),
/* harmony export */   "SteppedEase": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),
/* harmony export */   "Strong": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),
/* harmony export */   "TimelineLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),
/* harmony export */   "TimelineMax": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),
/* harmony export */   "TweenLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),
/* harmony export */   "TweenMax": () => (/* binding */ TweenMaxWithCSS),
/* harmony export */   "default": () => (/* binding */ gsapWithCSS),
/* harmony export */   "gsap": () => (/* binding */ gsapWithCSS)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");


var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ "./src/classes/Animation.js":
/*!**********************************!*\
  !*** ./src/classes/Animation.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Animation)
/* harmony export */ });
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
 ////////////////////////////////////////////////////////////////
//
//  ANIMATION
//
////////////////////////////////////////////////////////////////

class Animation {
  constructor() {} ////////////////////////////////////////////////////////////////
  //
  //  TEST HELLO
  //
  ////////////////////////////////////////////////////////////////


  hello() {
    console.log("HELLO");
  } ////////////////////////////////////////////////////////////////
  //
  //  BLOCK TEXT
  //
  ////////////////////////////////////////////////////////////////


  textIn(target_) {
    let id = target_.el.dataset.id;
    let t = document.querySelector('[data-id="' + id + '"]');
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].fromTo(t, {
      yPercent: 20,
      rotate: 3,
      opacity: 0
    }, {
      duration: 2,
      ease: "power2.out",
      opacity: 1,
      rotate: 0,
      yPercent: 0
    });
  } ////////////////////////////////////////////////////////////////
  //
  //  BLOCK IMAGES
  //
  ////////////////////////////////////////////////////////////////


  imageIn(target_) {
    let id = target_.el.dataset.id;
    let t = document.querySelector('[data-id="' + id + '"]');
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].fromTo(t, {
      yPercent: 20,
      opacity: 0
    }, {
      duration: 2,
      ease: "power2.out",
      yPercent: 0,
      opacity: 1
    });
  } ////////////////////////////////////////////////////////////////
  //
  //  BLOCK VIDEO
  //
  ////////////////////////////////////////////////////////////////


  videoIn(target_) {
    let id = target_.el.dataset.id;
    let t = document.querySelector('[data-id="' + id + '"]');
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].fromTo(t, {
      yPercent: 20,
      opacity: 0
    }, {
      duration: 2,
      ease: "power2.out",
      yPercent: 0,
      opacity: 1
    });
  }

}

/***/ }),

/***/ "./src/classes/Loader.js":
/*!*******************************!*\
  !*** ./src/classes/Loader.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Loader)
/* harmony export */ });
/* harmony import */ var _maeertin_medialoaded__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @maeertin/medialoaded */ "./node_modules/@maeertin/medialoaded/index.js");
/* harmony import */ var _maeertin_medialoaded__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_maeertin_medialoaded__WEBPACK_IMPORTED_MODULE_0__);
 ////////////////////////////////////////////////////////////////
//
//  LOADER
//
////////////////////////////////////////////////////////////////

class Loader {
  constructor() {
    this.loadMedia();
  }

  loadMedia() {
    const preloadImg = new Promise(resolve => {});
    const elements = document.querySelectorAll(".video");
    console.log(elements);
    _maeertin_medialoaded__WEBPACK_IMPORTED_MODULE_0___default()(elements, instance => {
      console.log("All media loaded", instance);
    });
    let allDone = [preloadImg];
    Promise.all(allDone).then(() => {
      console.log("MEDIA LOADED");
    });
  }

}

/***/ }),

/***/ "./src/classes/Navigation.js":
/*!***********************************!*\
  !*** ./src/classes/Navigation.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Navigation)
/* harmony export */ });
/* harmony import */ var _utils_responsive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/responsive */ "./src/utils/responsive.js");
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");

 // import { transition } from "../index";
////////////////////////////////////////////////////////////////
//
//  MENU
//
////////////////////////////////////////////////////////////////

class Navigation {
  constructor() {
    this.menu = document.querySelector("#menu");
    this.menu_trigger = document.querySelector("#menu_trigger");
    this.menu_status = "off";
    this.menu_animation_time = 1;
    this.menu_ease = "power2.inOut";
    this.primary_menu = document.querySelector("#primary-menu");
    this.li_list = this.primary_menu.querySelectorAll("li");
    this.home_url = document.querySelector("#logo").href;
    this.menuTrigger();
  }

  menuTrigger() {
    this.menu_trigger.addEventListener("click", e => {
      if (this.menu_trigger.classList.contains("active")) {
        this.closeMenu();
      } else {
        this.menu_trigger.classList.add("active");
        this.menu_status = "on";
        this.openMenu();
      }
    });
  }

  openMenu() {
    this.menu_trigger.classList.add("active");
    this.menu_status = "on";
    gsap__WEBPACK_IMPORTED_MODULE_1__["default"].to("#menu", {
      duration: this.menu_animation_time,
      ease: this.menu_ease,
      height: "100%"
    });
    gsap__WEBPACK_IMPORTED_MODULE_1__["default"].fromTo("#menu li a", {
      yPercent: -100
    }, {
      delay: 0.5,
      duration: 0.8,
      ease: "power3.out",
      yPercent: 0,
      stagger: 0.1
    });
  }

  closeMenu() {
    this.menu_trigger.classList.remove("active");
    this.menu_status = "off";
    gsap__WEBPACK_IMPORTED_MODULE_1__["default"].to("#menu", {
      duration: this.menu_animation_time,
      ease: this.menu_ease,
      height: 0
    });
  }

  test() {
    if (_utils_responsive__WEBPACK_IMPORTED_MODULE_0__.rsp(RSP_MD)) {
      console.log("BIGGER THAN MOBILE");
    }
  }

}

/***/ }),

/***/ "./src/classes/RAF.js":
/*!****************************!*\
  !*** ./src/classes/RAF.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RAF)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index */ "./src/index.js");
 ////////////////////////////////////////////////////////////////
//
//  RAF
//
////////////////////////////////////////////////////////////////

class RAF {
  constructor() {}

  render() {
    _index__WEBPACK_IMPORTED_MODULE_0__.scroll.info();
    _index__WEBPACK_IMPORTED_MODULE_0__.scroll.optimisation();
    window.requestAnimationFrame(this.render.bind(this));
  }

}

/***/ }),

/***/ "./src/classes/Transition.js":
/*!***********************************!*\
  !*** ./src/classes/Transition.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Transition)
/* harmony export */ });
/* harmony import */ var _barba_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @barba/core */ "./node_modules/@barba/core/dist/barba.umd.js");
/* harmony import */ var _barba_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_barba_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ "./src/index.js");
 // import gsap from 'gsap';

 // import { animation } from '../index';
// import { navigation } from '../index';

 ////////////////////////////////////////////////////////////////
//
//  TRANSITIONS
//
////////////////////////////////////////////////////////////////

class Transition {
  constructor() {
    this.init();
  }

  init() {
    let that = this;
    _barba_core__WEBPACK_IMPORTED_MODULE_0___default().init({
      debug: true,
      transitions: [{
        ////////////////////////////////////////////////////////////////
        //
        //  DEFAULT
        //
        ////////////////////////////////////////////////////////////////
        name: "default-transition",

        leave(data) {//
          // console.log('LEAVE');
        },

        enter(data) {//
          // console.log('ENTER');
        },

        after(data) {
          //
          // console.log('AFTER');
          _index__WEBPACK_IMPORTED_MODULE_1__.videoblock.startAutoplay();
          _index__WEBPACK_IMPORTED_MODULE_1__.videoblock.coverAction();
          _index__WEBPACK_IMPORTED_MODULE_1__.scroll.reset();
        }

      }]
    });
  }

  link(link_) {
    let link = link_;
    _barba_core__WEBPACK_IMPORTED_MODULE_0___default().go(link);
  }

}

/***/ }),

/***/ "./src/classes/Videoblock.js":
/*!***********************************!*\
  !*** ./src/classes/Videoblock.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Videoblock)
/* harmony export */ });
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap */ "./node_modules/gsap/index.js");
 ////////////////////////////////////////////////////////////////
//
//  VIDEO BLOCK
//
////////////////////////////////////////////////////////////////

class Videoblock {
  constructor() {
    this.startAutoplay();
    this.coverAction();
  }

  startAutoplay() {
    let video_list = document.querySelectorAll(".block_video .video");
    video_list.forEach(o => {
      o.play();
    });
  }

  coverAction() {
    let video_list = document.querySelectorAll(".block_video .cover");
    video_list.forEach(o => {
      let parent = o.parentNode;
      let embedded = parent.querySelector(".embedded iframe");
      o.addEventListener("pointerdown", event => {
        embedded.src += "&autoplay=1";
        this.hideCover(o);
      });
    });
  }

  hideCover(target_) {
    let t = target_;
    gsap__WEBPACK_IMPORTED_MODULE_0__["default"].to(t, {
      duration: 1,
      ease: "power2.inOut",
      opacity: 0,
      onComplete: () => {
        t.remove();
      }
    });
  }

}

/***/ }),

/***/ "./src/globals.js":
/*!************************!*\
  !*** ./src/globals.js ***!
  \************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

////////////////////////////////////////////////////////////////
//
//  GLOBALS
//
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
//  RESPONSIVE BREAKPOINTS (BASED ON BOOTSTRAP)
//
////////////////////////////////////////////////////////////////
__webpack_require__.g.RSP_XXS = 320;
__webpack_require__.g.RSP_XS = 375;
__webpack_require__.g.RSP_SM = 768;
__webpack_require__.g.RSP_MD = 992;
__webpack_require__.g.RSP_LG = 1200;
__webpack_require__.g.RSP_XL = 1400;
__webpack_require__.g.RSP_XXL = 1600;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animation": () => (/* binding */ animation),
/* harmony export */   "navigation": () => (/* binding */ navigation),
/* harmony export */   "scroll": () => (/* binding */ scroll),
/* harmony export */   "transition": () => (/* binding */ transition),
/* harmony export */   "videoblock": () => (/* binding */ videoblock)
/* harmony export */ });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "./src/globals.js");
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_globals__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_responsive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/responsive */ "./src/utils/responsive.js");
/* harmony import */ var _classes_Navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/Navigation */ "./src/classes/Navigation.js");
/* harmony import */ var _classes_Scroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/Scroll */ "./src/classes/Scroll.js");
/* harmony import */ var _classes_Animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/Animation */ "./src/classes/Animation.js");
/* harmony import */ var _classes_Transition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./classes/Transition */ "./src/classes/Transition.js");
/* harmony import */ var _classes_RAF__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/RAF */ "./src/classes/RAF.js");
/* harmony import */ var _classes_Videoblock__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./classes/Videoblock */ "./src/classes/Videoblock.js");
/* harmony import */ var _classes_Loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./classes/Loader */ "./src/classes/Loader.js");









_utils_responsive__WEBPACK_IMPORTED_MODULE_1__.cssSetTouchDevices("html", "touch", "no_touch");
const navigation = new _classes_Navigation__WEBPACK_IMPORTED_MODULE_2__["default"]();
const scroll = new _classes_Scroll__WEBPACK_IMPORTED_MODULE_3__["default"]();
const transition = new _classes_Transition__WEBPACK_IMPORTED_MODULE_5__["default"]();
const animation = new _classes_Animation__WEBPACK_IMPORTED_MODULE_4__["default"]();
const raf = new _classes_RAF__WEBPACK_IMPORTED_MODULE_6__["default"]();
const videoblock = new _classes_Videoblock__WEBPACK_IMPORTED_MODULE_7__["default"]();
const loader = new _classes_Loader__WEBPACK_IMPORTED_MODULE_8__["default"]();
console.log(scroll);
window.addEventListener("load", () => {
  loader.hideLoader();
  scroll.init();
  scroll.action();
  raf.render();
});
const header = document.querySelector("#header");
window.addEventListener("scroll", e => {
  if (window.scrollY >= 200) {
    header.classList.add("sticky");
  } else {
    header.classList.remove("sticky");
  }
});

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("f8bd5f1d854a98823766")
/******/ })();
/******/ 
/******/ }
);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLjI0YzlkODNjNTI5MjFlOWFmY2NhLmhvdC11cGRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBb09BOztFQUFBLFNBOFVnQkEsQ0E5VWhCLENBOFV1QkMsQ0E5VXZCLEVBOFU2QkMsQ0E5VTdCLEVBOFU2QkE7SUFDNUI7TUFDQyxJQUFJQyxJQUFTRixHQUFiO0lBQ0MsQ0FGRixDQUVFLE9BQU1HLENBQU4sRUFBTUE7TUFDUCxPQUFPRixFQUFRRSxDQUFSRixDQUFQO0lBRUQ7O0lBQUEsT0FBSUMsS0FBVUEsRUFBT0UsSUFBakJGLEdBQ0lBLEVBQU9FLElBQVBGLENBQU9FLEtBQUssQ0FBWkYsRUFBb0JELENBQXBCQyxDQURKQSxHQUdHQSxDQUhQO0VBcFo4RDs7RUFBQSxzQkFBWEcsTUFBVyxLQUFlQSxPQUFPQyxRQUFQRCxLQUFvQkEsT0FBT0MsUUFBUEQsR0FBa0JBLE9BQU8saUJBQVBBLENBQXRDQSxDQUFmLEdBNkRLLHNCQUFYQSxNQUFXLEtBQWVBLE9BQU9FLGFBQVBGLEtBQXlCQSxPQUFPRSxhQUFQRixHQUF1QkEsT0FBTyxzQkFBUEEsQ0FBaERBLENBQWYsQ0E3REw7O0VBNkQyRSxJQzNNOUhHLENEMk04SDtFQUFBLElDM005SEEsV0QyTThIO0VBQUEsSUV4TDdIQyxrQkZ3TDZIOztFRXhMN0hBLENEbkJiLFVBQVlELENBQVosRUFBWUE7SUFDVkEsc0JBQ0FBLHdCQURBQSxFQUVBQSw0QkFGQUEsRUFHQUEsc0JBSEFBLEVBSUFBLHdCQUpBQTtFQURGLEVBQVlBLGFBQVosQ0NtQmFDOztFRFJiLElBQUlDLElBQWlCRixFQUFVRyxHQUEvQjtFQUFBLElBRWFDO0lBeUJYLFdBQVlDLENBQVosRUFBWUE7TUFDVkMsS0FBS0MsQ0FBTEQsR0FBZUQsQ0FBZkM7SUExQkpGOztJQUFBQSxFQUlnQkks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QUFDSixJQUFQO0VBQ0FJLE1BQU0sQ0FBQ2lCLE1BQVA7RUFDQW9zQyxHQUFHLENBQUNqbEIsTUFBSjtBQUNELENBTEQ7QUFPQSxNQUFNb2xCLE1BQU0sR0FBR3R3QyxRQUFRLENBQUNRLGFBQVQsQ0FBdUIsU0FBdkIsQ0FBZjtBQUVBd0MsTUFBTSxDQUFDaVEsZ0JBQVAsQ0FBd0IsUUFBeEIsRUFBbUNqYixDQUFELElBQU87RUFDdkMsSUFBSWdMLE1BQU0sQ0FBQ0csT0FBUCxJQUFrQixHQUF0QixFQUEyQjtJQUN6Qm10QyxNQUFNLENBQUNsQyxTQUFQLENBQWlCdnFDLEdBQWpCLENBQXFCLFFBQXJCO0VBQ0QsQ0FGRCxNQUVPO0lBQ0x5c0MsTUFBTSxDQUFDbEMsU0FBUCxDQUFpQi9wQyxNQUFqQixDQUF3QixRQUF4QjtFQUNEO0FBQ0YsQ0FORDs7Ozs7Ozs7VUNyQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1hc3luYy10by1wcm9taXNlcy9oZWxwZXJzLmpzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4uL3NyYy9tb2R1bGVzL0xvZ2dlci50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvZGVmcy9ob29rcy50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi4vc3JjL3NjaGVtYXMvYXR0cmlidXRlLnRzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4uL3NyYy91dGlscy9kb20udHMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi4vc3JjL3V0aWxzL2hpc3RvcnkudHMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi4vc3JjL3V0aWxzL2hlbHBlcnMudHMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi4vc3JjL3V0aWxzL3VybC50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvdXRpbHMvcmVxdWVzdC50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaXMtcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvdXRpbHMvcnVuLWFzeW5jLnRzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4uL3NyYy9ob29rcy50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvbW9kdWxlcy9JZ25vcmUudHMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi4vc3JjL21vZHVsZXMvQ2FjaGUudHMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi4vc3JjL21vZHVsZXMvUHJldmVudC50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvbW9kdWxlcy9FcnJvci50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvbW9kdWxlcy9TdG9yZS50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvbW9kdWxlcy9UcmFuc2l0aW9ucy50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvbW9kdWxlcy9WaWV3cy50cyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uLi9zcmMvcG9seWZpbGxzL2luZGV4LnRzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4uL3NyYy9zY2hlbWFzL3BhZ2UudHMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi4vc3JjL2NvcmUudHMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi9ub2RlX21vZHVsZXMvQG1hZWVydGluL21lZGlhbG9hZGVkL2luZGV4LmpzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUGx1Z2luLmpzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4vbm9kZV9tb2R1bGVzL2dzYXAvZ3NhcC1jb3JlLmpzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4vbm9kZV9tb2R1bGVzL2dzYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi9zcmMvY2xhc3Nlcy9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi9zcmMvY2xhc3Nlcy9Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi9zcmMvY2xhc3Nlcy9OYXZpZ2F0aW9uLmpzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4vc3JjL2NsYXNzZXMvUkFGLmpzIiwid2VicGFjazovL3ppbmViZGphcmRpLy4vc3JjL2NsYXNzZXMvVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uL3NyYy9jbGFzc2VzL1ZpZGVvYmxvY2suanMiLCJ3ZWJwYWNrOi8vemluZWJkamFyZGkvLi9zcmMvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly96aW5lYmRqYXJkaS93ZWJwYWNrL3J1bnRpbWUvZ2V0RnVsbEhhc2giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSB0eXBlIG9mIHByb21pc2UtbGlrZSB0aGF0IHJlc29sdmVzIHN5bmNocm9ub3VzbHkgYW5kIHN1cHBvcnRzIG9ubHkgb25lIG9ic2VydmVyXG5leHBvcnQgY29uc3QgX1BhY3QgPSAvKiNfX1BVUkVfXyovKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBfUGFjdCgpIHt9XG5cdF9QYWN0LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHRjb25zdCByZXN1bHQgPSBuZXcgX1BhY3QoKTtcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMucztcblx0XHRpZiAoc3RhdGUpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gc3RhdGUgJiAxID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDEsIGNhbGxiYWNrKHRoaXMudikpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDIsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5vID0gZnVuY3Rpb24oX3RoaXMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gX3RoaXMudjtcblx0XHRcdFx0aWYgKF90aGlzLnMgJiAxKSB7XG5cdFx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDEsIG9uRnVsZmlsbGVkID8gb25GdWxmaWxsZWQodmFsdWUpIDogdmFsdWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9uUmVqZWN0ZWQpIHtcblx0XHRcdFx0XHRfc2V0dGxlKHJlc3VsdCwgMSwgb25SZWplY3RlZCh2YWx1ZSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9zZXR0bGUocmVzdWx0LCAyLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDIsIGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRyZXR1cm4gX1BhY3Q7XG59KSgpO1xuXG4vLyBTZXR0bGVzIGEgcGFjdCBzeW5jaHJvbm91c2x5XG5leHBvcnQgZnVuY3Rpb24gX3NldHRsZShwYWN0LCBzdGF0ZSwgdmFsdWUpIHtcblx0aWYgKCFwYWN0LnMpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBfUGFjdCkge1xuXHRcdFx0aWYgKHZhbHVlLnMpIHtcblx0XHRcdFx0aWYgKHN0YXRlICYgMSkge1xuXHRcdFx0XHRcdHN0YXRlID0gdmFsdWUucztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZS5vID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIHN0YXRlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdFx0dmFsdWUudGhlbihfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpLCBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgMikpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwYWN0LnMgPSBzdGF0ZTtcblx0XHRwYWN0LnYgPSB2YWx1ZTtcblx0XHRjb25zdCBvYnNlcnZlciA9IHBhY3Qubztcblx0XHRpZiAob2JzZXJ2ZXIpIHtcblx0XHRcdG9ic2VydmVyKHBhY3QpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzU2V0dGxlZFBhY3QodGhlbmFibGUpIHtcblx0cmV0dXJuIHRoZW5hYmxlIGluc3RhbmNlb2YgX1BhY3QgJiYgdGhlbmFibGUucyAmIDE7XG59XG5cbi8vIENvbnZlcnRzIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBhIFByb21pc2VcbmV4cG9ydCBmdW5jdGlvbiBfYXN5bmMoZikge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgYXJncyA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZi5hcHBseSh0aGlzLCBhcmdzKSk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8vIEF3YWl0cyBvbiBhIHZhbHVlIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYSBQcm9taXNlIChlcXVpdmFsZW50IHRvIHRoZSBhd2FpdCBrZXl3b3JkIGluIEVTMjAxNSwgd2l0aCBjb250aW51YXRpb25zIHBhc3NlZCBleHBsaWNpdGx5KVxuZXhwb3J0IGZ1bmN0aW9uIF9hd2FpdCh2YWx1ZSwgdGhlbiwgZGlyZWN0KSB7XG5cdGlmIChkaXJlY3QpIHtcblx0XHRyZXR1cm4gdGhlbiA/IHRoZW4odmFsdWUpIDogdmFsdWU7XG5cdH1cblx0aWYgKCF2YWx1ZSB8fCAhdmFsdWUudGhlbikge1xuXHRcdHZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gdGhlbiA/IHZhbHVlLnRoZW4odGhlbikgOiB2YWx1ZTtcbn1cblxuLy8gQXdhaXRzIG9uIGEgdmFsdWUgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBhIFByb21pc2UsIHRoZW4gaWdub3JlcyBpdFxuZXhwb3J0IGZ1bmN0aW9uIF9hd2FpdElnbm9yZWQodmFsdWUsIGRpcmVjdCkge1xuXHRpZiAoIWRpcmVjdCkge1xuXHRcdHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50aGVuID8gdmFsdWUudGhlbihfZW1wdHkpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cbn1cblxuLy8gUHJvY2VlZHMgYWZ0ZXIgYSB2YWx1ZSBoYXMgcmVzb2x2ZWQsIG9yIHByb2NlZWRzIGltbWVkaWF0ZWx5IGlmIHRoZSB2YWx1ZSBpcyBub3QgdGhlbmFibGVcbmV4cG9ydCBmdW5jdGlvbiBfY29udGludWUodmFsdWUsIHRoZW4pIHtcblx0cmV0dXJuIHZhbHVlICYmIHZhbHVlLnRoZW4gPyB2YWx1ZS50aGVuKHRoZW4pIDogdGhlbih2YWx1ZSk7XG59XG5cbi8vIFByb2NlZWRzIGFmdGVyIGEgdmFsdWUgaGFzIHJlc29sdmVkLCBvciBwcm9jZWVkcyBpbW1lZGlhdGVseSBpZiB0aGUgdmFsdWUgaXMgbm90IHRoZW5hYmxlXG5leHBvcnQgZnVuY3Rpb24gX2NvbnRpbnVlSWdub3JlZCh2YWx1ZSkge1xuXHRpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdHJldHVybiB2YWx1ZS50aGVuKF9lbXB0eSk7XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgaXRlcmF0ZSB0aHJvdWdoIGFuIG9iamVjdCB0aGF0IGhhcyBhIGxlbmd0aCBwcm9wZXJ0eSwgcGFzc2luZyB0aGUgaW5kZXggYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayAoZXZlbiBhcyB0aGUgbGVuZ3RoIHByb3BlcnR5IGNoYW5nZXMpXG5leHBvcnQgZnVuY3Rpb24gX2ZvclRvKGFycmF5LCBib2R5LCBjaGVjaykge1xuXHR2YXIgaSA9IC0xLCBwYWN0LCByZWplY3Q7XG5cdGZ1bmN0aW9uIF9jeWNsZShyZXN1bHQpIHtcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKCsraSA8IGFycmF5Lmxlbmd0aCAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuXHRcdFx0XHRyZXN1bHQgPSBib2R5KGkpO1xuXHRcdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdFx0aWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC52O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQudGhlbihfY3ljbGUsIHJlamVjdCB8fCAocmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QoKSwgMikpKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYWN0KSB7XG5cdFx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhY3QgPSByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0X3NldHRsZShwYWN0IHx8IChwYWN0ID0gbmV3IF9QYWN0KCkpLCAyLCBlKTtcblx0XHR9XG5cdH1cblx0X2N5Y2xlKCk7XG5cdHJldHVybiBwYWN0O1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBpdGVyYXRlIHRocm91Z2ggYW4gb2JqZWN0J3MgcHJvcGVydGllcyAoaW5jbHVkaW5nIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gdGhlIHByb3RvdHlwZSlcbi8vIFVzZXMgYSBzbmFwc2hvdCBvZiB0aGUgb2JqZWN0J3MgcHJvcGVydGllc1xuZXhwb3J0IGZ1bmN0aW9uIF9mb3JJbih0YXJnZXQsIGJvZHksIGNoZWNrKSB7XG5cdHZhciBrZXlzID0gW107XG5cdGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcblx0XHRrZXlzLnB1c2goa2V5KTtcblx0fVxuXHRyZXR1cm4gX2ZvclRvKGtleXMsIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGJvZHkoa2V5c1tpXSk7IH0sIGNoZWNrKTtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgaXRlcmF0ZSB0aHJvdWdoIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIChleGNsdWRpbmcgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSB0aGUgcHJvdG90eXBlKVxuLy8gVXNlcyBhIHNuYXBzaG90IG9mIHRoZSBvYmplY3QncyBwcm9wZXJ0aWVzXG5leHBvcnQgZnVuY3Rpb24gX2Zvck93bih0YXJnZXQsIGJvZHksIGNoZWNrKSB7XG5cdHZhciBrZXlzID0gW107XG5cdGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuXHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBfZm9yVG8oa2V5cywgZnVuY3Rpb24oaSkgeyByZXR1cm4gYm9keShrZXlzW2ldKTsgfSwgY2hlY2spO1xufVxuXG5leHBvcnQgY29uc3QgX2l0ZXJhdG9yU3ltYm9sID0gLyojX19QVVJFX18qLyB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gKFN5bWJvbC5pdGVyYXRvciB8fCAoU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKFwiU3ltYm9sLml0ZXJhdG9yXCIpKSkgOiBcIkBAaXRlcmF0b3JcIjtcblxuLy8gQXN5bmNocm9ub3VzbHkgaXRlcmF0ZSB0aHJvdWdoIGFuIG9iamVjdCdzIHZhbHVlc1xuLy8gVXNlcyBmb3IuLi5vZiBpZiB0aGUgcnVudGltZSBzdXBwb3J0cyBpdCwgb3RoZXJ3aXNlIGl0ZXJhdGVzIHVudGlsIGxlbmd0aCBvbiBhIGNvcHlcbmV4cG9ydCBmdW5jdGlvbiBfZm9yT2YodGFyZ2V0LCBib2R5LCBjaGVjaykge1xuXHRpZiAodHlwZW9mIHRhcmdldFtfaXRlcmF0b3JTeW1ib2xdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR2YXIgaXRlcmF0b3IgPSB0YXJnZXRbX2l0ZXJhdG9yU3ltYm9sXSgpLCBzdGVwLCBwYWN0LCByZWplY3Q7XG5cdFx0ZnVuY3Rpb24gX2N5Y2xlKHJlc3VsdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGJvZHkoc3RlcC52YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRcdFx0aWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnY7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQudGhlbihfY3ljbGUsIHJlamVjdCB8fCAocmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QoKSwgMikpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFjdCkge1xuXHRcdFx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYWN0ID0gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdF9zZXR0bGUocGFjdCB8fCAocGFjdCA9IG5ldyBfUGFjdCgpKSwgMiwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9jeWNsZSgpO1xuXHRcdGlmIChpdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdHZhciBfZml4dXAgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghc3RlcC5kb25lKSB7XG5cdFx0XHRcdFx0XHRpdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwYWN0ICYmIHBhY3QudGhlbikge1xuXHRcdFx0XHRyZXR1cm4gcGFjdC50aGVuKF9maXh1cCwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdHRocm93IF9maXh1cChlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRfZml4dXAoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhY3Q7XG5cdH1cblx0Ly8gTm8gc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yXG5cdGlmICghKFwibGVuZ3RoXCIgaW4gdGFyZ2V0KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHR9XG5cdC8vIEhhbmRsZSBsaXZlIGNvbGxlY3Rpb25zIHByb3Blcmx5XG5cdHZhciB2YWx1ZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyBpKyspIHtcblx0XHR2YWx1ZXMucHVzaCh0YXJnZXRbaV0pO1xuXHR9XG5cdHJldHVybiBfZm9yVG8odmFsdWVzLCBmdW5jdGlvbihpKSB7IHJldHVybiBib2R5KHZhbHVlc1tpXSk7IH0sIGNoZWNrKTtcbn1cblxuZXhwb3J0IGNvbnN0IF9hc3luY0l0ZXJhdG9yU3ltYm9sID0gLyojX19QVVJFX18qLyB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gKFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IChTeW1ib2wuYXN5bmNJdGVyYXRvciA9IFN5bWJvbChcIlN5bWJvbC5hc3luY0l0ZXJhdG9yXCIpKSkgOiBcIkBAYXN5bmNJdGVyYXRvclwiO1xuXG4vLyBBc3luY2hyb25vdXNseSBpdGVyYXRlIG9uIGEgdmFsdWUgdXNpbmcgaXQncyBhc3luYyBpdGVyYXRvciBpZiBwcmVzZW50LCBvciBpdHMgc3luY2hyb25vdXMgaXRlcmF0b3IgaWYgbWlzc2luZ1xuZXhwb3J0IGZ1bmN0aW9uIF9mb3JBd2FpdE9mKHRhcmdldCwgYm9keSwgY2hlY2spIHtcblx0aWYgKHR5cGVvZiB0YXJnZXRbX2FzeW5jSXRlcmF0b3JTeW1ib2xdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR2YXIgcGFjdCA9IG5ldyBfUGFjdCgpO1xuXHRcdHZhciBpdGVyYXRvciA9IHRhcmdldFtfYXN5bmNJdGVyYXRvclN5bWJvbF0oKTtcblx0XHRpdGVyYXRvci5uZXh0KCkudGhlbihfcmVzdW1lQWZ0ZXJOZXh0KS50aGVuKHZvaWQgMCwgX3JlamVjdCk7XG5cdFx0cmV0dXJuIHBhY3Q7XG5cdFx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyQm9keShyZXN1bHQpIHtcblx0XHRcdGlmIChjaGVjayAmJiBjaGVjaygpKSB7XG5cdFx0XHRcdHJldHVybiBfc2V0dGxlKHBhY3QsIDEsIGl0ZXJhdG9yLnJldHVybiA/IGl0ZXJhdG9yLnJldHVybigpLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiByZXN1bHQ7IH0pIDogcmVzdWx0KTtcblx0XHRcdH1cblx0XHRcdGl0ZXJhdG9yLm5leHQoKS50aGVuKF9yZXN1bWVBZnRlck5leHQpLnRoZW4odm9pZCAwLCBfcmVqZWN0KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyTmV4dChzdGVwKSB7XG5cdFx0XHRpZiAoc3RlcC5kb25lKSB7XG5cdFx0XHRcdF9zZXR0bGUocGFjdCwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQcm9taXNlLnJlc29sdmUoYm9keShzdGVwLnZhbHVlKSkudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgX3JlamVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9yZWplY3QoZXJyb3IpIHtcblx0XHRcdF9zZXR0bGUocGFjdCwgMiwgaXRlcmF0b3IucmV0dXJuID8gaXRlcmF0b3IucmV0dXJuKCkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIGVycm9yOyB9KSA6IGVycm9yKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShfZm9yT2YodGFyZ2V0LCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGJvZHkpOyB9LCBjaGVjaykpO1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBpbXBsZW1lbnQgYSBnZW5lcmljIGZvciBsb29wXG5leHBvcnQgZnVuY3Rpb24gX2Zvcih0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcblx0dmFyIHN0YWdlO1xuXHRmb3IgKDs7KSB7XG5cdFx0dmFyIHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXHRcdGlmIChfaXNTZXR0bGVkUGFjdChzaG91bGRDb250aW51ZSkpIHtcblx0XHRcdHNob3VsZENvbnRpbnVlID0gc2hvdWxkQ29udGludWUudjtcblx0XHR9XG5cdFx0aWYgKCFzaG91bGRDb250aW51ZSkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0aWYgKHNob3VsZENvbnRpbnVlLnRoZW4pIHtcblx0XHRcdHN0YWdlID0gMDtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5zO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhZ2UgPSAxO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHVwZGF0ZSkge1xuXHRcdFx0dmFyIHVwZGF0ZVZhbHVlID0gdXBkYXRlKCk7XG5cdFx0XHRpZiAodXBkYXRlVmFsdWUgJiYgdXBkYXRlVmFsdWUudGhlbiAmJiAhX2lzU2V0dGxlZFBhY3QodXBkYXRlVmFsdWUpKSB7XG5cdFx0XHRcdHN0YWdlID0gMjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHZhciBwYWN0ID0gbmV3IF9QYWN0KCk7XG5cdHZhciByZWplY3QgPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgMik7XG5cdChzdGFnZSA9PT0gMCA/IHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkgOiBzdGFnZSA9PT0gMSA/IHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpIDogdXBkYXRlVmFsdWUudGhlbihfcmVzdW1lQWZ0ZXJVcGRhdGUpKS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0cmV0dXJuIHBhY3Q7XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlckJvZHkodmFsdWUpIHtcblx0XHRyZXN1bHQgPSB2YWx1ZTtcblx0XHRkbyB7XG5cdFx0XHRpZiAodXBkYXRlKSB7XG5cdFx0XHRcdHVwZGF0ZVZhbHVlID0gdXBkYXRlKCk7XG5cdFx0XHRcdGlmICh1cGRhdGVWYWx1ZSAmJiB1cGRhdGVWYWx1ZS50aGVuICYmICFfaXNTZXR0bGVkUGFjdCh1cGRhdGVWYWx1ZSkpIHtcblx0XHRcdFx0XHR1cGRhdGVWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclVwZGF0ZSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzaG91bGRDb250aW51ZSA9IHRlc3QoKTtcblx0XHRcdGlmICghc2hvdWxkQ29udGludWUgfHwgKF9pc1NldHRsZWRQYWN0KHNob3VsZENvbnRpbnVlKSAmJiAhc2hvdWxkQ29udGludWUudikpIHtcblx0XHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuXHRcdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdH1cblx0XHR9IHdoaWxlICghcmVzdWx0IHx8ICFyZXN1bHQudGhlbik7XG5cdFx0cmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdH1cblx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyVGVzdChzaG91bGRDb250aW51ZSkge1xuXHRcdGlmIChzaG91bGRDb250aW51ZSkge1xuXHRcdFx0cmVzdWx0ID0gYm9keSgpO1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRyZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9yZXN1bWVBZnRlckJvZHkocmVzdWx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJVcGRhdGUoKSB7XG5cdFx0aWYgKHNob3VsZENvbnRpbnVlID0gdGVzdCgpKSB7XG5cdFx0XHRpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuXHRcdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3Jlc3VtZUFmdGVyVGVzdChzaG91bGRDb250aW51ZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHR9XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgaW1wbGVtZW50IGEgZG8gLi4uIHdoaWxlIGxvb3BcbmV4cG9ydCBmdW5jdGlvbiBfZG8oYm9keSwgdGVzdCkge1xuXHR2YXIgYXdhaXRCb2R5O1xuXHRkbyB7XG5cdFx0dmFyIHJlc3VsdCA9IGJvZHkoKTtcblx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0Qm9keSA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgc2hvdWxkQ29udGludWUgPSB0ZXN0KCk7XG5cdFx0aWYgKF9pc1NldHRsZWRQYWN0KHNob3VsZENvbnRpbnVlKSkge1xuXHRcdFx0c2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuXHRcdH1cblx0XHRpZiAoIXNob3VsZENvbnRpbnVlKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fSB3aGlsZSAoIXNob3VsZENvbnRpbnVlLnRoZW4pO1xuXHRjb25zdCBwYWN0ID0gbmV3IF9QYWN0KCk7XG5cdGNvbnN0IHJlamVjdCA9IF9zZXR0bGUuYmluZChudWxsLCBwYWN0LCAyKTtcblx0KGF3YWl0Qm9keSA/IHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpIDogc2hvdWxkQ29udGludWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdHJldHVybiBwYWN0O1xuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJCb2R5KHZhbHVlKSB7XG5cdFx0cmVzdWx0ID0gdmFsdWU7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0c2hvdWxkQ29udGludWUgPSB0ZXN0KCk7XG5cdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3Qoc2hvdWxkQ29udGludWUpKSB7XG5cdFx0XHRcdHNob3VsZENvbnRpbnVlID0gc2hvdWxkQ29udGludWUudjtcblx0XHRcdH1cblx0XHRcdGlmICghc2hvdWxkQ29udGludWUpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuXHRcdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0fVxuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKSB7XG5cdFx0aWYgKHNob3VsZENvbnRpbnVlKSB7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHJlc3VsdCA9IGJvZHkoKTtcblx0XHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXHRcdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3Qoc2hvdWxkQ29udGludWUpKSB7XG5cdFx0XHRcdFx0c2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2hvdWxkQ29udGludWUpIHtcblx0XHRcdFx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICghc2hvdWxkQ29udGludWUudGhlbik7XG5cdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdFx0fVxuXHR9XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGltcGxlbWVudCBhIHN3aXRjaCBzdGF0ZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBfc3dpdGNoKGRpc2NyaW1pbmFudCwgY2FzZXMpIHtcblx0dmFyIGRpc3BhdGNoSW5kZXggPSAtMTtcblx0dmFyIGF3YWl0Qm9keTtcblx0b3V0ZXI6IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhc2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdGVzdCA9IGNhc2VzW2ldWzBdO1xuXHRcdFx0aWYgKHRlc3QpIHtcblx0XHRcdFx0dmFyIHRlc3RWYWx1ZSA9IHRlc3QoKTtcblx0XHRcdFx0aWYgKHRlc3RWYWx1ZSAmJiB0ZXN0VmFsdWUudGhlbikge1xuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0ZXN0VmFsdWUgPT09IGRpc2NyaW1pbmFudCkge1xuXHRcdFx0XHRcdGRpc3BhdGNoSW5kZXggPSBpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3VuZCB0aGUgZGVmYXVsdCBjYXNlLCBzZXQgaXQgYXMgdGhlIHBlbmRpbmcgZGlzcGF0Y2ggY2FzZVxuXHRcdFx0XHRkaXNwYXRjaEluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGRpc3BhdGNoSW5kZXggIT09IC0xKSB7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHZhciBib2R5ID0gY2FzZXNbZGlzcGF0Y2hJbmRleF1bMV07XG5cdFx0XHRcdHdoaWxlICghYm9keSkge1xuXHRcdFx0XHRcdGRpc3BhdGNoSW5kZXgrKztcblx0XHRcdFx0XHRib2R5ID0gY2FzZXNbZGlzcGF0Y2hJbmRleF1bMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJlc3VsdCA9IGJvZHkoKTtcblx0XHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRcdGF3YWl0Qm9keSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGZhbGx0aHJvdWdoQ2hlY2sgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsyXTtcblx0XHRcdFx0ZGlzcGF0Y2hJbmRleCsrO1xuXHRcdFx0fSB3aGlsZSAoZmFsbHRocm91Z2hDaGVjayAmJiAhZmFsbHRocm91Z2hDaGVjaygpKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cdGNvbnN0IHBhY3QgPSBuZXcgX1BhY3QoKTtcblx0Y29uc3QgcmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIDIpO1xuXHQoYXdhaXRCb2R5ID8gcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkgOiB0ZXN0VmFsdWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdHJldHVybiBwYWN0O1xuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHZhbHVlKSB7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0aWYgKHZhbHVlID09PSBkaXNjcmltaW5hbnQpIHtcblx0XHRcdFx0ZGlzcGF0Y2hJbmRleCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCsraSA9PT0gY2FzZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChkaXNwYXRjaEluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRlc3QgPSBjYXNlc1tpXVswXTtcblx0XHRcdGlmICh0ZXN0KSB7XG5cdFx0XHRcdHZhbHVlID0gdGVzdCgpO1xuXHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdFx0XHRcdHZhbHVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNwYXRjaEluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZG8ge1xuXHRcdFx0dmFyIGJvZHkgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsxXTtcblx0XHRcdHdoaWxlICghYm9keSkge1xuXHRcdFx0XHRkaXNwYXRjaEluZGV4Kys7XG5cdFx0XHRcdGJvZHkgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsxXTtcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZmFsbHRocm91Z2hDaGVjayA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzJdO1xuXHRcdFx0ZGlzcGF0Y2hJbmRleCsrO1xuXHRcdH0gd2hpbGUgKGZhbGx0aHJvdWdoQ2hlY2sgJiYgIWZhbGx0aHJvdWdoQ2hlY2soKSk7XG5cdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHR9XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlckJvZHkocmVzdWx0KSB7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0dmFyIGZhbGx0aHJvdWdoQ2hlY2sgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsyXTtcblx0XHRcdGlmICghZmFsbHRocm91Z2hDaGVjayB8fCBmYWxsdGhyb3VnaENoZWNrKCkpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRkaXNwYXRjaEluZGV4Kys7XG5cdFx0XHR2YXIgYm9keSA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzFdO1xuXHRcdFx0d2hpbGUgKCFib2R5KSB7XG5cdFx0XHRcdGRpc3BhdGNoSW5kZXgrKztcblx0XHRcdFx0Ym9keSA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzFdO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0gYm9keSgpO1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRyZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gZXhwbGljaXRseSBwYXNzZWQgY29udGludWF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIF9jYWxsKGJvZHksIHRoZW4sIGRpcmVjdCkge1xuXHRpZiAoZGlyZWN0KSB7XG5cdFx0cmV0dXJuIHRoZW4gPyB0aGVuKGJvZHkoKSkgOiBib2R5KCk7XG5cdH1cblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKGJvZHkoKSk7XG5cdFx0cmV0dXJuIHRoZW4gPyByZXN1bHQudGhlbih0aGVuKSA6IHJlc3VsdDtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcblx0fVxufVxuXG4vLyBBc3luY2hyb25vdXNseSBjYWxsIGEgZnVuY3Rpb24gYW5kIHN3YWxsb3cgdGhlIHJlc3VsdFxuZXhwb3J0IGZ1bmN0aW9uIF9jYWxsSWdub3JlZChib2R5LCBkaXJlY3QpIHtcblx0cmV0dXJuIF9jYWxsKGJvZHksIF9lbXB0eSwgZGlyZWN0KTtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gZXhwbGljaXRseSBwYXNzZWQgY29udGludWF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnZva2UoYm9keSwgdGhlbikge1xuXHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0cmV0dXJuIHJlc3VsdC50aGVuKHRoZW4pO1xuXHR9XG5cdHJldHVybiB0aGVuKHJlc3VsdCk7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGNhbGwgYSBmdW5jdGlvbiBhbmQgc3dhbGxvdyB0aGUgcmVzdWx0XG5leHBvcnQgZnVuY3Rpb24gX2ludm9rZUlnbm9yZWQoYm9keSkge1xuXHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0cmV0dXJuIHJlc3VsdC50aGVuKF9lbXB0eSk7XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBzZW5kIGVycm9ycyB0byByZWNvdmVyeSBjb250aW51YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2goYm9keSwgcmVjb3Zlcikge1xuXHR0cnkge1xuXHRcdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdH0gY2F0Y2goZSkge1xuXHRcdHJldHVybiByZWNvdmVyKGUpO1xuXHR9XG5cdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRyZXR1cm4gcmVzdWx0LnRoZW4odm9pZCAwLCByZWNvdmVyKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBhd2FpdCBhIHByb21pc2UgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBhIGZpbmFsbHkgY29udGludWF0aW9uXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmFsbHlSZXRocm93cyhib2R5LCBmaW5hbGl6ZXIpIHtcblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZpbmFsaXplcih0cnVlLCBlKTtcblx0fVxuXHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0cmV0dXJuIHJlc3VsdC50aGVuKGZpbmFsaXplci5iaW5kKG51bGwsIGZhbHNlKSwgZmluYWxpemVyLmJpbmQobnVsbCwgdHJ1ZSkpO1xuXHR9XG5cdHJldHVybiBmaW5hbGl6ZXIoZmFsc2UsIHJlc3VsdCk7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGF3YWl0IGEgcHJvbWlzZSBhbmQgaW52b2tlIGEgZmluYWxseSBjb250aW51YXRpb24gdGhhdCBhbHdheXMgb3ZlcnJpZGVzIHRoZSByZXN1bHRcbmV4cG9ydCBmdW5jdGlvbiBfZmluYWxseShib2R5LCBmaW5hbGl6ZXIpIHtcblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZpbmFsaXplcigpO1xuXHR9XG5cdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRyZXR1cm4gcmVzdWx0LnRoZW4oZmluYWxpemVyLCBmaW5hbGl6ZXIpO1xuXHR9XG5cdHJldHVybiBmaW5hbGl6ZXIoKTtcbn1cblxuLy8gUmV0aHJvdyBvciByZXR1cm4gYSB2YWx1ZSBmcm9tIGEgZmluYWxseSBjb250aW51YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBfcmV0aHJvdyh0aHJvd24sIHZhbHVlKSB7XG5cdGlmICh0aHJvd24pXG5cdFx0dGhyb3cgdmFsdWU7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLy8gRW1wdHkgZnVuY3Rpb24gdG8gaW1wbGVtZW50IGJyZWFrIGFuZCBvdGhlciBjb250cm9sIGZsb3cgdGhhdCBpZ25vcmVzIGFzeW5jaHJvbm91cyByZXN1bHRzXG5leHBvcnQgZnVuY3Rpb24gX2VtcHR5KCkge1xufVxuXG4vLyBTZW50aW5lbCB2YWx1ZSBmb3IgZWFybHkgcmV0dXJucyBpbiBnZW5lcmF0b3JzIFxuZXhwb3J0IGNvbnN0IF9lYXJseVJldHVybiA9IC8qI19fUFVSRV9fKi8ge307XG5cbi8vIEFzeW5jaHJvbm91c2x5IGNhbGwgYSBmdW5jdGlvbiBhbmQgc2VuZCBlcnJvcnMgdG8gcmVjb3ZlcnkgY29udGludWF0aW9uLCBza2lwcGluZyBlYXJseSByZXR1cm5zXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoSW5HZW5lcmF0b3IoYm9keSwgcmVjb3Zlcikge1xuXHRyZXR1cm4gX2NhdGNoKGJvZHksIGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZSA9PT0gX2Vhcmx5UmV0dXJuKSB7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVjb3ZlcihlKTtcblx0fSk7XG59XG5cbi8vIEFzeW5jaHJvbm91cyBnZW5lcmF0b3IgY2xhc3M7IGFjY2VwdHMgdGhlIGVudHJ5cG9pbnQgb2YgdGhlIGdlbmVyYXRvciwgdG8gd2hpY2ggaXQgcGFzc2VzIGl0c2VsZiB3aGVuIHRoZSBnZW5lcmF0b3Igc2hvdWxkIHN0YXJ0XG5leHBvcnQgY29uc3QgX0FzeW5jR2VuZXJhdG9yID0gLyojX19QVVJFX18qLyhmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gX0FzeW5jR2VuZXJhdG9yKGVudHJ5KSB7XG5cdFx0dGhpcy5fZW50cnkgPSBlbnRyeTtcblx0XHR0aGlzLl9wYWN0ID0gbnVsbDtcblx0XHR0aGlzLl9yZXNvbHZlID0gbnVsbDtcblx0XHR0aGlzLl9yZXR1cm4gPSBudWxsO1xuXHRcdHRoaXMuX3Byb21pc2UgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3dyYXBSZXR1cm5lZFZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiB0cnVlIH07XG5cdH1cblx0ZnVuY3Rpb24gX3dyYXBZaWVsZGVkVmFsdWUodmFsdWUpIHtcblx0XHRyZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlIH07XG5cdH1cblxuXHRfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLl95aWVsZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gWWllbGQgdGhlIHZhbHVlIHRvIHRoZSBwZW5kaW5nIG5leHQgY2FsbFxuXHRcdHRoaXMuX3Jlc29sdmUodmFsdWUgJiYgdmFsdWUudGhlbiA/IHZhbHVlLnRoZW4oX3dyYXBZaWVsZGVkVmFsdWUpIDogX3dyYXBZaWVsZGVkVmFsdWUodmFsdWUpKTtcblx0XHQvLyBSZXR1cm4gYSBwYWN0IGZvciBhbiB1cGNvbWluZyBuZXh0L3JldHVybi90aHJvdyBjYWxsXG5cdFx0cmV0dXJuIHRoaXMuX3BhY3QgPSBuZXcgX1BhY3QoKTtcblx0fTtcblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBBZHZhbmNlIHRoZSBnZW5lcmF0b3IsIHN0YXJ0aW5nIGl0IGlmIGl0IGhhcyB5ZXQgdG8gYmUgc3RhcnRlZFxuXHRcdGNvbnN0IF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdFx0Y29uc3QgX3BhY3QgPSBfdGhpcy5fcGFjdDtcblx0XHRcdGlmIChfcGFjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBfZW50cnkgPSBfdGhpcy5fZW50cnk7XG5cdFx0XHRcdGlmIChfZW50cnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBHZW5lcmF0b3IgaXMgc3RhcnRlZCwgYnV0IG5vdCBhd2FpdGluZyBhIHlpZWxkIGV4cHJlc3Npb25cblx0XHRcdFx0XHQvLyBBYmFuZG9uIHRoZSBuZXh0IGNhbGwhXG5cdFx0XHRcdFx0cmV0dXJuIHJlc29sdmUoX3RoaXMuX3Byb21pc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFN0YXJ0IHRoZSBnZW5lcmF0b3Jcblx0XHRcdFx0X3RoaXMuX2VudHJ5ID0gbnVsbDtcblx0XHRcdFx0X3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0XHRmdW5jdGlvbiByZXR1cm5WYWx1ZSh2YWx1ZSkge1xuXHRcdFx0XHRcdF90aGlzLl9yZXNvbHZlKHZhbHVlICYmIHZhbHVlLnRoZW4gPyB2YWx1ZS50aGVuKF93cmFwUmV0dXJuZWRWYWx1ZSkgOiBfd3JhcFJldHVybmVkVmFsdWUodmFsdWUpKTtcblx0XHRcdFx0XHRfdGhpcy5fcGFjdCA9IG51bGw7XG5cdFx0XHRcdFx0X3RoaXMuX3Jlc29sdmUgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByZXN1bHQgPSBfZW50cnkoX3RoaXMpO1xuXHRcdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnRoZW4ocmV0dXJuVmFsdWUsIGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXJyb3IgPT09IF9lYXJseVJldHVybikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZShfdGhpcy5fcmV0dXJuKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHBhY3QgPSBuZXcgX1BhY3QoKTtcblx0XHRcdFx0XHRcdFx0X3RoaXMuX3Jlc29sdmUocGFjdCk7XG5cdFx0XHRcdFx0XHRcdF90aGlzLl9wYWN0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0X3RoaXMuX3Jlc29sdmUgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRfcmVzb2x2ZShwYWN0LCAyLCBlcnJvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gR2VuZXJhdG9yIGlzIHN0YXJ0ZWQgYW5kIGEgeWllbGQgZXhwcmVzc2lvbiBpcyBwZW5kaW5nLCBzZXR0bGUgaXRcblx0XHRcdFx0X3RoaXMuX3BhY3QgPSBudWxsO1xuXHRcdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdF9zZXR0bGUoX3BhY3QsIDEsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIEVhcmx5IHJldHVybiBmcm9tIHRoZSBnZW5lcmF0b3IgaWYgc3RhcnRlZCwgb3RoZXJ3aXNlIGFiYW5kb25zIHRoZSBnZW5lcmF0b3Jcblx0XHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0XHRcdGNvbnN0IF9wYWN0ID0gX3RoaXMuX3BhY3Q7XG5cdFx0XHRpZiAoX3BhY3QgPT09IG51bGwpIHtcblx0XHRcdFx0aWYgKF90aGlzLl9lbnRyeSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIEdlbmVyYXRvciBpcyBzdGFydGVkLCBidXQgbm90IGF3YWl0aW5nIGEgeWllbGQgZXhwcmVzc2lvblxuXHRcdFx0XHRcdC8vIEFiYW5kb24gdGhlIHJldHVybiBjYWxsIVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlKF90aGlzLl9wcm9taXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBHZW5lcmF0b3IgaXMgbm90IHN0YXJ0ZWQsIGFiYW5kb24gaXQgYW5kIHJldHVybiB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRcdF90aGlzLl9lbnRyeSA9IG51bGw7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlKHZhbHVlICYmIHZhbHVlLnRoZW4gPyB2YWx1ZS50aGVuKF93cmFwUmV0dXJuZWRWYWx1ZSkgOiBfd3JhcFJldHVybmVkVmFsdWUodmFsdWUpKTtcblx0XHRcdH1cblx0XHRcdC8vIFNldHRsZSB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aXRoIGEgcmVqZWN0ZWQgXCJlYXJseSByZXR1cm5cIiB2YWx1ZVxuXHRcdFx0X3RoaXMuX3JldHVybiA9IHZhbHVlO1xuXHRcdFx0X3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0X3RoaXMuX3BhY3QgPSBudWxsO1xuXHRcdFx0X3NldHRsZShfcGFjdCwgMiwgX2Vhcmx5UmV0dXJuKTtcblx0XHR9KTtcblx0fTtcblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0Ly8gSW5qZWN0IGFuIGV4Y2VwdGlvbiBpbnRvIHRoZSBwZW5kaW5nIHlpZWxkIGV4cHJlc3Npb25cblx0XHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0Y29uc3QgX3BhY3QgPSBfdGhpcy5fcGFjdDtcblx0XHRcdGlmIChfcGFjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoX3RoaXMuX2VudHJ5ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gR2VuZXJhdG9yIGlzIHN0YXJ0ZWQsIGJ1dCBub3QgYXdhaXRpbmcgYSB5aWVsZCBleHByZXNzaW9uXG5cdFx0XHRcdFx0Ly8gQWJhbmRvbiB0aGUgdGhyb3cgY2FsbCFcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZShfdGhpcy5fcHJvbWlzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gR2VuZXJhdG9yIGlzIG5vdCBzdGFydGVkLCBhYmFuZG9uIGl0IGFuZCByZXR1cm4gYSByZWplY3RlZCBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGVycm9yXG5cdFx0XHRcdF90aGlzLl9lbnRyeSA9IG51bGw7XG5cdFx0XHRcdHJldHVybiByZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2V0dGxlIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpdGggdGhlIHZhbHVlIGFzIGEgcmVqZWN0aW9uXG5cdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRfdGhpcy5fcGFjdCA9IG51bGw7XG5cdFx0XHRfc2V0dGxlKF9wYWN0LCAyLCBlcnJvcik7XG5cdFx0fSk7XG5cdH07XG5cblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtfYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHJldHVybiBfQXN5bmNHZW5lcmF0b3I7XG59KSgpO1xuIiwiLyoqXG4gKiBAYmFyYmEvY29yZS9tb2R1bGVzL0xvZ2dlclxuICogPGJyPjxicj5cbiAqICMjIExvZ2dlci5cbiAqXG4gKiAtIERpc3BsYXkgaW5mb3JtYXRpb25zIHZpYSB0aGUgY29uc29sZVxuICpcbiAqIEBtb2R1bGUgY29yZS9tb2R1bGVzL0xvZ2dlclxuICogQHByZWZlcnJlZFxuICovXG5cbi8qKiovXG5cbi8qKlxuICogTG9nIGxldmVscywgYWxsIGxvd2VyIGxldmVsIG1lc3NhZ2VzIGFyZSBwcmludGVkXG4gKlxuICogMC4gbXV0ZVxuICogMS4gZXJyb3IgPSBgY29uc29sZS5lcnJvcigpYFxuICogMi4gd2FybmluZz0gYGNvbnNvbGUud2FybigpYFxuICogMy4gaW5mbyA9IGBjb25zb2xlLmluZm8oKWBcbiAqIDQuIGRlYnVnID0gYGNvbnNvbGUubG9nKClgXG4gKi9cbmV4cG9ydCBlbnVtIExvZ0xldmVscyB7XG4gIG9mZiA9IDAsXG4gIGVycm9yID0gMSxcbiAgd2FybmluZyA9IDIsXG4gIGluZm8gPSAzLFxuICBkZWJ1ZyA9IDQsXG59XG5cbi8qKlxuICogR2xvYmFsIGxvZyBsZXZlbFxuICovXG5sZXQgX2xldmVsOiBudW1iZXIgPSBMb2dMZXZlbHMub2ZmO1xuXG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgLyoqXG4gICAqIEdldCBnbG9iYWwgbG9nIGxldmVsLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiBfbGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGdsb2JhbCBsb2cgbGV2ZWwuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNldExldmVsKG5hbWU6IGtleW9mIHR5cGVvZiBMb2dMZXZlbHMpOiBudW1iZXIge1xuICAgIF9sZXZlbCA9IExvZ0xldmVsc1tuYW1lXTtcblxuICAgIHJldHVybiBfbGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogTG9nIFwicHJlZml4XCIuXG4gICAqL1xuICBwcml2YXRlIF9zb3VyY2U6IHN0cmluZztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBMb2dnZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZykge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJtYW5lbnQsIHVucmVtb3ZhYmxlIGxvZy5cbiAgICovXG4gIC8vIHB1YmxpYyBwcmludCguLi5vYmplY3RzOiBhbnlbXSk6IHZvaWQge1xuICAvLyAgIHRoaXMuX2xvZyhjb25zb2xlLmluZm8sIExvZ0xldmVscy5vZmYsIG9iamVjdHMpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIEVycm9yIGxvZy5cbiAgICovXG4gIHB1YmxpYyBlcnJvciguLi5vYmplY3RzOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuX2xvZyhjb25zb2xlLmVycm9yLCBMb2dMZXZlbHMuZXJyb3IsIG9iamVjdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm4gbG9nLlxuICAgKi9cbiAgcHVibGljIHdhcm4oLi4ub2JqZWN0czogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLl9sb2coY29uc29sZS53YXJuLCBMb2dMZXZlbHMud2FybmluZywgb2JqZWN0cyk7XG4gIH1cblxuICAvKipcbiAgICogSW5mbyBsb2cuXG4gICAqL1xuICBwdWJsaWMgaW5mbyguLi5vYmplY3RzOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuX2xvZyhjb25zb2xlLmluZm8sIExvZ0xldmVscy5pbmZvLCBvYmplY3RzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWJ1ZyBsb2cuXG4gICAqL1xuICBwdWJsaWMgZGVidWcoLi4ub2JqZWN0czogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLl9sb2coY29uc29sZS5sb2csIExvZ0xldmVscy5kZWJ1Zywgb2JqZWN0cyk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgbG9nZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBfbG9nKGZuOiAoKSA9PiB2b2lkLCBsZXZlbDogbnVtYmVyLCBvYmplY3RzOiBhbnlbXSk6IHZvaWQge1xuICAgIGlmIChsZXZlbCA8PSBMb2dnZXIuZ2V0TGV2ZWwoKSkge1xuICAgICAgZm4uYXBwbHkoY29uc29sZSwgKFtgWyR7dGhpcy5fc291cmNlfV0gYF0uY29uY2F0KG9iamVjdHMpIGFzIHVua25vd24pIGFzIFtcblxuICAgICAgXSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgdHlwaW5ncy9jb3JlXG4gKi9cbmltcG9ydCB7IElUcmFuc2l0aW9uRGF0YSwgSVRyYW5zaXRpb25QYWdlLCBJVmlld0RhdGEgfSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IHR5cGUgSG9va3NCYXJiYSA9XG4gIHwgJ3JlYWR5J1xuICB8ICdwYWdlJ1xuICB8ICdyZXNldCdcbiAgfCAnY3VycmVudEFkZGVkJ1xuICB8ICdjdXJyZW50UmVtb3ZlZCdcbiAgfCAnbmV4dEFkZGVkJ1xuICB8ICduZXh0UmVtb3ZlZCc7XG5cbmV4cG9ydCB0eXBlIEhvb2tzT25jZSA9ICdiZWZvcmVPbmNlJyB8ICdvbmNlJyB8ICdhZnRlck9uY2UnO1xuXG5leHBvcnQgdHlwZSBIb29rc1BhZ2UgPVxuICB8ICdiZWZvcmUnXG4gIHwgJ2JlZm9yZUxlYXZlJ1xuICB8ICdsZWF2ZSdcbiAgfCAnYWZ0ZXJMZWF2ZSdcbiAgfCAnYmVmb3JlRW50ZXInXG4gIHwgJ2VudGVyJ1xuICB8ICdhZnRlckVudGVyJ1xuICB8ICdhZnRlcic7XG5cbmV4cG9ydCB0eXBlIEhvb2tzQmVmb3JlID0gJ2JlZm9yZU9uY2UnIHwgJ2JlZm9yZUxlYXZlJyB8ICdiZWZvcmVFbnRlcic7XG5leHBvcnQgdHlwZSBIb29rc0FmdGVyID0gJ2FmdGVyT25jZScgfCAnYWZ0ZXJMZWF2ZScgfCAnYWZ0ZXJFbnRlcic7XG5cbmV4cG9ydCB0eXBlIEhvb2tzVHJhbnNpdGlvbiA9IEhvb2tzT25jZSB8IEhvb2tzUGFnZTtcbmV4cG9ydCB0eXBlIEhvb2tzVmlldyA9IEhvb2tzQmVmb3JlIHwgSG9va3NBZnRlcjtcbmV4cG9ydCB0eXBlIEhvb2tzQWxsID0gSG9va3NCYXJiYSB8IEhvb2tzVHJhbnNpdGlvbjtcblxuLy8gQWxsb3cgb3B0aW9uYWwgXCJkeW5hbWljYWxseSBjcmVhdGVkXCIgaG9va3NcbmV4cG9ydCB0eXBlIEhvb2tzVHJhbnNpdGlvbk1hcCA9IHsgW2tleSBpbiBIb29rc1RyYW5zaXRpb25dPzogYW55IH07XG5cbmV4cG9ydCB0eXBlIEhvb2tGdW5jdGlvbiA9IChcbiAgZGF0YT86IElUcmFuc2l0aW9uRGF0YSB8IElWaWV3RGF0YSxcbiAgdD86IElUcmFuc2l0aW9uUGFnZVxuKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcblxuZXhwb3J0IGNsYXNzIEhvb2tNZXRob2RzIHtcbiAgcHVibGljIGJlZm9yZTogKGZuOiBIb29rRnVuY3Rpb24sIGN0eD86IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIGJlZm9yZUxlYXZlOiAoZm46IEhvb2tGdW5jdGlvbiwgY3R4PzogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgbGVhdmU6IChmbjogSG9va0Z1bmN0aW9uLCBjdHg/OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBhZnRlckxlYXZlOiAoZm46IEhvb2tGdW5jdGlvbiwgY3R4PzogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgYmVmb3JlRW50ZXI6IChmbjogSG9va0Z1bmN0aW9uLCBjdHg/OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBlbnRlcjogKGZuOiBIb29rRnVuY3Rpb24sIGN0eD86IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIGFmdGVyRW50ZXI6IChmbjogSG9va0Z1bmN0aW9uLCBjdHg/OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBhZnRlcjogKGZuOiBIb29rRnVuY3Rpb24sIGN0eD86IGFueSkgPT4gdm9pZDtcbn1cbiIsIi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMubWF0Y2ggPSBtYXRjaFxubW9kdWxlLmV4cG9ydHMucmVnZXhwVG9GdW5jdGlvbiA9IHJlZ2V4cFRvRnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIERlZmF1bHQgY29uZmlncy5cbiAqL1xudmFyIERFRkFVTFRfREVMSU1JVEVSID0gJy8nXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCI6dGVzdChcXFxcZCspP1wiID0+IFtcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCJdXG4gIC8vIFwiKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkXVxuICAnKD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/J1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyKSB8fCBERUZBVUxUX0RFTElNSVRFUlxuICB2YXIgd2hpdGVsaXN0ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy53aGl0ZWxpc3QpIHx8IHVuZGVmaW5lZFxuICB2YXIgcGF0aEVzY2FwZWQgPSBmYWxzZVxuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9PSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIHBhdGhFc2NhcGVkID0gdHJ1ZVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9ICcnXG4gICAgdmFyIG5hbWUgPSByZXNbMl1cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1szXVxuICAgIHZhciBncm91cCA9IHJlc1s0XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s1XVxuXG4gICAgaWYgKCFwYXRoRXNjYXBlZCAmJiBwYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIGsgPSBwYXRoLmxlbmd0aCAtIDFcbiAgICAgIHZhciBjID0gcGF0aFtrXVxuICAgICAgdmFyIG1hdGNoZXMgPSB3aGl0ZWxpc3QgPyB3aGl0ZWxpc3QuaW5kZXhPZihjKSA+IC0xIDogdHJ1ZVxuXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBwcmV2ID0gY1xuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBrKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gICAgICBwYXRoID0gJydcbiAgICAgIHBhdGhFc2NhcGVkID0gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwXG4gICAgdmFyIGRlbGltaXRlciA9IHByZXYgfHwgZGVmYXVsdERlbGltaXRlclxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJldixcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuXG4gICAgICAgID8gZXNjYXBlR3JvdXAocGF0dGVybilcbiAgICAgICAgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlciA9PT0gZGVmYXVsdERlbGltaXRlciA/IGRlbGltaXRlciA6IChkZWxpbWl0ZXIgKyBkZWZhdWx0RGVsaW1pdGVyKSkgKyAnXSs/J1xuICAgIH0pXG4gIH1cblxuICAvLyBQdXNoIGFueSByZW1haW5pbmcgY2hhcmFjdGVycy5cbiAgaWYgKHBhdGggfHwgaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aCArIHN0ci5zdWJzdHIoaW5kZXgpKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2ggKHN0ciwgb3B0aW9ucykge1xuICB2YXIga2V5cyA9IFtdXG4gIHZhciByZSA9IHBhdGhUb1JlZ2V4cChzdHIsIGtleXMsIG9wdGlvbnMpXG4gIHJldHVybiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbiAocmUsIGtleXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXRobmFtZSwgb3B0aW9ucykge1xuICAgIHZhciBtID0gcmUuZXhlYyhwYXRobmFtZSlcbiAgICBpZiAoIW0pIHJldHVybiBmYWxzZVxuXG4gICAgdmFyIHBhdGggPSBtWzBdXG4gICAgdmFyIGluZGV4ID0gbS5pbmRleFxuICAgIHZhciBwYXJhbXMgPSB7fVxuICAgIHZhciBkZWNvZGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlY29kZSkgfHwgZGVjb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtW2ldID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG5cbiAgICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXVxuXG4gICAgICBpZiAoa2V5LnJlcGVhdCkge1xuICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gbVtpXS5zcGxpdChrZXkuZGVsaW1pdGVyKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZSh2YWx1ZSwga2V5KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IGRlY29kZShtW2ldLCBrZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgaW5kZXg6IGluZGV4LCBwYXJhbXM6IHBhcmFtcyB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcsIGZsYWdzKG9wdGlvbnMpKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZW5jb2RlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUpIHx8IGVuY29kZVVSSUNvbXBvbmVudFxuICAgIHZhciB2YWxpZGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnZhbGlkYXRlICE9PSBmYWxzZSA6IHRydWVcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhID8gZGF0YVt0b2tlbi5uYW1lXSA6IHVuZGVmaW5lZFxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFycmF5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIGNvbnRpbnVlXG5cbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSwgdG9rZW4pXG5cbiAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIicpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pXG5cbiAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCBnb3QgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICAgIH1cblxuICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSBjb250aW51ZVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlICcgKyAodG9rZW4ucmVwZWF0ID8gJ2FuIGFycmF5JyA6ICdhIHN0cmluZycpKVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheT19ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICBpZiAoIWtleXMpIHJldHVybiBwYXRoXG5cbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXk9fSAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheT19ICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICB0b2tlbnNcbiAqIEBwYXJhbSAge0FycmF5PX0gIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydCAhPT0gZmFsc2VcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgZGVsaW1pdGVyID0gb3B0aW9ucy5kZWxpbWl0ZXIgfHwgREVGQVVMVF9ERUxJTUlURVJcbiAgdmFyIGVuZHNXaXRoID0gW10uY29uY2F0KG9wdGlvbnMuZW5kc1dpdGggfHwgW10pLm1hcChlc2NhcGVTdHJpbmcpLmNvbmNhdCgnJCcpLmpvaW4oJ3wnKVxuICB2YXIgcm91dGUgPSBzdGFydCA/ICdeJyA6ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYXB0dXJlID0gdG9rZW4ucmVwZWF0XG4gICAgICAgID8gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJykoPzonICsgZXNjYXBlU3RyaW5nKHRva2VuLmRlbGltaXRlcikgKyAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSkqJ1xuICAgICAgICA6IHRva2VuLnBhdHRlcm5cblxuICAgICAgaWYgKGtleXMpIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucHJlZml4KSB7XG4gICAgICAgICAgcm91dGUgKz0gJygnICsgY2FwdHVyZSArICcpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZSArPSAnKD86JyArIGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICBpZiAoIXN0cmljdCkgcm91dGUgKz0gJyg/OicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICcpPydcblxuICAgIHJvdXRlICs9IGVuZHNXaXRoID09PSAnJCcgPyAnJCcgOiAnKD89JyArIGVuZHNXaXRoICsgJyknXG4gIH0gZWxzZSB7XG4gICAgdmFyIGVuZFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVxuICAgIHZhciBpc0VuZERlbGltaXRlZCA9IHR5cGVvZiBlbmRUb2tlbiA9PT0gJ3N0cmluZydcbiAgICAgID8gZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0gPT09IGRlbGltaXRlclxuICAgICAgOiBlbmRUb2tlbiA9PT0gdW5kZWZpbmVkXG5cbiAgICBpZiAoIXN0cmljdCkgcm91dGUgKz0gJyg/OicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICcoPz0nICsgZW5kc1dpdGggKyAnKSk/J1xuICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHJvdXRlICs9ICcoPz0nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnfCcgKyBlbmRzV2l0aCArICcpJ1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheT19ICAgICAgICAgICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIGtleXMsIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwga2V5cywgb3B0aW9ucylcbn1cbiIsIi8qKlxuICogQGJhcmJhL2NvcmUvc2NoZW1hc1xuICogPGJyPjxicj5cbiAqICMjIFNjaGVtYXMgZGVzY3JpcHRpb24uXG4gKlxuICogQG1vZHVsZSBjb3JlL3NjaGVtYXNcbiAqIEBwcmVmZXJyZWRcbiAqL1xuXG4vKioqL1xuXG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSVNjaGVtYUF0dHJpYnV0ZSB9IGZyb20gJy4uL2RlZnMnO1xuXG4vKipcbiAqIFNlZSBbW0lTY2hlbWFBdHRyaWJ1dGVdXVxuICovXG5leHBvcnQgY29uc3Qgc2NoZW1hQXR0cmlidXRlOiBJU2NoZW1hQXR0cmlidXRlID0ge1xuICBjb250YWluZXI6ICdjb250YWluZXInLFxuICBoaXN0b3J5OiAnaGlzdG9yeScsXG4gIG5hbWVzcGFjZTogJ25hbWVzcGFjZScsXG4gIHByZWZpeDogJ2RhdGEtYmFyYmEnLFxuICBwcmV2ZW50OiAncHJldmVudCcsXG4gIHdyYXBwZXI6ICd3cmFwcGVyJyxcbn07XG4iLCIvKipcbiAqIEBiYXJiYS9jb3JlL3V0aWxzL2RvbVxuICogPGJyPjxicj5cbiAqICMjIERvbSB1dGlsc1xuICpcbiAqIC0gQWNjZXNzIERPTSBjb250ZW50c1xuICogLSBET00gdnMgc3RyaW5nIGNvbnZlcnNpb25zXG4gKlxuICogQG1vZHVsZSBjb3JlL3V0aWxzL2RvbVxuICogQHByZWZlcnJlZFxuICovXG5cbi8qKiovXG5cbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSVNjaGVtYUF0dHJpYnV0ZSwgTGluaywgU2NvcGUsIFdyYXBwZXIgfSBmcm9tICcuLi9kZWZzJztcbi8vIFNjaGVtYXNcbmltcG9ydCB7IHNjaGVtYUF0dHJpYnV0ZSB9IGZyb20gJy4uL3NjaGVtYXMvYXR0cmlidXRlJztcblxuZXhwb3J0IGNsYXNzIERvbSB7XG4gIHByaXZhdGUgX2F0dHI6IElTY2hlbWFBdHRyaWJ1dGUgPSBzY2hlbWFBdHRyaWJ1dGU7XG4gIHByaXZhdGUgX3BhcnNlcjogRE9NUGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IEhUTUxEb2N1bWVudCB0byBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgdG9TdHJpbmcoZWw6IEhUTUxFbGVtZW50KTogc3RyaW5nIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIEhUTUwgc3RyaW5nIHRvIEhUTUxEb2N1bWVudC5cbiAgICovXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmFyYmFqcy9iYXJiYS9pc3N1ZXMvMzYyXG4gIC8vIFNlZW1zIHRoYXQgdXNpbmcgRE9NUGFyc2VyLnBhcnNlRnJvbVN0cmluZyBjYXVzZXMgdGhpcyBpc3N1ZS5cbiAgcHVibGljIHRvRG9jdW1lbnQoaHRtbFN0cmluZzogc3RyaW5nKTogSFRNTERvY3VtZW50IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sU3RyaW5nLCAndGV4dC9odG1sJyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgSFRNTCBzdHJpbmcgdG8gRElWRWxlbWVudC5cbiAgICpcbiAgICogRE9NUGFyc2VyLnBhcnNlRnJvbVN0cmluZyBmYWlscyB3aXRoIGltZ1tzcmNzZXRdIG9uIGlPUy5cbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iYXJiYWpzL2JhcmJhL2lzc3Vlcy8zNjJcbiAgICovXG4gIHB1YmxpYyB0b0VsZW1lbnQoaHRtbFN0cmluZzogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZGl2LmlubmVySFRNTCA9IGh0bWxTdHJpbmc7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgSFRNTCBjb250ZW50LlxuICAgKi9cbiAgcHVibGljIGdldEh0bWwoZG9jOiBIVE1MRG9jdW1lbnQgPSBkb2N1bWVudCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoZG9jLmRvY3VtZW50RWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZ1bGwgZG9jdW1lbnQgY29udGVudC5cbiAgICovXG4gIC8vIGdldERvY3VtZW50KGVsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gIC8vICAgcmV0dXJuIHRoaXMudG9TdHIoZWwpO1xuICAvLyB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYFtkYXRhLWJhcmJhPVwid3JhcHBlclwiXWAuXG4gICAqL1xuICBwdWJsaWMgZ2V0V3JhcHBlcihzY29wZTogU2NvcGUgPSBkb2N1bWVudCk6IFdyYXBwZXIge1xuICAgIHJldHVybiBzY29wZS5xdWVyeVNlbGVjdG9yKFxuICAgICAgYFske3RoaXMuX2F0dHIucHJlZml4fT1cIiR7dGhpcy5fYXR0ci53cmFwcGVyfVwiXWBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBgW2RhdGEtYmFyYmE9XCJjb250YWluZXJcIl1gLlxuICAgKi9cbiAgcHVibGljIGdldENvbnRhaW5lcihzY29wZTogU2NvcGUgPSBkb2N1bWVudCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIHNjb3BlLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBgWyR7dGhpcy5fYXR0ci5wcmVmaXh9PVwiJHt0aGlzLl9hdHRyLmNvbnRhaW5lcn1cIl1gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY29udGFpbmVyIGFuZCBzdG9yZSBuZXh0IHNpYmxpbmcgKGlmIGFwcGxpY2FibGUpLlxuICAgKi9cbiAgcHVibGljIHJlbW92ZUNvbnRhaW5lcihjb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMoY29udGFpbmVyKSkge1xuICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGNvbnRhaW5lciBiZWZvcmUgbmV4dCBzaWJsaW5nIG9yIGF0IHRoZSBlbmQgb2YgdGhlIHdyYXBwZXIuXG4gICAqL1xuICBwdWJsaWMgYWRkQ29udGFpbmVyKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHdyYXBwZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgZXhpc3RpbmdDb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuXG4gICAgaWYgKGV4aXN0aW5nQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLl9pbnNlcnRBZnRlcihjb250YWluZXIsIGV4aXN0aW5nQ29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYFtkYXRhLWJhcmJhLW5hbWVzcGFjZV1gLlxuICAgKi9cbiAgcHVibGljIGdldE5hbWVzcGFjZShzY29wZTogU2NvcGUgPSBkb2N1bWVudCk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IG5zID0gc2NvcGUucXVlcnlTZWxlY3RvcihcbiAgICAgIGBbJHt0aGlzLl9hdHRyLnByZWZpeH0tJHt0aGlzLl9hdHRyLm5hbWVzcGFjZX1dYFxuICAgICk7XG5cbiAgICByZXR1cm4gbnNcbiAgICAgID8gbnMuZ2V0QXR0cmlidXRlKGAke3RoaXMuX2F0dHIucHJlZml4fS0ke3RoaXMuX2F0dHIubmFtZXNwYWNlfWApXG4gICAgICA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFVSTCBmcm9tIGBocmVmYCB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBnZXRIcmVmKGVsOiBMaW5rKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gSFRNTCB0YWdOYW1lIGlzIFVQUEVSQ0FTRSwgeGh0bWwgdGFnTmFtZSBrZWVwcyBleGlzdGluZyBjYXNlLlxuICAgIGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAvLyBIVE1MQW5jaG9yRWxlbWVudCwgZnVsbCBVUkwgYXZhaWxhYmxlXG4gICAgICBpZiAodHlwZW9mIGVsLmhyZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbC5ocmVmO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm9iYWJseSBhIFNWR0FFbGVtZW504oCmXG4gICAgICBjb25zdCBocmVmID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJyk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoaHJlZikge1xuICAgICAgICAvLyBXaGVuIGxpbmsgY29tZXMgZnJvbSBTVkcsIGBocmVmYCByZXR1cm5zIGFuIG9iamVjdCwgbm90IGEgc3RyaW5nLlxuICAgICAgICBjb25zdCBhdHRyOiBzdHJpbmcgPVxuICAgICAgICAgICgoaHJlZiBhcyB1bmtub3duKSBhcyBTVkdBbmltYXRlZFN0cmluZykuYmFzZVZhbCB8fCBocmVmO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVVcmwoYXR0cik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ29weXJpZ2h0IDIwMTQgU2ltb24gTHlkZWxsXG4gIC8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9seWRlbGwvcmVzb2x2ZS11cmwvYmxvYi9tYXN0ZXIvcmVzb2x2ZS11cmwuanNcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHVibGljIHJlc29sdmVVcmwoLi4udXJsczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBudW1VcmxzID0gdXJscy5sZW5ndGg7XG5cbiAgICBpZiAobnVtVXJscyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNvbHZlVXJsIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudDsgZ290IG5vbmUuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICBiYXNlLmhyZWYgPSBhcmd1bWVudHNbMF07XG5cbiAgICBpZiAobnVtVXJscyA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJhc2UuaHJlZjtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmluc2VydEJlZm9yZShiYXNlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuXG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBsZXQgcmVzb2x2ZWQ7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgbnVtVXJsczsgaW5kZXgrKykge1xuICAgICAgYS5ocmVmID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIHJlc29sdmVkID0gYS5ocmVmO1xuICAgICAgYmFzZS5ocmVmID0gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgaGVhZC5yZW1vdmVDaGlsZChiYXNlKTtcblxuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgbm9kZSBhZnRlciBhbm90aGVyIG5vZGUuXG4gICAqL1xuICBwcml2YXRlIF9pbnNlcnRBZnRlcihuZXdOb2RlOiBOb2RlLCByZWZlcmVuY2VOb2RlOiBOb2RlKSB7XG4gICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbiAgfVxufVxuXG5jb25zdCBkb20gPSBuZXcgRG9tKCk7XG5cbmV4cG9ydCB7IGRvbSB9O1xuIiwiaW1wb3J0IHsgSGlzdG9yeUFjdGlvbiwgTGlua0V2ZW50LCBUcmlnZ2VyIH0gZnJvbSAnLi4vZGVmcyc7XG4vLyBTY2hlbWFzXG5pbXBvcnQgeyBzY2hlbWFBdHRyaWJ1dGUgfSBmcm9tICcuLi9zY2hlbWFzL2F0dHJpYnV0ZSc7XG5cbi8qKlxuICogQGJhcmJhL2NvcmUvdXRpbHMvaGlzdG9yeVxuICogPGJyPjxicj5cbiAqICMjIEhpc3RvcnkgbWFuYWdlci5cbiAqXG4gKiAtIEtlZXAgdHJhY2sgb2YgdGhlIG5hdmlnYXRpb24gaGlzdG9yeVxuICpcbiAqIEBtb2R1bGUgY29yZS91dGlscy9oaXN0b3J5XG4gKiBAcHJlZmVycmVkXG4gKi9cblxuLyoqXG4gKiBTdGF0ZSBpdGVtLlxuICpcbiAqIEBwcm9wZXJ0eSBmcm9tXG4gKiBAcHJvcGVydHkgaW5kZXhcbiAqL1xuaW50ZXJmYWNlIElIaXN0b3J5SXRlbSB7XG4gIC8qKiBvcmlnaW4gKi9cbiAgZnJvbTogc3RyaW5nO1xuICAvKiogaW5kZXggKi9cbiAgaW5kZXg6IG51bWJlcjtcbiAgLyoqIHN0YXRlcyAqL1xuICBzdGF0ZXM6IElTdGF0ZUl0ZW1bXTtcbn1cblxuLyoqKi9cbmludGVyZmFjZSBJQ29vcmRzIHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG59XG5cbi8qKlxuICogSGlzdG9yeSBpdGVtLlxuICpcbiAqIEBwcm9wZXJ0eSBuYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSBzY3JvbGxcbiAqIEBwcm9wZXJ0eSBVUkxcbiAqL1xuaW50ZXJmYWNlIElTdGF0ZUl0ZW0ge1xuICAvKiogbmFtZXNwYWNlICovXG4gIG5zOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8qKiBTY3JvbGwgcG9zaXRpb24gKi9cbiAgc2Nyb2xsOiBJQ29vcmRzO1xuICAvKiogVVJMICovXG4gIHVybDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgSGlzdG9yeSB7XG4gIHByaXZhdGUgX3Nlc3Npb246IHN0cmluZztcbiAgcHJpdmF0ZSBfc3RhdGVzOiBJU3RhdGVJdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBfcG9pbnRlciA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbml0IHdpdGggZmlyc3Qgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgaW5pdCh1cmw6IHN0cmluZywgbnM6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX3Nlc3Npb24gPSAnYmFyYmEnO1xuICAgIGNvbnN0IGluZGV4ID0gMDtcblxuICAgIGNvbnN0IHN0YXRlOiBJU3RhdGVJdGVtID0ge1xuICAgICAgbnMsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgeDogd2luZG93LnNjcm9sbFgsXG4gICAgICAgIHk6IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgfSxcbiAgICAgIHVybCxcbiAgICB9O1xuXG4gICAgdGhpcy5fc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIHRoaXMuX3BvaW50ZXIgPSBpbmRleDtcblxuICAgIGNvbnN0IGl0ZW06IElIaXN0b3J5SXRlbSA9IHtcbiAgICAgIGZyb206IHRoaXMuX3Nlc3Npb24sXG4gICAgICBpbmRleCxcbiAgICAgIHN0YXRlczogWy4uLnRoaXMuX3N0YXRlc10sXG4gICAgfTtcblxuICAgIHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShpdGVtLCAnJywgdXJsKTtcbiAgfVxuXG4gIHB1YmxpYyBjaGFuZ2UoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgdHJpZ2dlcjogVHJpZ2dlcixcbiAgICBlPzogTGlua0V2ZW50IHwgUG9wU3RhdGVFdmVudFxuICApOiBUcmlnZ2VyIHtcbiAgICBpZiAoZSAmJiAoZSBhcyBQb3BTdGF0ZUV2ZW50KS5zdGF0ZSkge1xuICAgICAgLy8gSWYgcG9wc3RhdGUsIG1vdmUgdG8gZXhpc3Rpbmcgc3RhdGVcbiAgICAgIC8vIGFuZCBnZXQgYmFjay9mb3J3YXJkIGRpcmVjdGlvbi5cbiAgICAgIGNvbnN0IHsgc3RhdGUgfTogeyBzdGF0ZTogSUhpc3RvcnlJdGVtIH0gPSBlIGFzIFBvcFN0YXRlRXZlbnQ7XG4gICAgICBjb25zdCB7IGluZGV4IH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLl9wb2ludGVyIC0gaW5kZXg7XG5cbiAgICAgIHRyaWdnZXIgPSB0aGlzLl9nZXREaXJlY3Rpb24oZGlmZik7XG5cbiAgICAgIC8vIFdvcmsgd2l0aCBwcmV2aW91cyBzdGF0ZXNcbiAgICAgIHRoaXMucmVwbGFjZShzdGF0ZS5zdGF0ZXMpO1xuICAgICAgdGhpcy5fcG9pbnRlciA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgbmV3IHN0YXRlXG4gICAgICB0aGlzLmFkZCh1cmwsIHRyaWdnZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmlnZ2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBhZGQodXJsOiBzdHJpbmcsIHRyaWdnZXI6IFRyaWdnZXIpOiB2b2lkIHtcbiAgICAvLyBJZiBubyBzdGF0ZSwgaXQgd2lsbCBiZSB1cGRhdGVkIGxhdGVyLlxuICAgIGNvbnN0IG5zID0gJ3RtcCc7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnNpemU7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5fZ2V0QWN0aW9uKHRyaWdnZXIpO1xuICAgIGNvbnN0IHN0YXRlOiBJU3RhdGVJdGVtID0ge1xuICAgICAgbnMsXG4gICAgICBzY3JvbGw6IHtcbiAgICAgICAgeDogd2luZG93LnNjcm9sbFgsXG4gICAgICAgIHk6IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgfSxcbiAgICAgIHVybCxcbiAgICB9O1xuXG4gICAgdGhpcy5fc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIHRoaXMuX3BvaW50ZXIgPSBpbmRleDtcblxuICAgIGNvbnN0IGl0ZW06IElIaXN0b3J5SXRlbSA9IHtcbiAgICAgIGZyb206IHRoaXMuX3Nlc3Npb24sXG4gICAgICBpbmRleCxcbiAgICAgIHN0YXRlczogWy4uLnRoaXMuX3N0YXRlc10sXG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgd2luZG93Lmhpc3RvcnkgJiYgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGl0ZW0sICcnLCB1cmwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaXRlbSwgJycsIHVybCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoZGF0YTogYW55LCBpPzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgaW5kZXggPSBpIHx8IHRoaXMuX3BvaW50ZXI7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldChpbmRleCk7XG4gICAgY29uc3Qgc3RhdGU6IElTdGF0ZUl0ZW0gPSB7XG4gICAgICAuLi5leGlzdGluZyxcbiAgICAgIC4uLmRhdGEsXG4gICAgfTtcblxuICAgIHRoaXMuc2V0KGluZGV4LCBzdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGxhc3Qgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlKGk/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoaSkge1xuICAgICAgdGhpcy5fc3RhdGVzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdGVzLnBvcCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BvaW50ZXItLTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYWxsIHN0YXRlcy5cbiAgICovXG4gIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcbiAgICB0aGlzLl9zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLl9wb2ludGVyID0gLTE7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSBhbGwgc3RhdGVzLlxuICAgKi9cbiAgcHVibGljIHJlcGxhY2UobmV3U3RhdGVzOiBJU3RhdGVJdGVtW10pOiB2b2lkIHtcbiAgICB0aGlzLl9zdGF0ZXMgPSBuZXdTdGF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0YXRlIGJ5IGluZGV4LlxuICAgKi9cbiAgcHVibGljIGdldChpbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlc1tpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHN0YXRlIGJ5IGluZGV4LlxuICAgKi9cbiAgcHVibGljIHNldChpOiBudW1iZXIsIHN0YXRlOiBJU3RhdGVJdGVtKSB7XG4gICAgcmV0dXJuICh0aGlzLl9zdGF0ZXNbaV0gPSBzdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKi9cbiAgZ2V0IGN1cnJlbnQoKTogSVN0YXRlSXRlbSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlc1t0aGlzLl9wb2ludGVyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhc3Qgc3RhdGUgKHRvcCBvZiB0aGUgaGlzdG9yeSBzdGFjaykuXG4gICAqL1xuICBnZXQgc3RhdGUoKTogSVN0YXRlSXRlbSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlc1t0aGlzLl9zdGF0ZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICovXG4gIGdldCBwcmV2aW91cygpOiBJU3RhdGVJdGVtIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50ZXIgPCAxID8gbnVsbCA6IHRoaXMuX3N0YXRlc1t0aGlzLl9wb2ludGVyIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBzaXplLlxuICAgKi9cbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVzLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhpc3RvcnkgYWN0aW9uOiBwdXNoIHZzIHJlcGxhY2VcbiAgICovXG4gIHByaXZhdGUgX2dldEFjdGlvbih0cmlnZ2VyOiBUcmlnZ2VyKTogSGlzdG9yeUFjdGlvbiB7XG4gICAgbGV0IGFjdGlvbjogSGlzdG9yeUFjdGlvbiA9ICdwdXNoJztcblxuICAgIC8vIE1hbmFnZSBgZGF0YS1iYXJiYS1oaXN0b3J5YCBhdHRyaWJ1dGVcbiAgICAvLyB0byBnZXQgdGhlIHJpZ2h0IGFjdGlvbiAocHVzaCB2cyByZXBsYWNlKS5cbiAgICBjb25zdCBlbCA9IHRyaWdnZXIgYXMgSFRNTEFuY2hvckVsZW1lbnQ7XG4gICAgY29uc3QgYXR0ciA9IGAke3NjaGVtYUF0dHJpYnV0ZS5wcmVmaXh9LSR7c2NoZW1hQXR0cmlidXRlLmhpc3Rvcnl9YDtcblxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUgJiYgZWwuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICBhY3Rpb24gPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cikgYXMgSGlzdG9yeUFjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGlyZWN0aW9uIG9mIHBvcHN0YXRlIGNoYW5nZVxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0RGlyZWN0aW9uKGRpZmY6IG51bWJlcik6IFRyaWdnZXIge1xuICAgIC8vIENoZWNrIGlmIFwic2Vzc2lvbiBzd2l0Y2hcIlxuICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IDEpIHtcbiAgICAgIC8vIEV4IDYtMCA+IDAgLT4gZm9yd2FyZCwgMC02IDwgMCAtPiBiYWNrXG4gICAgICByZXR1cm4gZGlmZiA+IDAgPyAnZm9yd2FyZCcgOiAnYmFjayc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybiAncG9wc3RhdGUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXggNi01ID4gMCAtPiBiYWNrLCA1LTYgPCAwIC0+IGZvcndhcmRcbiAgICAgICAgcmV0dXJuIGRpZmYgPiAwID8gJ2JhY2snIDogJ2ZvcndhcmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBoaXN0b3J5ID0gbmV3IEhpc3RvcnkoKTtcblxuZXhwb3J0IHsgaGlzdG9yeSB9O1xuIiwiLyoqXG4gKiBAYmFyYmEvY29yZS91dGlscy9oZWxwZXJzXG4gKiA8YnI+PGJyPlxuICogIyMgSGVscGVyc1xuICpcbiAqIC0gVXBkYXRlIG5leHQgcGFnZSBkYXRhXG4gKlxuICogQG1vZHVsZSBjb3JlL3V0aWxzL2hlbHBlcnNcbiAqIEBwcmVmZXJyZWRcbiAqL1xuXG4vKioqL1xuXG4vLyBUaGlyZC1wYXJ0eVxuaW1wb3J0IHB0ciBmcm9tICdwYXRoLXRvLXJlZ2V4cCc7XG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSVRyYW5zaXRpb25EYXRhIH0gZnJvbSAnLi4vZGVmcyc7XG4vLyBVdGlsc1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHsgaGlzdG9yeSB9IGZyb20gJy4vaGlzdG9yeSc7XG5cbi8qKlxuICogVXBkYXRlIGBkYXRhLm5leHRgLCB0aGUgdGl0bGUgYW5kIHRoZSBoaXN0b3J5XG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGUgPSBhc3luYyAoXG4gIHBhZ2U6IFByb21pc2U8c3RyaW5nIHwgdm9pZD4sXG4gIGRhdGE6IElUcmFuc2l0aW9uRGF0YVxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIElmIG5vdCBhbHJlYWR5IHVwZGF0ZWRcbiAgaWYgKCFkYXRhLm5leHQuaHRtbCkge1xuICAgIGNvbnN0IGh0bWwgPSBhd2FpdCBwYWdlO1xuICAgIGNvbnN0IHsgbmV4dCB9ID0gZGF0YTtcblxuICAgIGlmIChodG1sKSB7XG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYXJiYWpzL2JhcmJhL2lzc3Vlcy8zNjJcbiAgICAgIC8vIGNvbnN0IG5leHREb2N1bWVudCA9IGRvbS50b0RvY3VtZW50KGh0bWwpO1xuICAgICAgY29uc3QgbmV4dERvY3VtZW50ID0gZG9tLnRvRWxlbWVudChodG1sKTtcblxuICAgICAgbmV4dC5uYW1lc3BhY2UgPSBkb20uZ2V0TmFtZXNwYWNlKG5leHREb2N1bWVudCk7XG4gICAgICBuZXh0LmNvbnRhaW5lciA9IGRvbS5nZXRDb250YWluZXIobmV4dERvY3VtZW50KTtcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmFyYmFqcy9iYXJiYS9pc3N1ZXMvMzYyXG4gICAgICAvLyBuZXh0Lmh0bWwgPSBkb20uZ2V0SHRtbChuZXh0RG9jdW1lbnQpO1xuICAgICAgLy8gbmV4dC5odG1sID0gbmV4dERvY3VtZW50LmlubmVySFRNTDtcbiAgICAgIG5leHQuaHRtbCA9IGh0bWw7XG5cbiAgICAgIC8vIFVwZGF0ZSBoaXN0b3J5IG5hbWVzcGFjZSAobm90IGF2YWlsYWJsZSB3aGVuIGluaXRpYWxseSBzZXQpXG4gICAgICBoaXN0b3J5LnVwZGF0ZSh7IG5zOiBuZXh0Lm5hbWVzcGFjZSB9KTtcblxuICAgICAgLy8gVXBkYXRlIHRpdGxlLlxuICAgICAgY29uc3QgeyB0aXRsZSB9ID0gZG9tLnRvRG9jdW1lbnQoaHRtbCk7XG5cbiAgICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE5leHQgdGlja1xuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSAoKSA9PlxuICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpO1xuICAgIC8vIERFVjogc2FtZSByZXN1bHQ/XG4gICAgLy8gc2V0VGltZW91dChyZXNvbHZlLCAwKTtcbiAgfSk7XG5cbi8qKlxuICogVHVybiBhIHJvdXRlIHN0cmluZyBzdWNoIGFzIGAvdXNlci86bmFtZWAgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBVc2VkIGZvcjpcbiAqXG4gKiAtIHJvdXRlcyB0byBpZ25vcmVcbiAqIC0gcm91dGUgdHJhbnNpdGlvbiByZXNvbHV0aW9uXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9wYXRoLXRvLXJlZ2V4cFxuICovXG5jb25zdCBwYXRoVG9SZWdleHAgPSBwdHI7XG5cbmV4cG9ydCB7IHBhdGhUb1JlZ2V4cCB9O1xuIiwiLyoqXG4gKiBAYmFyYmEvY29yZS91dGlscy91cmxcbiAqIDxicj48YnI+XG4gKiAjIyBVUkwgdXRpbHMuXG4gKlxuICogLSBDb2xsZWN0IGFuZCBzdHJ1Y3R1cmUgaW5mb3JtYXRpb25zIGZyb20gVVJMc1xuICpcbiAqIEBtb2R1bGUgY29yZS91dGlscy91cmxcbiAqL1xuXG4vKioqL1xuXG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSUdlbmVyaWNPYmplY3QsIElVcmxCYXNlIH0gZnJvbSAnLi4vZGVmcyc7XG5cbi8qKlxuICogR2V0IGxvY2F0aW9uIGhyZWYuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRIcmVmID0gKCkgPT4gd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbi8qKlxuICogR2V0IGxvY2F0aW9uIG9yaWdpbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yaWdpbiA9ICgpID0+IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbi8qKlxuICogR2V0IHBvcnQgYmFzZWQgb24gVVJMIG9yIGxvY2F0aW9uLlxuICovXG5leHBvcnQgY29uc3QgZ2V0UG9ydCA9ICh1cmw6IHN0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSA9PiBwYXJzZSh1cmwpLnBvcnQ7XG5cbi8qKlxuICogR2V0IHBhdGggZnJvbSBVUkwuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQYXRoID0gKHVybDogc3RyaW5nID0gd2luZG93LmxvY2F0aW9uLmhyZWYpID0+IHBhcnNlKHVybCkucGF0aDtcblxuLyoqXG4gKiBHZXQgcXVlcnkgb2JqZWN0IGZyb20gVVJMLlxuICovXG4vLyBleHBvcnQgY29uc3QgZ2V0UXVlcnkgPSAodXJsOiBzdHJpbmcpOiBJR2VuZXJpY09iamVjdCA9PiBwYXJzZSh1cmwpLnF1ZXJ5O1xuXG4vKipcbiAqIEdldCBoYXNoIGZyb20gVVJMLlxuICovXG4vLyBleHBvcnQgY29uc3QgZ2V0SGFzaCA9ICh1cmw6IHN0cmluZyk6IHN0cmluZyA9PiBwYXJzZSh1cmwpLmhhc2g7XG5cbi8qKlxuICogUGFyc2UgVVJMIGZvciBwYXRoLCBxdWVyeSBhbmQgaGFzaCBhbmQgbW9yZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlID0gKHVybDogc3RyaW5nKTogSVVybEJhc2UgPT4ge1xuICAvLyBQb3J0XG4gIGxldCBwb3J0O1xuICBjb25zdCBtYXRjaGVzID0gdXJsLm1hdGNoKC86XFxkKy8pO1xuXG4gIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgaWYgKC9eaHR0cC8udGVzdCh1cmwpKSB7XG4gICAgICBwb3J0ID0gODA7XG4gICAgfVxuXG4gICAgaWYgKC9eaHR0cHMvLnRlc3QodXJsKSkge1xuICAgICAgcG9ydCA9IDQ0MztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcG9ydFN0cmluZyA9IG1hdGNoZXNbMF0uc3Vic3RyaW5nKDEpO1xuXG4gICAgcG9ydCA9IHBhcnNlSW50KHBvcnRTdHJpbmcsIDEwKTtcbiAgfVxuXG4gIC8vIFBhdGhcbiAgbGV0IHBhdGggPSB1cmwucmVwbGFjZShnZXRPcmlnaW4oKSwgJycpO1xuICBsZXQgaGFzaDtcbiAgbGV0IHF1ZXJ5ID0ge307XG5cbiAgLy8gSGFzaFxuICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcblxuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICBoYXNoID0gcGF0aC5zbGljZShoYXNoSW5kZXggKyAxKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgLy8gUXVlcnlcbiAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuXG4gIGlmIChxdWVyeUluZGV4ID49IDApIHtcbiAgICBxdWVyeSA9IHBhcnNlUXVlcnkocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSkpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHF1ZXJ5SW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYXNoLFxuICAgIHBhdGgsXG4gICAgcG9ydCxcbiAgICBxdWVyeSxcbiAgfTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBxdWVyeSBzdHJpbmcgdG8gb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgcGFyc2VRdWVyeSA9IChzdHI6IHN0cmluZykgPT5cbiAgc3RyLnNwbGl0KCcmJykucmVkdWNlKChhY2M6IElHZW5lcmljT2JqZWN0LCBlbDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gZWwuc3BsaXQoJz0nKTtcblxuICAgIGFjY1trZXldID0gdmFsdWU7XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG5cbi8qKlxuICogQ2xlYW4gVVJMLCByZW1vdmUgXCJoYXNoXCIgYW5kL29yIFwidHJhaWxpbmcgc2xhc2hcIi5cbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFuID0gKHVybDogc3RyaW5nID0gd2luZG93LmxvY2F0aW9uLmhyZWYpID0+XG4gIHVybC5yZXBsYWNlKC8oXFwvIy4qfFxcL3wjLiopJC8sICcnKTtcbiIsIi8qKlxuICogQGJhcmJhL2NvcmUvdXRpbHMvcmVxdWVzdFxuICogPGJyPjxicj5cbiAqICMjIEZldGNoIHBhZ2VzIGZvciB0cmFuc2l0aW9ucy5cbiAqXG4gKiAtIEluY2x1ZGVzIHRpbWVvdXRcbiAqIC0gVXNlcyBGZXRjaCBBUElcbiAqIC0gSGFuZGxlcyBlcnJvcnNcbiAqXG4gKiBAbW9kdWxlIGNvcmUvdXRpbHMvcmVxdWVzdFxuICogQHByZWZlcnJlZFxuICovXG5cbi8qKiovXG5cbi8vIERlZmluaXRpb25zXG5pbXBvcnQgeyBSZXF1ZXN0RXJyb3IgfSBmcm9tICcuLi9kZWZzJztcblxuLyoqXG4gKiBJbml0IGEgcGFnZSByZXF1ZXN0LlxuICogRmV0Y2ggdGhlIHBhZ2UgYW5kIHJldHVybnMgYSBwcm9taXNlIHdpdGggdGhlIHRleHQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gcmVxdWVzdChcbiAgdXJsOiBzdHJpbmcsXG4gIHR0bDogbnVtYmVyID0gMmUzLFxuICByZXF1ZXN0RXJyb3I6IFJlcXVlc3RFcnJvclxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnN0YXR1cykge1xuICAgICAgICAgIC8vIEhUVFAgY29kZSBpcyBub3QgMjAwLCByZWplY3Qgd2l0aCByZXNwb25zZS5cbiAgICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlcXVlc3RFcnJvcih1cmwsIHJlcyk7XG4gICAgICAgICAgcmVqZWN0KHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFRpbWVvdXQgZXJyb3IgWyR7dHRsfV1gKTtcbiAgICAgIHJlcXVlc3RFcnJvcih1cmwsIGVycik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBGZXRjaCBlcnJvcmApO1xuICAgICAgcmVxdWVzdEVycm9yKHVybCwgZXJyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG5cbiAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICB4aHIudGltZW91dCA9IHR0bDtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcbiAgICAgICdBY2NlcHQnLFxuICAgICAgJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sJ1xuICAgICk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ3gtYmFyYmEnLCAneWVzJyk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IHJlcXVlc3QgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuIiwiaW1wb3J0IGlzUHJvbWlzZSBmcm9tICdpcy1wcm9taXNlJztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1NCb3Vkcmlhcy9ydW4tYXN5bmNcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgZnVuY3Rpb24gcnVuQXN5bmMoXG4gIGZ1bmM6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCB8IFByb21pc2U8YW55PixcbiAgY3R4OiBhbnkgPSB7fVxuKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgbGV0IGFzeW5jID0gZmFsc2U7XG5cbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gQWRkIGFzeW5jIHRvIGNvbnRleHRcbiAgICAgIGN0eC5hc3luYyA9ICgpID0+IHtcbiAgICAgICAgYXN5bmMgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiAoZXJyOiBhbnksIHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgYW5zd2VyID0gZnVuYy5hcHBseShjdHgsIGFyZ3MgYXMgW10pO1xuXG4gICAgICBpZiAoIWFzeW5jKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UoYW5zd2VyKSkge1xuICAgICAgICAgIChhbnN3ZXIgYXMgUHJvbWlzZTxhbnk+KS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn1cbiIsIi8qKlxuICogQGJhcmJhL2NvcmUvbW9kdWxlcy9ob29rc1xuICogPGJyPjxicj5cbiAqICMjIEhvb2tzIG1hbmFnZXIuXG4gKlxuICogLSBSZWdpc3RlciBhbmQgdHJpZ2dlciBob29rc1xuICpcbiAqIEhvb2tzIGNhbiBiZSBlYXNpbHkgcmVnaXN0ZXJlZDpcbiAqXG4gKiBgYGBqc1xuICogaG9va3MubGVhdmUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICogYGBgXG4gKlxuICogQG1vZHVsZSBjb3JlL21vZHVsZXMvaG9va3NcbiAqIEBwcmVmZXJyZWRcbiAqL1xuXG4vKioqL1xuXG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSG9va0Z1bmN0aW9uLCBIb29rTWV0aG9kcywgSG9va3NBbGwgfSBmcm9tICcuL2RlZnMnO1xuLy8gTW9kdWxlc1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi9tb2R1bGVzL0xvZ2dlcic7XG4vLyBVdGlsc1xuaW1wb3J0IHsgcnVuQXN5bmMgfSBmcm9tICcuL3V0aWxzJztcbi8vIFR5cGVzXG5pbnRlcmZhY2UgSUhvb2tJbmZvcyB7XG4gIGN0eDogYW55O1xuICBmbjogSG9va0Z1bmN0aW9uO1xufVxuXG5leHBvcnQgY2xhc3MgSG9va3MgZXh0ZW5kcyBIb29rTWV0aG9kcyB7XG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgdXNlIG9mIGBob29rc1tuYW1lXShjYiwgY3R4KWAuXG4gICAqL1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIC8vIFtrZXkgaW4gSG9va3NBbGxdPzogYW55O1xuICBwdWJsaWMgbG9nZ2VyOiBMb2dnZXIgPSBuZXcgTG9nZ2VyKCdAYmFyYmEvY29yZScpO1xuICAvKipcbiAgICogQWxsIGF2YWlsYWJsZSBob29rcy5cbiAgICpcbiAgICogU2VlIFtbSG9va3NBbGxdXVxuICAgKi9cbiAgLy8gVE9ETzogZ2V0IGhvb2tzIGZyb20gZGVmcyAoRFJZKT9cbiAgcHVibGljIGFsbDogSG9va3NBbGxbXSA9IFtcbiAgICAncmVhZHknLFxuICAgICdwYWdlJyxcbiAgICAncmVzZXQnLFxuICAgICdjdXJyZW50QWRkZWQnLFxuICAgICdjdXJyZW50UmVtb3ZlZCcsXG4gICAgJ25leHRBZGRlZCcsXG4gICAgJ25leHRSZW1vdmVkJyxcbiAgICAnYmVmb3JlT25jZScsXG4gICAgJ29uY2UnLFxuICAgICdhZnRlck9uY2UnLFxuICAgICdiZWZvcmUnLFxuICAgICdiZWZvcmVMZWF2ZScsXG4gICAgJ2xlYXZlJyxcbiAgICAnYWZ0ZXJMZWF2ZScsXG4gICAgJ2JlZm9yZUVudGVyJyxcbiAgICAnZW50ZXInLFxuICAgICdhZnRlckVudGVyJyxcbiAgICAnYWZ0ZXInLFxuICBdO1xuICAvKipcbiAgICogUmVnaXN0ZXJlZCBob29rcy5cbiAgICpcbiAgICogLSBVbmlxdWUgaG9vayBuYW1lXG4gICAqIC0gQXNzb2NpYXRlZCBkYXRhIHNldChzKSAoY2FsbGJhY2sgKyBjb250ZXh0KVxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyZWQ6IE1hcDxIb29rc0FsbCwgU2V0PElIb29rSW5mb3M+PiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgcHVibGljIGluaXQoKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkLmNsZWFyKCk7XG4gICAgdGhpcy5hbGwuZm9yRWFjaChob29rID0+IHtcbiAgICAgIGlmICghdGhpc1tob29rXSkge1xuICAgICAgICB0aGlzW2hvb2tdID0gKGZuOiBIb29rRnVuY3Rpb24sIGN0eD86IGFueSkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5yZWdpc3RlcmVkLmhhcyhob29rKSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkLnNldChob29rLCBuZXcgU2V0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzZXQgPSB0aGlzLnJlZ2lzdGVyZWQuZ2V0KGhvb2spO1xuXG4gICAgICAgICAgc2V0LmFkZCh7XG4gICAgICAgICAgICBjdHg6IGN0eCB8fCB7fSxcbiAgICAgICAgICAgIGZuLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERvIGhvb2suXG4gICAqXG4gICAqIFRyaWdnZXIgcmVnaXN0ZXJlZCBob29rcy5cbiAgICovXG4gIHB1YmxpYyBkbyhuYW1lOiBIb29rc0FsbCwgLi4uYXJnczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAodGhpcy5yZWdpc3RlcmVkLmhhcyhuYW1lKSkge1xuICAgICAgLy8gTGV0J3Mgc3RhcnQgYSBjaGFpbiBvZiBwcm9taXNlc1xuICAgICAgbGV0IGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICAgIHRoaXMucmVnaXN0ZXJlZC5nZXQobmFtZSkuZm9yRWFjaChob29rID0+IHtcbiAgICAgICAgLy8gQ2hhaW4gYXN5bmMgaG9va3MgcHJvbWlzaWZpZWRcbiAgICAgICAgY2hhaW4gPSBjaGFpbi50aGVuKCgpID0+IHJ1bkFzeW5jKGhvb2suZm4sIGhvb2suY3R4KSguLi5hcmdzKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNoYWluLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYEhvb2sgZXJyb3IgWyR7bmFtZX1dYCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcbiAgICB0aGlzLmFsbC5mb3JFYWNoKGhvb2sgPT4ge1xuICAgICAgZGVsZXRlIHRoaXNbaG9va107XG4gICAgfSk7XG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwLCBwcmludCBhdmFpbGFibGUgYW5kIHJlZ2lzdGVyZWQgaG9va3MuXG4gICAqL1xuICBwdWJsaWMgaGVscCgpOiB2b2lkIHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKGBBdmFpbGFibGUgaG9va3M6ICR7dGhpcy5hbGwuam9pbignLCcpfWApO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWQ6IHN0cmluZ1tdID0gW107XG4gICAgdGhpcy5yZWdpc3RlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHJlZ2lzdGVyZWQucHVzaChrZXkpKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKGBSZWdpc3RlcmVkIGhvb2tzOiAke3JlZ2lzdGVyZWQuam9pbignLCcpfWApO1xuICB9XG59XG5cbmNvbnN0IGhvb2tzID0gbmV3IEhvb2tzKCk7XG5cbmV4cG9ydCB7IGhvb2tzIH07XG4iLCIvKipcbiAqIEBiYXJiYS9jb3JlL21vZHVsZXMvaWdub3JlXG4gKiA8YnI+PGJyPlxuICogIyMgTWFuYWdlIGlnbm9yZSBvcHRpb25zLlxuICpcbiAqIC0gY2FjaGVcbiAqIC0gcHJlZmV0Y2hcbiAqXG4gKiBAbW9kdWxlIGNvcmUvbW9kdWxlcy9pZ25vcmVcbiAqIEBwcmVmZXJyZWRcbiAqL1xuXG4vKioqL1xuXG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSWdub3JlT3B0aW9uIH0gZnJvbSAnLi4vZGVmcyc7XG4vLyBVdGlsc1xuaW1wb3J0IHsgcGF0aFRvUmVnZXhwIH0gZnJvbSAnLi4vdXRpbHMvaGVscGVycyc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4uL3V0aWxzL3VybCc7XG5cbmV4cG9ydCBjbGFzcyBJZ25vcmUge1xuICBwcml2YXRlIF9pZ25vcmVBbGw6IGJvb2xlYW47XG4gIHByaXZhdGUgX2lnbm9yZVJlZ2V4ZXM6IFJlZ0V4cFtdID0gW107XG5cbiAgY29uc3RydWN0b3IoaWdub3JlOiBJZ25vcmVPcHRpb24pIHtcbiAgICBpZiAodHlwZW9mIGlnbm9yZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLl9pZ25vcmVBbGwgPSBpZ25vcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShpZ25vcmUpID8gaWdub3JlIDogW2lnbm9yZV07XG5cbiAgICAgIHRoaXMuX2lnbm9yZVJlZ2V4ZXMgPSBwYXRocy5tYXAocCA9PiBwYXRoVG9SZWdleHAocCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjaGVja0hyZWYoaHJlZjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pZ25vcmVBbGwgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2lnbm9yZUFsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IHBhdGggfSA9IHBhcnNlKGhyZWYpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2lnbm9yZVJlZ2V4ZXMuc29tZShyZWdleCA9PiByZWdleC5leGVjKHBhdGgpICE9PSBudWxsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAYmFyYmEvY29yZS9tb2R1bGVzL2NhY2hlXG4gKiA8YnI+PGJyPlxuICogIyMgQ2FjaGUgZm9yIHN0b3JpbmcgVVJMIC8gSFRNTC5cbiAqXG4gKiBAbW9kdWxlIGNvcmUvbW9kdWxlcy9jYWNoZVxuICogQHByZWZlcnJlZFxuICovXG5cbi8qKiovXG5cbi8vIERlZmluaXRpb25zXG5pbXBvcnQgeyBDYWNoZUFjdGlvbiwgQ2FjaGVSZXF1ZXN0LCBJQ2FjaGVEYXRhLCBJZ25vcmVPcHRpb24gfSBmcm9tICcuLi9kZWZzJztcbi8vIE1vZHVsZXNcbmltcG9ydCB7IElnbm9yZSB9IGZyb20gJy4vSWdub3JlJztcblxuZXhwb3J0IGNsYXNzIENhY2hlIGV4dGVuZHMgSWdub3JlIHtcbiAgcHJpdmF0ZSBfc3RhdGU6IE1hcDxzdHJpbmcsIElDYWNoZURhdGE+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKGlnbm9yZTogSWdub3JlT3B0aW9uKSB7XG4gICAgc3VwZXIoaWdub3JlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdmFsdWUgdG8gY2FjaGVcbiAgICovXG4gIHB1YmxpYyBzZXQoXG4gICAgaHJlZjogc3RyaW5nLFxuICAgIHJlcXVlc3Q6IENhY2hlUmVxdWVzdCxcbiAgICBhY3Rpb246IENhY2hlQWN0aW9uXG4gICk6IElDYWNoZURhdGEge1xuICAgIHRoaXMuX3N0YXRlLnNldChocmVmLCB7XG4gICAgICBhY3Rpb24sXG4gICAgICByZXF1ZXN0LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbixcbiAgICAgIHJlcXVlc3QsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSBmcm9tIGNhY2hlXG4gICAqL1xuICBwdWJsaWMgZ2V0KGhyZWY6IHN0cmluZyk6IElDYWNoZURhdGEge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXQoaHJlZik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlcXVlc3QgZnJvbSBjYWNoZVxuICAgKi9cbiAgcHVibGljIGdldFJlcXVlc3QoaHJlZjogc3RyaW5nKTogQ2FjaGVSZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0KGhyZWYpLnJlcXVlc3Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjdGlvbiBmcm9tIGNhY2hlXG4gICAqL1xuICBwdWJsaWMgZ2V0QWN0aW9uKGhyZWY6IHN0cmluZyk6IENhY2hlQWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0KGhyZWYpLmFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB2YWx1ZSBleGlzdHMgaW50byBjYWNoZVxuICAgKi9cbiAgcHVibGljIGhhcyhocmVmOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0aGlzLmNoZWNrSHJlZihocmVmKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaGFzKGhyZWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB2YWx1ZSBmcm9tIGNhY2hlXG4gICAqL1xuICBwdWJsaWMgZGVsZXRlKGhyZWY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kZWxldGUoaHJlZik7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGNhY2hlIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGhyZWY6IHN0cmluZywgZGF0YTogSUNhY2hlRGF0YSk6IElDYWNoZURhdGEge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgLi4udGhpcy5fc3RhdGUuZ2V0KGhyZWYpLFxuICAgICAgLi4uZGF0YSxcbiAgICB9O1xuICAgIHRoaXMuX3N0YXRlLnNldChocmVmLCBzdGF0ZSk7XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cbiIsIi8qKlxuICogQGJhcmJhL2NvcmUvbW9kdWxlcy9wcmV2ZW50XG4gKiA8YnI+PGJyPlxuICogIyMgUHJldmVudCBjaGVja3MuXG4gKlxuICogLSBHYXRoZXJzIGFsbCB0aGUgdGVzdHMgdGhhdCBhbGxvdyBCYXJiYSB0byB3b3JrIGFuZCBwbGF5IHRyYW5zaXRpb25zXG4gKlxuICogQG1vZHVsZSBjb3JlL21vZHVsZXMvcHJldmVudFxuICogQHByZWZlcnJlZFxuICovXG5cbi8qKiovXG5cbi8vIERlZmluaXRpb25zXG5pbXBvcnQgeyBJZ25vcmVPcHRpb24sIExpbmssIFByZXZlbnRDaGVjayB9IGZyb20gJy4uL2RlZnMnO1xuLy8gU2NoZW1hc1xuaW1wb3J0IHsgc2NoZW1hQXR0cmlidXRlIH0gZnJvbSAnLi4vc2NoZW1hcy9hdHRyaWJ1dGUnO1xuLy8gVXRpbHNcbmltcG9ydCB7IHVybCB9IGZyb20gJy4uL3V0aWxzJztcbi8vIE1vZHVsZXNcbmltcG9ydCB7IElnbm9yZSB9IGZyb20gJy4vSWdub3JlJztcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYGhpc3RvcnkucHVzaFN0YXRlYC5cbiAqL1xuY29uc3QgcHVzaFN0YXRlOiBQcmV2ZW50Q2hlY2sgPSAoKSA9PiAhd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlO1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGVyZSBpcyBhbiBgZWxgIGFuZCBgaHJlZmAuXG4gKi9cbmNvbnN0IGV4aXN0czogUHJldmVudENoZWNrID0gKHsgZWwsIGhyZWYgfSkgPT4gIWVsIHx8ICFocmVmO1xuXG4vKipcbiAqIElmIHRoZSB1c2VyIGlzIHByZXNzaW5nIGN0cmwgKyBjbGljaywgdGhlIGJyb3dzZXIgd2lsbCBvcGVuIGEgbmV3IHRhYi5cbiAqL1xuY29uc3QgbmV3VGFiOiBQcmV2ZW50Q2hlY2sgPSAoeyBldmVudCB9KSA9PlxuICAoZXZlbnQgYXMgS2V5Ym9hcmRFdmVudCkud2hpY2ggPiAxIHx8XG4gIChldmVudCBhcyBLZXlib2FyZEV2ZW50KS5tZXRhS2V5IHx8XG4gIChldmVudCBhcyBLZXlib2FyZEV2ZW50KS5jdHJsS2V5IHx8XG4gIChldmVudCBhcyBLZXlib2FyZEV2ZW50KS5zaGlmdEtleSB8fFxuICAoZXZlbnQgYXMgS2V5Ym9hcmRFdmVudCkuYWx0S2V5O1xuXG4vKipcbiAqIElmIHRoZSBsaW5rIGhhcyBgX2JsYW5rYCB0YXJnZXQuXG4gKi9cbmNvbnN0IGJsYW5rOiBQcmV2ZW50Q2hlY2sgPSAoeyBlbCB9KSA9PlxuICBlbC5oYXNBdHRyaWJ1dGUoJ3RhcmdldCcpICYmIChlbCBhcyBMaW5rKS50YXJnZXQgPT09ICdfYmxhbmsnO1xuXG4vKipcbiAqIElmIHRoZSBkb21haW4gaXMgdGhlIHNhbWUgKGluIG9yZGVyIHRvIGF2b2lkIHB1c2hTdGF0ZSBjcm9zcyBvcmlnaW4gc2VjdXJpdHkgcHJvYmxlbSkuXG4gKiBOb3RlOiBTVkdBRWxlbWVudCBkbyBub3QgaGF2ZSBgcHJvdG9jb2xgIG5laXRoZXIgYGhvc3RuYW1lYCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCBjb3JzRG9tYWluOiBQcmV2ZW50Q2hlY2sgPSAoeyBlbCB9KSA9PlxuICAoKGVsIGFzIEhUTUxBbmNob3JFbGVtZW50KS5wcm90b2NvbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAoZWwgYXMgSFRNTEFuY2hvckVsZW1lbnQpLnByb3RvY29sKSB8fFxuICAoKGVsIGFzIEhUTUxBbmNob3JFbGVtZW50KS5ob3N0bmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICE9PSAoZWwgYXMgSFRNTEFuY2hvckVsZW1lbnQpLmhvc3RuYW1lKTtcblxuLyoqXG4gKiBJZiB0aGUgcG9ydCBpcyB0aGUgc2FtZS5cbiAqIE5vdGU6IFNWR0FFbGVtZW50IGRvIG5vdCBoYXZlIGBwb3J0YCBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgY29yc1BvcnQ6IFByZXZlbnRDaGVjayA9ICh7IGVsIH0pID0+XG4gIChlbCBhcyBIVE1MQW5jaG9yRWxlbWVudCkucG9ydCAhPT0gdW5kZWZpbmVkICYmXG4gIHVybC5nZXRQb3J0KCkgIT09IHVybC5nZXRQb3J0KChlbCBhcyBIVE1MQW5jaG9yRWxlbWVudCkuaHJlZik7XG5cbi8qKlxuICogSWYgdGhlIGxpbmsgaGFzIGRvd25sb2FkIGF0dHJpYnV0ZS5cbiAqL1xuY29uc3QgZG93bmxvYWQ6IFByZXZlbnRDaGVjayA9ICh7IGVsIH0pID0+XG4gIGVsLmdldEF0dHJpYnV0ZSAmJiB0eXBlb2YgZWwuZ2V0QXR0cmlidXRlKCdkb3dubG9hZCcpID09PSAnc3RyaW5nJztcblxuLyoqXG4gKiBJZiB0aGUgbGlua3MgY29udGFpbnMgW2RhdGEtYmFyYmEtcHJldmVudF0gb3IgW2RhdGEtYmFyYmEtcHJldmVudD1cInNlbGZcIl0uXG4gKi9cbmNvbnN0IHByZXZlbnRTZWxmOiBQcmV2ZW50Q2hlY2sgPSAoeyBlbCB9KSA9PlxuICBlbC5oYXNBdHRyaWJ1dGUoYCR7c2NoZW1hQXR0cmlidXRlLnByZWZpeH0tJHtzY2hlbWFBdHRyaWJ1dGUucHJldmVudH1gKTtcblxuLyoqXG4gKiBJZiBzb21lIGxpbmsgYW5jZXN0b3IgY29udGFpbnMgW2RhdGEtYmFyYmEtcHJldmVudD1cImFsbFwiXS5cbiAqL1xuY29uc3QgcHJldmVudEFsbDogUHJldmVudENoZWNrID0gKHsgZWwgfSkgPT5cbiAgQm9vbGVhbihcbiAgICBlbC5jbG9zZXN0KGBbJHtzY2hlbWFBdHRyaWJ1dGUucHJlZml4fS0ke3NjaGVtYUF0dHJpYnV0ZS5wcmV2ZW50fT1cImFsbFwiXWApXG4gICk7XG5cbi8qKlxuICogSWYgdGhlIGxpbmsgaXMgdGhlIGN1cnJlbnQgVVJMLlxuICpcbiAqID4gTm90IGluIHRoZSB0ZXN0IHN1aXRlLlxuICovXG5jb25zdCBzYW1lVXJsOiBQcmV2ZW50Q2hlY2sgPSAoeyBocmVmIH0pID0+XG4gIHVybC5jbGVhbihocmVmKSA9PT0gdXJsLmNsZWFuKCkgJiYgdXJsLmdldFBvcnQoaHJlZikgPT09IHVybC5nZXRQb3J0KCk7XG5cbmV4cG9ydCBjbGFzcyBQcmV2ZW50IGV4dGVuZHMgSWdub3JlIHtcbiAgcHVibGljIHN1aXRlOiBzdHJpbmdbXSA9IFtdO1xuICBwdWJsaWMgdGVzdHM6IE1hcDxzdHJpbmcsIFByZXZlbnRDaGVjaz4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoaWdub3JlOiBJZ25vcmVPcHRpb24pIHtcbiAgICBzdXBlcihpZ25vcmUpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgcHVibGljIGluaXQoKTogdm9pZCB7XG4gICAgLy8gQWRkIGRlZmF1bHRzXG4gICAgdGhpcy5hZGQoJ3B1c2hTdGF0ZScsIHB1c2hTdGF0ZSk7XG4gICAgdGhpcy5hZGQoJ2V4aXN0cycsIGV4aXN0cyk7XG4gICAgdGhpcy5hZGQoJ25ld1RhYicsIG5ld1RhYik7XG4gICAgdGhpcy5hZGQoJ2JsYW5rJywgYmxhbmspO1xuICAgIHRoaXMuYWRkKCdjb3JzRG9tYWluJywgY29yc0RvbWFpbik7XG4gICAgdGhpcy5hZGQoJ2NvcnNQb3J0JywgY29yc1BvcnQpO1xuICAgIHRoaXMuYWRkKCdkb3dubG9hZCcsIGRvd25sb2FkKTtcbiAgICB0aGlzLmFkZCgncHJldmVudFNlbGYnLCBwcmV2ZW50U2VsZik7XG4gICAgdGhpcy5hZGQoJ3ByZXZlbnRBbGwnLCBwcmV2ZW50QWxsKTtcblxuICAgIC8vIE91dHNpZGUgb2YgdGhlIHRlc3Qgc3VpdGVcbiAgICB0aGlzLmFkZCgnc2FtZVVybCcsIHNhbWVVcmwsIGZhbHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGQobmFtZTogc3RyaW5nLCBjaGVjazogUHJldmVudENoZWNrLCBzdWl0ZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICB0aGlzLnRlc3RzLnNldChuYW1lLCBjaGVjayk7XG4gICAgc3VpdGUgJiYgdGhpcy5zdWl0ZS5wdXNoKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBpbmRpdmlkdWFsIHRlc3RcbiAgICovXG4gIHB1YmxpYyBydW4obmFtZTogc3RyaW5nLCBlbDogTGluaywgZXZlbnQ6IEV2ZW50LCBocmVmOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0cy5nZXQobmFtZSkoe1xuICAgICAgZWwsXG4gICAgICBldmVudCxcbiAgICAgIGhyZWYsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIHRlc3Qgc3VpdGVcbiAgICovXG4gIHB1YmxpYyBjaGVja0xpbmsoZWw6IExpbmssIGV2ZW50OiBFdmVudCwgaHJlZjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3VpdGUuc29tZShuYW1lID0+IHRoaXMucnVuKG5hbWUsIGVsLCBldmVudCwgaHJlZikpO1xuICB9XG59XG4iLCIvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclxuZXhwb3J0IGNsYXNzIEJhcmJhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBlcnJvcjogRXJyb3IsXG4gICAgcHVibGljIGxhYmVsID0gJ0JhcmJhIGVycm9yJyxcbiAgICAuLi5wYXJhbXM6IGFueVtdXG4gICkge1xuICAgIC8vIFBhc3MgcmVtYWluaW5nIGFyZ3VtZW50cyAoaW5jbHVkaW5nIHZlbmRvciBzcGVjaWZpYyBvbmVzKSB0byBwYXJlbnQgY29uc3RydWN0b3JcbiAgICBzdXBlciguLi5wYXJhbXMpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBCYXJiYUVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSAnQmFyYmFFcnJvcic7XG4gIH1cbn1cbiIsIi8qKlxuICogQGJhcmJhL2NvcmUvbW9kdWxlcy9zdG9yZVxuICogPGJyPjxicj5cbiAqICMjIFRyYW5zaXRpb25zIHN0b3JlLlxuICpcbiAqIC0gUmVzb2x2ZSB0cmFuc2l0aW9uXG4gKiAtIE1hbmFnZSBydWxlc1xuICpcbiAqIEBtb2R1bGUgY29yZS9tb2R1bGVzL3N0b3JlXG4gKiBAcHJlZmVycmVkXG4gKi9cblxuLyoqKi9cblxuLy8gRGVmaW5pdGlvbnNcbmltcG9ydCB7XG4gIElSdWxlLFxuICBJUnVsZXMsXG4gIElUcmFuc2l0aW9uRGF0YSxcbiAgSVRyYW5zaXRpb25GaWx0ZXJzLFxuICBJVHJhbnNpdGlvbk9uY2UsXG4gIElUcmFuc2l0aW9uUGFnZSxcbiAgUnVsZU5hbWUsXG59IGZyb20gJy4uL2RlZnMnO1xuXG4vLyBNb2R1bGVzXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuL0xvZ2dlcic7XG5cbmV4cG9ydCBjbGFzcyBTdG9yZSB7XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlciA9IG5ldyBMb2dnZXIoJ0BiYXJiYS9jb3JlJyk7XG4gIC8qKlxuICAgKiBBbGwgcmVnaXN0ZXJlZCB0cmFuc2l0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBhbGw6IElUcmFuc2l0aW9uUGFnZVtdID0gW107XG4gIC8qKlxuICAgKiBcIlBhZ2Ugb25seVwiIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgcGFnZTogSVRyYW5zaXRpb25QYWdlW10gPSBbXTtcbiAgLyoqXG4gICAqIFwiT25jZSBvbmx5XCIgcmVnaXN0ZXJlZCB0cmFuc2l0aW9ucy5cbiAgICovXG4gIHB1YmxpYyBvbmNlOiBJVHJhbnNpdGlvbk9uY2VbXSA9IFtdO1xuICAvKipcbiAgICogUnVsZXMgZm9yIHRyYW5zaXRpb24gcmVzb2x1dGlvbi5cbiAgICpcbiAgICogRGVmYXVsdHM6XG4gICAqXG4gICAqIC0gbmFtZXNwYWNlXG4gICAqIC0gY3VzdG9tXG4gICAqL1xuICBwcml2YXRlIF9ydWxlczogSVJ1bGVbXSA9IFtcbiAgICB7XG4gICAgICBuYW1lOiAnbmFtZXNwYWNlJyxcbiAgICAgIHR5cGU6ICdzdHJpbmdzJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdjdXN0b20nLFxuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB9LFxuICBdO1xuXG4gIC8qKlxuICAgKiBJbml0IHN0b3JlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHJhbnNpdGlvbnM6IElUcmFuc2l0aW9uUGFnZVtdID0gW10pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0cmFuc2l0aW9ucykge1xuICAgICAgLy8gVE9ETzogYWRkIGNoZWNrIGZvciB2YWxpZCB0cmFuc2l0aW9ucz8gY3JpdGVyaWE/IChvbmNlIHx8IGVudGVyICYmIGxlYXZlKVxuICAgICAgdGhpcy5hbGwgPSB0aGlzLmFsbC5jb25jYXQodHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBydWxlIG9yIHRyYW5zaXRpb24uXG4gICAqL1xuICBwdWJsaWMgYWRkKHR5cGU6ICdydWxlJyB8ICd0cmFuc2l0aW9uJywgZGF0YTogYW55KTogdm9pZCB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdydWxlJzpcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIHZhbGlkIHJ1bGVcbiAgICAgICAgdGhpcy5fcnVsZXMuc3BsaWNlKGRhdGEucG9zaXRpb24gfHwgMCwgMCwgZGF0YS52YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJhbnNpdGlvbic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgdmFsaWQgdHJhbnNpdGlvblxuICAgICAgICB0aGlzLmFsbC5wdXNoKGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdHJhbnNpdGlvbi5cbiAgICovXG4gIHB1YmxpYyByZXNvbHZlKFxuICAgIGRhdGE6IElUcmFuc2l0aW9uRGF0YSxcbiAgICBmaWx0ZXJzOiBJVHJhbnNpdGlvbkZpbHRlcnMgPSB7fVxuICApOiBJVHJhbnNpdGlvbk9uY2UgfCBJVHJhbnNpdGlvblBhZ2Uge1xuICAgIC8vIEZpbHRlciBvbiBcIm9uY2VcIlxuICAgIGxldCB0cmFuc2l0aW9ucyA9IGZpbHRlcnMub25jZSA/IHRoaXMub25jZSA6IHRoaXMucGFnZTtcblxuICAgIC8vIEZpbHRlciBvbiBcInNlbGZcIlxuICAgIGlmIChmaWx0ZXJzLnNlbGYpIHtcbiAgICAgIHRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnMuZmlsdGVyKHQgPT4gdC5uYW1lICYmIHQubmFtZSA9PT0gJ3NlbGYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucy5maWx0ZXIodCA9PiAhdC5uYW1lIHx8IHQubmFtZSAhPT0gJ3NlbGYnKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgbWF0Y2hpbmcgdHJhbnNpdGlvbiBpbmZvc1xuICAgIGNvbnN0IG1hdGNoaW5nID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gQWN0aXZlID0gZmlyc3Qgb2YgdmFsaWQgdHJhbnNpdGlvbnNcbiAgICAvLyBzb3J0ZWQgYnkgZGlyZWN0aW9ucyAoZnJvbS90bywgZnJvbSB8fCB0bywg4oCmKVxuICAgIGNvbnN0IGFjdGl2ZSA9IHRyYW5zaXRpb25zLmZpbmQodCA9PiB7XG4gICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgICAgY29uc3QgbWF0Y2ggPSB7fTtcblxuICAgICAgaWYgKGZpbHRlcnMuc2VsZiAmJiB0Lm5hbWUgPT09ICdzZWxmJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgcnVsZXNcbiAgICAgIHRoaXMuX3J1bGVzLnJldmVyc2UoKS5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICB2YWxpZCA9IHRoaXMuX2NoZWNrKHQsIHJ1bGUsIGRhdGEsIG1hdGNoKTtcbiAgICAgICAgICAvLyBGcm9tL3RvIGNoZWNrXG4gICAgICAgICAgaWYgKHQuZnJvbSAmJiB0LnRvKSB7XG4gICAgICAgICAgICB2YWxpZCA9XG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrKHQsIHJ1bGUsIGRhdGEsIG1hdGNoLCAnZnJvbScpICYmXG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrKHQsIHJ1bGUsIGRhdGEsIG1hdGNoLCAndG8nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQuZnJvbSAmJiAhdC50bykge1xuICAgICAgICAgICAgdmFsaWQgPSB0aGlzLl9jaGVjayh0LCBydWxlLCBkYXRhLCBtYXRjaCwgJ2Zyb20nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0LmZyb20gJiYgdC50bykge1xuICAgICAgICAgICAgdmFsaWQgPSB0aGlzLl9jaGVjayh0LCBydWxlLCBkYXRhLCBtYXRjaCwgJ3RvJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbWF0Y2hpbmcuc2V0KHQsIG1hdGNoKTtcblxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYWN0aXZlTWF0Y2ggPSBtYXRjaGluZy5nZXQoYWN0aXZlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uVHlwZSA9IFtdO1xuICAgIGlmIChmaWx0ZXJzLm9uY2UpIHtcbiAgICAgIHRyYW5zaXRpb25UeXBlLnB1c2goJ29uY2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvblR5cGUucHVzaCgncGFnZScpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5zZWxmKSB7XG4gICAgICB0cmFuc2l0aW9uVHlwZS5wdXNoKCdzZWxmJyk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZU1hdGNoKSB7XG4gICAgICAvLyBMb2cgcmVzb2x2ZWQgdHJhbnNpdGlvblxuICAgICAgY29uc3QgaW5mb3M6IGFueVtdID0gW2FjdGl2ZV07XG4gICAgICAvLyBMb2cgaWYgbWF0Y2hpbmcgY3JpdGVyaWFcbiAgICAgIE9iamVjdC5rZXlzKGFjdGl2ZU1hdGNoKS5sZW5ndGggPiAwICYmIGluZm9zLnB1c2goYWN0aXZlTWF0Y2gpO1xuXG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFxuICAgICAgICBgVHJhbnNpdGlvbiBmb3VuZCBbJHt0cmFuc2l0aW9uVHlwZS5qb2luKCcsJyl9XWAsXG4gICAgICAgIC4uLmluZm9zXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKGBObyB0cmFuc2l0aW9uIGZvdW5kIFske3RyYW5zaXRpb25UeXBlLmpvaW4oJywnKX1dYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgVXBkYXRlIHN0b3JlLlxuICAgKlxuICAgKiAtIFJlb3JkZXIgdHJhbnNpdGlvbiBieSBwcmlvcml0aWVzXG4gICAqIC0gR2V0IHdhaXQgaW5kaWNhdG9yXG4gICAqIC0gR2V0IG9uY2UgdHJhbnNpdGlvbnNcbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoKTogdm9pZCB7XG4gICAgLy8gUmVvcmRlciBieSBwcmlvcml0aWVzXG4gICAgdGhpcy5hbGwgPSB0aGlzLmFsbFxuICAgICAgLm1hcCh0ID0+IHRoaXMuX2FkZFByaW9yaXR5KHQpKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLm1hcCh0ID0+IHtcbiAgICAgICAgZGVsZXRlIHQucHJpb3JpdHk7XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9KTtcbiAgICB0aGlzLnBhZ2UgPSB0aGlzLmFsbC5maWx0ZXIoXG4gICAgICB0ID0+IHQubGVhdmUgIT09IHVuZGVmaW5lZCB8fCB0LmVudGVyICE9PSB1bmRlZmluZWRcbiAgICApIGFzIElUcmFuc2l0aW9uUGFnZVtdO1xuICAgIHRoaXMub25jZSA9IHRoaXMuYWxsLmZpbHRlcih0ID0+IHQub25jZSAhPT0gdW5kZWZpbmVkKSBhcyBJVHJhbnNpdGlvbk9uY2VbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgQ2hlY2sgaWYgdHJhbnNpdGlvbiBhcHBseS5cbiAgICpcbiAgICogQmFzZWQgb24gcnVsZSwgcGFnZSBkYXRhIGFuZCBvcHRpb25hbCBkaXJlY3Rpb246XG4gICAqXG4gICAqIDEuIHRyYW5zaXRpb24gaGFzIG5vIHJ1bGUgXCJwcm9wZXJ0eVwiOlxuICAgKiAgICAtIGFsd2F5cyByZXR1cm5zIHRydWVcbiAgICogMi4gdHJhbnNpdGlvbiBoYXMgcnVsZSBcInByb3BlcnR5XCI6XG4gICAqICAgICAtIFwic3RyaW5nc1wiIHNob3VsZCBiZSBwcmVzZW50IG9uIGJvdGggc2lkZSAodHJhbnNpdGlvbiArIHBhZ2UpIGFuZCBtYXRjaFxuICAgKiAgICAgLSBcImZ1bmN0aW9uXCIgc2hvdWxkIHJldHVybiB0cnVlXG4gICAqL1xuICBwcml2YXRlIF9jaGVjayhcbiAgICB0cmFuc2l0aW9uOiBJVHJhbnNpdGlvblBhZ2UsXG4gICAgcnVsZTogSVJ1bGUsXG4gICAgZGF0YTogSVRyYW5zaXRpb25EYXRhLFxuICAgIG1hdGNoOiBhbnksXG4gICAgZGlyZWN0aW9uPzogJ2Zyb20nIHwgJ3RvJ1xuICApOiBib29sZWFuIHtcbiAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgbGV0IGhhc01hdGNoID0gZmFsc2U7XG4gICAgY29uc3QgdCA9IHRyYW5zaXRpb247XG4gICAgY29uc3QgeyBuYW1lLCB0eXBlIH0gPSBydWxlO1xuICAgIGNvbnN0IHN0clJ1bGUgPSBuYW1lIGFzIElSdWxlc1snc3RyaW5ncyddO1xuICAgIGNvbnN0IG9ialJ1bGUgPSBuYW1lIGFzIElSdWxlc1snb2JqZWN0J107XG4gICAgY29uc3QgZm5OYW1lID0gbmFtZSBhcyBJUnVsZXNbJ2Z1bmN0aW9uJ107XG4gICAgY29uc3QgYmFzZSA9IGRpcmVjdGlvbiA/IHRbZGlyZWN0aW9uXSA6IHQ7IC8vID0gdCB8fCB0LmZyb20gfHwgdC50b1xuICAgIGNvbnN0IHBhZ2UgPSBkaXJlY3Rpb24gPT09ICd0bycgPyBkYXRhLm5leHQgOiBkYXRhLmN1cnJlbnQ7IC8vID0gY3VycmVudCB8fCBuZXh0XG4gICAgY29uc3QgZXhpc3QgPSBkaXJlY3Rpb24gPyBiYXNlICYmIGJhc2VbbmFtZV0gOiBiYXNlW25hbWVdO1xuXG4gICAgLy8gSWYgdHJhbnNpdGlvbiBydWxlIGV4aXN0c1xuICAgIGlmIChleGlzdCkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZ3MnOlxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgLy8gQXJyYXkgc3VwcG9ydFxuICAgICAgICAgIGNvbnN0IG5hbWVzOiBzdHJpbmdbXSA9IEFycmF5LmlzQXJyYXkoYmFzZVtzdHJSdWxlXSlcbiAgICAgICAgICAgID8gKGJhc2Vbc3RyUnVsZV0gYXMgc3RyaW5nW10pXG4gICAgICAgICAgICA6IFtiYXNlW3N0clJ1bGVdIGFzIHN0cmluZ107XG5cbiAgICAgICAgICAvLyBGb3IgbWF0Y2hpbmcsIHByb3Agc2hvdWxkIGJlIHByZXNlbnQgb24gYm90aCBzaWRlcyBhbmQgbWF0Y2hcbiAgICAgICAgICBpZiAocGFnZVtzdHJSdWxlXSAmJiBuYW1lcy5pbmRleE9mKHBhZ2Vbc3RyUnVsZV0pICE9PSAtMSkge1xuICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0cmFuc2l0aW9uIHByb3AgaXMgZGlmZmVyZW50IGZyb20gY3VycmVudCwgbm90IHZhbGlkXG4gICAgICAgICAgaWYgKG5hbWVzLmluZGV4T2YocGFnZVtzdHJSdWxlXSkgPT09IC0xKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgIC8vIEFycmF5IHN1cHBvcnRcbiAgICAgICAgICBjb25zdCBuYW1lczogc3RyaW5nW10gPSBBcnJheS5pc0FycmF5KGJhc2Vbb2JqUnVsZV0pXG4gICAgICAgICAgICA/IChiYXNlW29ialJ1bGVdIGFzIHN0cmluZ1tdKVxuICAgICAgICAgICAgOiBbYmFzZVtvYmpSdWxlXSBhcyBzdHJpbmddO1xuXG4gICAgICAgICAgLy8gRm9yIG1hdGNoaW5nLCBwcm9wIHNob3VsZCBiZSBwcmVzZW50IG9uIGJvdGggc2lkZXMgYW5kIG1hdGNoXG4gICAgICAgICAgaWYgKHBhZ2Vbb2JqUnVsZV0pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcGFnZVtvYmpSdWxlXS5uYW1lICYmXG4gICAgICAgICAgICAgIG5hbWVzLmluZGV4T2YocGFnZVtvYmpSdWxlXS5uYW1lKSAhPT0gLTFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBoYXNNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0cmFuc2l0aW9uIHByb3AgaXMgZGlmZmVyZW50IGZyb20gY3VycmVudCwgbm90IHZhbGlkXG4gICAgICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihwYWdlW29ialJ1bGVdLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgaWYgKGJhc2VbZm5OYW1lXShkYXRhKSkge1xuICAgICAgICAgICAgaGFzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTWF0Y2gpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgIG1hdGNoW2RpcmVjdGlvbl0gPSBtYXRjaFtkaXJlY3Rpb25dIHx8IHt9O1xuICAgICAgICAgIG1hdGNoW2RpcmVjdGlvbl1bbmFtZV0gPSB0W2RpcmVjdGlvbl1bbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hbbmFtZV0gPSB0W25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogIyMjIENhbGN1bGF0ZSB0cmFuc2l0aW9uIHByaW9yaXR5LlxuICAgKlxuICAgKiBCYXNlZCBvbjpcbiAgICpcbiAgICogLSBydWxlIFwicG9zaXRpb25cIiAoaW5kZXgpIGdpdmUgdGVucywgaHVuZHJlZHMsIHRob3VzYW5kcywg4oCmXG4gICAqIC0gZnJvbS90byBwcm9wZXJ0aWVzIGdpdmUgdW5pdHMgKDAsIDEgb3IgMilcbiAgICovXG4gIHByaXZhdGUgX2NhbGN1bGF0ZVByaW9yaXR5KFxuICAgIHQ6IElUcmFuc2l0aW9uUGFnZSxcbiAgICBydWxlTmFtZTogUnVsZU5hbWUsXG4gICAgcnVsZUluZGV4OiBudW1iZXJcbiAgKTogbnVtYmVyIHtcbiAgICBsZXQgcHJpb3JpdHkgPSAwO1xuXG4gICAgaWYgKFxuICAgICAgdFtydWxlTmFtZV0gfHxcbiAgICAgICh0LmZyb20gJiYgdC5mcm9tW3J1bGVOYW1lXSkgfHxcbiAgICAgICh0LnRvICYmIHQudG9bcnVsZU5hbWVdKVxuICAgICkge1xuICAgICAgcHJpb3JpdHkgKz0gTWF0aC5wb3coMTAsIHJ1bGVJbmRleCk7XG5cbiAgICAgIGlmICh0LmZyb20gJiYgdC5mcm9tW3J1bGVOYW1lXSkge1xuICAgICAgICBwcmlvcml0eSArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHQudG8gJiYgdC50b1tydWxlTmFtZV0pIHtcbiAgICAgICAgcHJpb3JpdHkgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJpb3JpdHk7XG4gIH1cblxuICBwcml2YXRlIF9hZGRQcmlvcml0eSh0OiBJVHJhbnNpdGlvblBhZ2UpOiBJVHJhbnNpdGlvblBhZ2Uge1xuICAgIHQucHJpb3JpdHkgPSAwO1xuICAgIGxldCBwcmlvcml0eSA9IDA7XG5cbiAgICB0aGlzLl9ydWxlcy5mb3JFYWNoKChydWxlLCBpKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUgfSA9IHJ1bGU7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKyAxO1xuXG4gICAgICBwcmlvcml0eSArPSB0aGlzLl9jYWxjdWxhdGVQcmlvcml0eSh0LCBuYW1lLCBpbmRleCk7XG4gICAgfSk7XG5cbiAgICB0LnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cbiAgICByZXR1cm4gdDtcbiAgfVxufVxuIiwiLyoqXG4gKiBAYmFyYmEvY29yZS9tb2R1bGVzL3RyYW5zaXRpb25zXG4gKiA8YnI+PGJyPlxuICogIyMgVHJhbnNpdGlvbnMgbWFuYWdlci5cbiAqXG4gKiAtIEhhbmRsZSBob29rcyBhbmQgdHJhbnNpdGlvbiBsaWZlY3ljbGVcbiAqXG4gKiBAbW9kdWxlIGNvcmUvbW9kdWxlcy90cmFuc2l0aW9uc1xuICogQHByZWZlcnJlZFxuICovXG5cbi8qKiovXG5cbi8vIERlZmluaXRpb25zXG5pbXBvcnQge1xuICBIb29rc1RyYW5zaXRpb24sXG4gIEhvb2tzVHJhbnNpdGlvbk1hcCxcbiAgSVRyYW5zaXRpb25EYXRhLFxuICBJVHJhbnNpdGlvbkZpbHRlcnMsXG4gIElUcmFuc2l0aW9uT25jZSxcbiAgSVRyYW5zaXRpb25QYWdlLFxuICBXcmFwcGVyLFxufSBmcm9tICcuLi9kZWZzJztcbi8vIEhvb2tzXG5pbXBvcnQgeyBob29rcyB9IGZyb20gJy4uL2hvb2tzJztcbi8vIFV0aWxzXG5pbXBvcnQgeyBkb20sIGhlbHBlcnMsIHJ1bkFzeW5jIH0gZnJvbSAnLi4vdXRpbHMnO1xuLy8gTW9kdWxlc1xuaW1wb3J0IHsgQmFyYmFFcnJvciB9IGZyb20gJy4vRXJyb3InO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi9Mb2dnZXInO1xuaW1wb3J0IHsgU3RvcmUgfSBmcm9tICcuL1N0b3JlJztcblxuZXhwb3J0IGNsYXNzIFRyYW5zaXRpb25zIHtcbiAgcHVibGljIGxvZ2dlcjogTG9nZ2VyID0gbmV3IExvZ2dlcignQGJhcmJhL2NvcmUnKTtcbiAgcHVibGljIHN0b3JlOiBTdG9yZTtcbiAgcHJpdmF0ZSBfcnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHRyYW5zaXRpb25zOiBJVHJhbnNpdGlvblBhZ2VbXSA9IFtdKSB7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBTdG9yZSh0cmFuc2l0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlc29sdmVkIHRyYW5zaXRpb25cbiAgICpcbiAgICogLSBiYXNlZCBvbiBkYXRhXG4gICAqL1xuICBwdWJsaWMgZ2V0KFxuICAgIGRhdGE6IElUcmFuc2l0aW9uRGF0YSxcbiAgICBmaWx0ZXJzPzogSVRyYW5zaXRpb25GaWx0ZXJzXG4gICk6IElUcmFuc2l0aW9uT25jZSB8IElUcmFuc2l0aW9uUGFnZSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUucmVzb2x2ZShkYXRhLCBmaWx0ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gcnVubmluZyBzdGF0dXMuXG4gICAqL1xuICBnZXQgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9ydW5uaW5nO1xuICB9XG4gIHNldCBpc1J1bm5pbmcoc3RhdHVzOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IHN0YXR1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgcmVnaXN0ZXJlZCBvbmNlIHRyYW5zaXRpb24ocykuXG4gICAqL1xuICBnZXQgaGFzT25jZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5vbmNlLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHJlZ2lzdGVyZWQgc2VsZiB0cmFuc2l0aW9uLlxuICAgKi9cbiAgZ2V0IGhhc1NlbGYoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuYWxsLnNvbWUodCA9PiB0Lm5hbWUgPT09ICdzZWxmJyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIFdhaXQgaW5kaWNhdG9yLlxuICAgKlxuICAgKiBUZWxscyBCYXJiYSB0byBnZXQgbmV4dCBwYWdlIGRhdGE8YnI+XG4gICAqIGJlZm9yZSBzdGFydGluZyB0aGUgcmVzb2x1dGlvbjxicj5cbiAgICogYmVjYXVzZSBzb21lIHJlZ2lzdGVyZWQgdHJhbnNpdGlvbnMgbmVlZDxicj5cbiAgICogbmV4dCBwYWdlIGRhdGEgdG8gYmUgcmVzb2x2ZWQgKGVnOiBgc3luYzogdHJ1ZWAsIGB0bzogeyBuYW1lc3BhY2UgfWAsIOKApilcbiAgICovXG4gIGdldCBzaG91bGRXYWl0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmFsbC5zb21lKHQgPT4gKHQudG8gJiYgIXQudG8ucm91dGUpIHx8IHQuc3luYyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIERvIFwib25jZVwiIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEhvb2tzOiBzZWUgW1tIb29rc09uY2VdXS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkb09uY2Uoe1xuICAgIGRhdGEsXG4gICAgdHJhbnNpdGlvbixcbiAgfToge1xuICAgIGRhdGE6IElUcmFuc2l0aW9uRGF0YTtcbiAgICB0cmFuc2l0aW9uOiBJVHJhbnNpdGlvbk9uY2U7XG4gIH0pIHtcbiAgICBjb25zdCB0ID0gdHJhbnNpdGlvbiB8fCB7fTtcbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9kb0FzeW5jSG9vaygnYmVmb3JlT25jZScsIGRhdGEsIHQpO1xuICAgICAgYXdhaXQgdGhpcy5vbmNlKGRhdGEsIHQpO1xuICAgICAgYXdhaXQgdGhpcy5fZG9Bc3luY0hvb2soJ2FmdGVyT25jZScsIGRhdGEsIHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdUcmFuc2l0aW9uIGVycm9yIFtiZWZvcmUvYWZ0ZXIvb25jZV0nKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogIyMjIERvIFwicGFnZVwiIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEhvb2tzOiBzZWUgW1tIb29rc1BhZ2VdXS5cbiAgICpcbiAgICogYHN5bmM6IGZhbHNlYCAoZGVmYXVsdCkgb3JkZXI6XG4gICAqXG4gICAqIDEuIGJlZm9yZVxuICAgKiAyLiBiZWZvcmVMZWF2ZVxuICAgKiAzLiBsZWF2ZVxuICAgKiA0LiBhZnRlckxlYXZlXG4gICAqIDUuIGJlZm9yZUVudGVyXG4gICAqIDYuIGVudGVyXG4gICAqIDcuIGFmdGVyRW50ZXJcbiAgICogOC4gYWZ0ZXJcbiAgICpcbiAgICogYHN5bmM6IHRydWVgIG9yZGVyOlxuICAgKlxuICAgKiAxLiBiZWZvcmVcbiAgICogMi4gYmVmb3JlTGVhdmVcbiAgICogMy4gYmVmb3JlRW50ZXJcbiAgICogNC4gbGVhdmUgJiBlbnRlclxuICAgKiA1LiBhZnRlckxlYXZlXG4gICAqIDYuIGFmdGVyRW50ZXJcbiAgICogNy4gYWZ0ZXJcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkb1BhZ2Uoe1xuICAgIGRhdGEsXG4gICAgdHJhbnNpdGlvbixcbiAgICBwYWdlLFxuICAgIHdyYXBwZXIsXG4gIH06IHtcbiAgICBkYXRhOiBJVHJhbnNpdGlvbkRhdGE7XG4gICAgdHJhbnNpdGlvbjogSVRyYW5zaXRpb25QYWdlO1xuICAgIHBhZ2U6IFByb21pc2U8c3RyaW5nIHwgdm9pZD47XG4gICAgd3JhcHBlcjogV3JhcHBlcjtcbiAgfSkge1xuICAgIGNvbnN0IHQgPSB0cmFuc2l0aW9uIHx8IHt9O1xuICAgIGNvbnN0IHN5bmMgPSB0LnN5bmMgPT09IHRydWUgfHwgZmFsc2U7XG5cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBzeW5jIG1vZGUsIHdhaXQgZm9yIG5leHQgY29udGVudFxuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgYXdhaXQgaGVscGVycy51cGRhdGUocGFnZSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuX2RvQXN5bmNIb29rKCdiZWZvcmUnLCBkYXRhLCB0KTtcblxuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFkZChkYXRhLCB3cmFwcGVyKTtcbiAgICAgICAgICAvLyBCZWZvcmUgYWN0aW9uc1xuICAgICAgICAgIGF3YWl0IHRoaXMuX2RvQXN5bmNIb29rKCdiZWZvcmVMZWF2ZScsIGRhdGEsIHQpO1xuICAgICAgICAgIGF3YWl0IHRoaXMuX2RvQXN5bmNIb29rKCdiZWZvcmVFbnRlcicsIGRhdGEsIHQpO1xuXG4gICAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmxlYXZlKGRhdGEsIHQpLCB0aGlzLmVudGVyKGRhdGEsIHQpXSk7XG5cbiAgICAgICAgICAvLyBBZnRlciBhY3Rpb25zXG4gICAgICAgICAgYXdhaXQgdGhpcy5fZG9Bc3luY0hvb2soJ2FmdGVyTGVhdmUnLCBkYXRhLCB0KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9kb0FzeW5jSG9vaygnYWZ0ZXJFbnRlcicsIGRhdGEsIHQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLmRlYnVnKCdUcmFuc2l0aW9uIGVycm9yIFtzeW5jXScpO1xuICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmFyYmFFcnJvcihlcnJvciwgJ1RyYW5zaXRpb24gZXJyb3IgW3N5bmNdJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbGVhdmVSZXN1bHQ6IGFueSA9IGZhbHNlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTGVhdmVcbiAgICAgICAgICBhd2FpdCB0aGlzLl9kb0FzeW5jSG9vaygnYmVmb3JlTGVhdmUnLCBkYXRhLCB0KTtcblxuICAgICAgICAgIGxlYXZlUmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5sZWF2ZShkYXRhLCB0KSxcbiAgICAgICAgICAgIGhlbHBlcnMudXBkYXRlKHBhZ2UsIGRhdGEpLFxuICAgICAgICAgIF0pLnRoZW4odmFsdWVzID0+IHZhbHVlc1swXSk7XG5cbiAgICAgICAgICBhd2FpdCB0aGlzLl9kb0FzeW5jSG9vaygnYWZ0ZXJMZWF2ZScsIGRhdGEsIHQpO1xuXG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgaGVyZSBcInZhbGlkXCIgcGFnZSByZXN1bHRcbiAgICAgICAgICAvLyBiZWZvcmUgZ29pbmcgZnVydGhlclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLmRlYnVnKCdUcmFuc2l0aW9uIGVycm9yIFtiZWZvcmUvYWZ0ZXIvbGVhdmVdJyk7XG4gICAgICAgICAgLy8gdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCYXJiYUVycm9yKFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgJ1RyYW5zaXRpb24gZXJyb3IgW2JlZm9yZS9hZnRlci9sZWF2ZV0nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gRW50ZXJcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChsZWF2ZVJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRkKGRhdGEsIHdyYXBwZXIpO1xuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9kb0FzeW5jSG9vaygnYmVmb3JlRW50ZXInLCBkYXRhLCB0KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZW50ZXIoZGF0YSwgdCwgbGVhdmVSZXN1bHQpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZG9Bc3luY0hvb2soJ2FmdGVyRW50ZXInLCBkYXRhLCB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gdGhpcy5sb2dnZXIuZGVidWcoJ1RyYW5zaXRpb24gZXJyb3IgW2JlZm9yZS9hZnRlci9lbnRlcl0nKTtcbiAgICAgICAgICAvLyB0aGlzLmxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJhcmJhRXJyb3IoXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAnVHJhbnNpdGlvbiBlcnJvciBbYmVmb3JlL2FmdGVyL2VudGVyXSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBjdXJyZW50IGNvbnRhaWVuclxuICAgICAgYXdhaXQgdGhpcy5yZW1vdmUoZGF0YSk7XG5cbiAgICAgIGF3YWl0IHRoaXMuX2RvQXN5bmNIb29rKCdhZnRlcicsIGRhdGEsIHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIElmIFwiY3VzdG9tL3NwZWNpZmljXCIgYmFyYmEgZXJyb3IuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGVycm9yLm5hbWUgJiYgZXJyb3IubmFtZSA9PT0gJ0JhcmJhRXJyb3InKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGVycm9yLmxhYmVsKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IuZXJyb3IpO1xuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnVHJhbnNpdGlvbiBlcnJvciBbcGFnZV0nKTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yKTtcblxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uY2UgaG9vayArIGFzeW5jIFwib25jZVwiIHRyYW5zaXRpb24uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgb25jZShkYXRhOiBJVHJhbnNpdGlvbkRhdGEsIHQ6IElUcmFuc2l0aW9uT25jZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IGhvb2tzLmRvKCdvbmNlJywgZGF0YSwgdCk7XG5cbiAgICByZXR1cm4gdC5vbmNlID8gcnVuQXN5bmModC5vbmNlLCB0KShkYXRhKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExlYXZlIGhvb2sgKyBhc3luYyBcImxlYXZlXCIgdHJhbnNpdGlvbi5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsZWF2ZShkYXRhOiBJVHJhbnNpdGlvbkRhdGEsIHQ6IElUcmFuc2l0aW9uUGFnZSk6IFByb21pc2U8YW55PiB7XG4gICAgYXdhaXQgaG9va3MuZG8oJ2xlYXZlJywgZGF0YSwgdCk7XG5cbiAgICByZXR1cm4gdC5sZWF2ZSA/IHJ1bkFzeW5jKHQubGVhdmUsIHQpKGRhdGEpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogRW50ZXIgaG9vayArIGFzeW5jIFwiZW50ZXJcIiB0cmFuc2l0aW9uLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGVudGVyKFxuICAgIGRhdGE6IElUcmFuc2l0aW9uRGF0YSxcbiAgICB0OiBJVHJhbnNpdGlvblBhZ2UsXG4gICAgbGVhdmVSZXN1bHQ/OiBhbnlcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgaG9va3MuZG8oJ2VudGVyJywgZGF0YSwgdCk7XG5cbiAgICByZXR1cm4gdC5lbnRlclxuICAgICAgPyBydW5Bc3luYyh0LmVudGVyLCB0KShkYXRhLCBsZWF2ZVJlc3VsdClcbiAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG5leHQgY29udGFpbmVyLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGFkZChkYXRhOiBJVHJhbnNpdGlvbkRhdGEsIHdyYXBwZXI6IFdyYXBwZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBkb20uYWRkQ29udGFpbmVyKGRhdGEubmV4dC5jb250YWluZXIsIHdyYXBwZXIpO1xuICAgIGhvb2tzLmRvKCduZXh0QWRkZWQnLCBkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgY3VycmVudCBjb250YWluZXIuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVtb3ZlKGRhdGE6IElUcmFuc2l0aW9uRGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGRvbS5yZW1vdmVDb250YWluZXIoZGF0YS5jdXJyZW50LmNvbnRhaW5lcik7XG4gICAgaG9va3MuZG8oJ2N1cnJlbnRSZW1vdmVkJywgZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIF9pc1RyYW5zaXRpb25FcnJvcihlcnJvcjogYW55KSB7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgIC8vIEVycm9ycyBmcm9tIHJlcXVlc3RcbiAgICAgIHJldHVybiAhL1RpbWVvdXQgZXJyb3J8RmV0Y2ggZXJyb3IvLnRlc3QoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yLnN0YXR1cykge1xuICAgICAgLy8gRXJyb3JzIGZyb20gcmVxdWVzdFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERvIGhvb2tzICsgYXN5bmMgdHJhbnNpdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZG9Bc3luY0hvb2soXG4gICAgaG9vazogSG9va3NUcmFuc2l0aW9uLFxuICAgIGRhdGE6IElUcmFuc2l0aW9uRGF0YSxcbiAgICB0OiBIb29rc1RyYW5zaXRpb25NYXBcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgaG9va3MuZG8oaG9vaywgZGF0YSwgdCk7XG5cbiAgICByZXR1cm4gdFtob29rXSA/IHJ1bkFzeW5jKHRbaG9va10sIHQpKGRhdGEpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGJhcmJhL2NvcmUvbW9kdWxlcy92aWV3c1xuICogPGJyPjxicj5cbiAqICMjIFZpZXdzIG1hbmFnZXIuXG4gKlxuICogQG1vZHVsZSBjb3JlL21vZHVsZXMvdmlld3NcbiAqIEBwcmVmZXJyZWRcbiAqL1xuXG4vKioqL1xuXG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSG9va3NWaWV3LCBJVmlldywgSVZpZXdEYXRhIH0gZnJvbSAnLi4vZGVmcyc7XG4vLyBIb29rc1xuaW1wb3J0IHsgaG9va3MgfSBmcm9tICcuLi9ob29rcyc7XG4vLyBVdGlsc1xuaW1wb3J0IHsgcnVuQXN5bmMgfSBmcm9tICcuLi91dGlscyc7XG4vLyBUeXBlc1xudHlwZSBIb29rID0gKGRhdGE6IElWaWV3RGF0YSkgPT4gUHJvbWlzZTx2b2lkPjtcblxuZXhwb3J0IGNsYXNzIFZpZXdzIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBob29rIG5hbWVzIGZvciB2aWV3cy5cbiAgICovXG4gIHB1YmxpYyBuYW1lczogSG9va3NWaWV3W10gPSBbXG4gICAgJ2JlZm9yZUxlYXZlJyxcbiAgICAnYWZ0ZXJMZWF2ZScsXG4gICAgJ2JlZm9yZUVudGVyJyxcbiAgICAnYWZ0ZXJFbnRlcicsXG4gIF07XG4gIC8qKlxuICAgKiBSZWdpc3RlcmVkIHZpZXdzIGJ5IG5hbWVzcGFjZS5cbiAgICovXG4gIHB1YmxpYyBieU5hbWVzcGFjZTogTWFwPHN0cmluZywgSVZpZXc+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBJbml0IHZpZXdzLlxuICAgKi9cbiAgY29uc3RydWN0b3Iodmlld3M6IElWaWV3W10pIHtcbiAgICBpZiAodmlld3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIGNoZWNrXG4gICAgLy8gZm9yIHZhbGlkIHZpZXdzPyBjcml0ZXJpYT8gKG5hbWVzcGFjZSBwcm9wZXJ0eSwgc3RyaW5nID8pXG4gICAgLy8gb3IgZHVwbGljYXRlXG4gICAgdmlld3MuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgIHRoaXMuYnlOYW1lc3BhY2Uuc2V0KHZpZXcubmFtZXNwYWNlLCB2aWV3KTtcbiAgICB9KTtcblxuICAgIHRoaXMubmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGhvb2tzW25hbWVdKHRoaXMuX2NyZWF0ZUhvb2sobmFtZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgaG9vayBtZXRob2QuXG4gICAqXG4gICAqIC0gZ2V0IHZpZXcgYmFzZWQgb24gbmFtZXNwYWNlXG4gICAqIC0gZXhlY3V0ZSBjYWxsYmFjayB3aXRoIHRyYW5zaXRpb24gZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBfY3JlYXRlSG9vayhuYW1lOiBIb29rc1ZpZXcpOiBIb29rIHtcbiAgICByZXR1cm4gZGF0YSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWVzcGFjZSB9ID0gbmFtZS5tYXRjaCgvZW50ZXIvaSkgPyBkYXRhLm5leHQgOiBkYXRhLmN1cnJlbnQ7XG4gICAgICBjb25zdCB2aWV3ID0gdGhpcy5ieU5hbWVzcGFjZS5nZXQobmFtZXNwYWNlKTtcblxuICAgICAgLy8gVE9ETzogbWFuYWdlIHNlbGbigKZcbiAgICAgIC8vIGlmICh2aWV3ICYmIGRhdGEudHJpZ2dlciAhPT0gJ3NlbGYnKSB7XG4gICAgICBpZiAodmlldyAmJiB2aWV3W25hbWVdKSB7XG4gICAgICAgIHJldHVybiBydW5Bc3luYyh2aWV3W25hbWVdLCB2aWV3KShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gIH1cbn1cbiIsIi8vIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgcG9seWZpbGxcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXMjUG9seWZpbGxcbmlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID1cbiAgICAoRWxlbWVudCBhcyBhbnkpLnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuLy8gRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdCNQb2x5ZmlsbFxuaWYgKCFFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0KSB7XG4gIEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbiBjbG9zZXN0KHM6IHN0cmluZykge1xuICAgIGxldCBlbCA9IHRoaXM7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoZWwubWF0Y2hlcyhzKSkge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG5cbiAgICAgIGVsID0gKGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZSkgYXMgRWxlbWVudDtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBjb3JlL3NjaGVtYXNcbiAqL1xuXG4vLyBEZWZpbml0aW9uc1xuaW1wb3J0IHsgSVNjaGVtYVBhZ2UgfSBmcm9tICcuLi9kZWZzJztcblxuLyoqXG4gKiBTZWUgW1tJU2NoZW1hUGFnZV1dXG4gKi9cbmV4cG9ydCBjb25zdCBzY2hlbWFQYWdlOiBJU2NoZW1hUGFnZSA9IHtcbiAgY29udGFpbmVyOiBudWxsLFxuICBodG1sOiAnJyxcbiAgbmFtZXNwYWNlOiAnJyxcbiAgdXJsOiB7XG4gICAgaGFzaDogJycsXG4gICAgaHJlZjogJycsXG4gICAgcGF0aDogJycsXG4gICAgcG9ydDogbnVsbCxcbiAgICBxdWVyeToge30sXG4gIH0sXG59O1xuIiwiLyoqXG4gKiBAYmFyYmEvY29yZVxuICogPGJyPjxicj5cbiAqICMjIEJhcmJhIGNvcmUgb2JqZWN0XG4gKlxuICogTWFpbiBtZXRob2RzOlxuICpcbiAqIC0gYC5pbml0KClgIGZvciBpbml0aWFsaXphdGlvbiB3aXRoIG9wdGlvbnNcbiAqIC0gYC51c2UoKWAgZm9yIHBsdWdpbnNcbiAqXG4gKiBAbW9kdWxlIGNvcmVcbiAqL1xuXG4vKioqL1xuXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcbi8vIERlZmluaXRpb25zXG5pbXBvcnQge1xuICBJQmFyYmFPcHRpb25zLFxuICBJQmFyYmFQbHVnaW4sXG4gIElnbm9yZU9wdGlvbixcbiAgSVNjaGVtYVBhZ2UsXG4gIElUcmFuc2l0aW9uRGF0YSxcbiAgSVRyYW5zaXRpb25PbmNlLFxuICBJVHJhbnNpdGlvblBhZ2UsXG4gIExpbmssXG4gIExpbmtFdmVudCxcbiAgUmVxdWVzdEN1c3RvbUVycm9yLFxuICBSZXF1ZXN0RXJyb3JPclJlc3BvbnNlLFxuICBTY2hlbWFBdHRyaWJ1dGVWYWx1ZXMsXG4gIFRyaWdnZXIsXG4gIFdyYXBwZXIsXG59IGZyb20gJy4vZGVmcyc7XG4vLyBIb29rc1xuaW1wb3J0IHsgaG9va3MgfSBmcm9tICcuL2hvb2tzJztcbi8vIE1vZHVsZXNcbmltcG9ydCB7IENhY2hlIH0gZnJvbSAnLi9tb2R1bGVzL0NhY2hlJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4vbW9kdWxlcy9Mb2dnZXInO1xuaW1wb3J0IHsgUHJldmVudCB9IGZyb20gJy4vbW9kdWxlcy9QcmV2ZW50JztcbmltcG9ydCB7IFRyYW5zaXRpb25zIH0gZnJvbSAnLi9tb2R1bGVzL1RyYW5zaXRpb25zJztcbmltcG9ydCB7IFZpZXdzIH0gZnJvbSAnLi9tb2R1bGVzL1ZpZXdzJztcbi8vIFBvbHlmaWxsc1xuaW1wb3J0ICcuL3BvbHlmaWxscyc7XG4vLyBTY2hlbWFzXG5pbXBvcnQgeyBzY2hlbWFBdHRyaWJ1dGUgfSBmcm9tICcuL3NjaGVtYXMvYXR0cmlidXRlJztcbmltcG9ydCB7IHNjaGVtYVBhZ2UgfSBmcm9tICcuL3NjaGVtYXMvcGFnZSc7XG4vLyBVdGlsc1xuaW1wb3J0IHsgZG9tLCBoZWxwZXJzLCBoaXN0b3J5LCByZXF1ZXN0LCB1cmwgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIENvcmUge1xuICAvKipcbiAgICogVmVyc2lvbi5cbiAgICovXG4gIHB1YmxpYyB2ZXJzaW9uOiBzdHJpbmcgPSB2ZXJzaW9uO1xuICAvKipcbiAgICogU2NoZW1hcy5cbiAgICovXG4gIHB1YmxpYyBzY2hlbWFQYWdlOiBJU2NoZW1hUGFnZSA9IHNjaGVtYVBhZ2U7XG4gIC8qKlxuICAgKiBMb2dnZXIgY2xhc3MsIGFsbG93cyBwbHVnaW5zIHRvIGNyZWF0ZSBMb2dnZXIuXG4gICAqL1xuICBwdWJsaWMgTG9nZ2VyOiB0eXBlb2YgTG9nZ2VyID0gTG9nZ2VyO1xuICAvKipcbiAgICogQmFyYmEgbG9nZ2VyLlxuICAgKi9cbiAgcHVibGljIGxvZ2dlcjogTG9nZ2VyID0gbmV3IExvZ2dlcignQGJhcmJhL2NvcmUnKTtcbiAgLyoqXG4gICAqIFBsdWdpbnMuXG4gICAqL1xuICBwdWJsaWMgcGx1Z2luczogQXJyYXk8SUJhcmJhUGx1Z2luPGFueT4+ID0gW107XG4gIC8qKlxuICAgKiBPcHRpb25zXG4gICAqL1xuICBwdWJsaWMgdGltZW91dDogbnVtYmVyO1xuICBwdWJsaWMgY2FjaGVJZ25vcmU6IElnbm9yZU9wdGlvbjtcbiAgcHVibGljIHByZWZldGNoSWdub3JlOiBJZ25vcmVPcHRpb247XG4gIHB1YmxpYyBwcmV2ZW50UnVubmluZzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEhvb2tzXG4gICAqL1xuICBwdWJsaWMgaG9va3MgPSBob29rcztcbiAgLyoqXG4gICAqIE1vZHVsZXMuXG4gICAqL1xuICAvLyBwdWJsaWMgaGlzdG9yeTogSGlzdG9yeTtcbiAgcHVibGljIGNhY2hlOiBDYWNoZTtcbiAgcHVibGljIHByZXZlbnQ6IFByZXZlbnQ7XG4gIHB1YmxpYyB0cmFuc2l0aW9uczogVHJhbnNpdGlvbnM7XG4gIHB1YmxpYyB2aWV3czogVmlld3M7XG4gIC8qKlxuICAgKiBVdGlscy5cbiAgICovXG4gIHB1YmxpYyBkb20gPSBkb207XG4gIHB1YmxpYyBoZWxwZXJzID0gaGVscGVycztcbiAgcHVibGljIGhpc3RvcnkgPSBoaXN0b3J5O1xuICBwdWJsaWMgcmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHB1YmxpYyB1cmwgPSB1cmw7XG5cbiAgcHJpdmF0ZSBfZGF0YTogSVRyYW5zaXRpb25EYXRhO1xuICBwcml2YXRlIF9yZXF1ZXN0Q3VzdG9tRXJyb3I6IFJlcXVlc3RDdXN0b21FcnJvcjtcbiAgcHJpdmF0ZSBfd3JhcHBlcjogV3JhcHBlcjtcblxuICAvKipcbiAgICogIyMjIEluaXQgcGx1Z2luIHdpdGggb3B0aW9ucy5cbiAgICpcbiAgICogU2VlIFtbSUJhcmJhUGx1Z2luXV0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIHB1YmxpYyB1c2U8VD4ocGx1Z2luOiBJQmFyYmFQbHVnaW48VD4sIG9wdGlvbnM/OiBUKTogdm9pZCB7XG4gICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IHRoaXMucGx1Z2lucztcblxuICAgIC8vIFBsdWdpbiBpbnN0YWxsYXRpb25cbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgUGx1Z2luIFske3BsdWdpbi5uYW1lfV0gYWxyZWFkeSBpbnN0YWxsZWQuYCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBQbHVnaW4gWyR7cGx1Z2luLm5hbWV9XSBoYXMgbm8gXCJpbnN0YWxsXCIgbWV0aG9kLmApO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGx1Z2luLmluc3RhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIEluaXQgYmFyYmEgd2l0aCBvcHRpb25zLlxuICAgKlxuICAgKiBTZWUgW1tJQmFyYmFPcHRpb25zXV0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogRGVmYXVsdCB2YWx1ZXMgYXJlOlxuICAgKlxuICAgKiAtIHRyYW5zaXRpb25zOiBgW11gXG4gICAqIC0gdmlld3M6IGBbXWBcbiAgICogLSBzY2hlbWE6IFtbU2NoZW1hQXR0cmlidXRlXV1cbiAgICogLSB0aW1lb3V0OiBgMmUzYFxuICAgKiAtIGNhY2hlSWdub3JlOiBgZmFsc2VgXG4gICAqIC0gcHJlZmV0Y2hJZ25vcmU6IGBmYWxzZWBcbiAgICogLSBwcmV2ZW50UnVubmluZzogYGZhbHNlYFxuICAgKiAtIHByZXZlbnQ6IGBudWxsYCxcbiAgICogLSBkZWJ1ZzogYGZhbHNlYFxuICAgKiAtIGxvZ0xldmVsOiBgJ2RlYnVnJ2BcbiAgICovXG4gIHB1YmxpYyBpbml0KFxuICAgIC8qKiBAaWdub3JlICovIHtcbiAgICAgIHRyYW5zaXRpb25zID0gW10sXG4gICAgICB2aWV3cyA9IFtdLFxuICAgICAgc2NoZW1hID0gc2NoZW1hQXR0cmlidXRlLFxuICAgICAgcmVxdWVzdEVycm9yLFxuICAgICAgdGltZW91dCA9IDJlMyxcbiAgICAgIGNhY2hlSWdub3JlID0gZmFsc2UsXG4gICAgICBwcmVmZXRjaElnbm9yZSA9IGZhbHNlLFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHByZXZlbnRSdW5uaW5nID0gZmFsc2UsXG4gICAgICBwcmV2ZW50OiBwcmV2ZW50Q3VzdG9tID0gbnVsbCxcbiAgICAgIGRlYnVnID0gZmFsc2UsXG4gICAgICBsb2dMZXZlbCA9ICdvZmYnLFxuICAgIH06IElCYXJiYU9wdGlvbnMgPSB7fVxuICApIHtcbiAgICAvLyAwLiBTZXQgbG9nZ2VyIGxldmVsIGFuZCBwcmludCB2ZXJzaW9uXG4gICAgTG9nZ2VyLnNldExldmVsKGRlYnVnID09PSB0cnVlID8gJ2RlYnVnJyA6IGxvZ0xldmVsKTtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKHRoaXMudmVyc2lvbik7XG5cbiAgICAvLyAxLiBNYW5hZ2Ugb3B0aW9uc1xuICAgIE9iamVjdC5rZXlzKHNjaGVtYSkuZm9yRWFjaChrID0+IHtcbiAgICAgIGNvbnN0IGF0dHIgPSBrIGFzIFNjaGVtYUF0dHJpYnV0ZVZhbHVlcztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChzY2hlbWFBdHRyaWJ1dGVbYXR0cl0pIHtcbiAgICAgICAgc2NoZW1hQXR0cmlidXRlW2F0dHJdID0gc2NoZW1hW2F0dHJdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcXVlc3RDdXN0b21FcnJvciA9IHJlcXVlc3RFcnJvcjtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIHRoaXMuY2FjaGVJZ25vcmUgPSBjYWNoZUlnbm9yZTtcbiAgICB0aGlzLnByZWZldGNoSWdub3JlID0gcHJlZmV0Y2hJZ25vcmU7XG4gICAgdGhpcy5wcmV2ZW50UnVubmluZyA9IHByZXZlbnRSdW5uaW5nO1xuXG4gICAgLy8gMi4gR2V0IGFuZCBjaGVjayB3cmFwcGVyXG4gICAgdGhpcy5fd3JhcHBlciA9IHRoaXMuZG9tLmdldFdyYXBwZXIoKTtcbiAgICBpZiAoIXRoaXMuX3dyYXBwZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW0BiYXJiYS9jb3JlXSBObyBCYXJiYSB3cmFwcGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIHRoaXMuX3dyYXBwZXIuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7IC8vIEExMXlcblxuICAgIC8vIDMuIEluaXQgcGFnZXMgKGdldCBcImN1cnJlbnRcIiBkYXRhKVxuICAgIHRoaXMuX3Jlc2V0RGF0YSgpO1xuXG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAoIWN1cnJlbnQuY29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tAYmFyYmEvY29yZV0gTm8gQmFyYmEgY29udGFpbmVyIGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLy8gNC4gSW5pdCBvdGhlciBtb2R1bGVzXG4gICAgdGhpcy5jYWNoZSA9IG5ldyBDYWNoZShjYWNoZUlnbm9yZSk7XG4gICAgdGhpcy5wcmV2ZW50ID0gbmV3IFByZXZlbnQocHJlZmV0Y2hJZ25vcmUpO1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgVHJhbnNpdGlvbnModHJhbnNpdGlvbnMpO1xuICAgIHRoaXMudmlld3MgPSBuZXcgVmlld3Modmlld3MpO1xuXG4gICAgLy8gQWRkIHByZXZlbnQgY3VzdG9tXG4gICAgaWYgKHByZXZlbnRDdXN0b20gIT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJldmVudEN1c3RvbSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tAYmFyYmEvY29yZV0gUHJldmVudCBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXZlbnQuYWRkKCdwcmV2ZW50Q3VzdG9tJywgcHJldmVudEN1c3RvbSk7XG4gICAgfVxuXG4gICAgLy8gNS4gVXNlIFwiY3VycmVudFwiIGRhdGFcbiAgICAvLyBJbml0IGhpc3RvcnlcbiAgICB0aGlzLmhpc3RvcnkuaW5pdChjdXJyZW50LnVybC5ocmVmLCBjdXJyZW50Lm5hbWVzcGFjZSk7XG4gICAgLy8gQWRkIHRvIGNhY2hlXG4gICAgLy8gVE9ETzogZG8gbm90IGNhY2hlIHJlbmRlcmVyIEhUTUwsIG9ubHkgcmVxdWVzdCByZXN1bHRz4oCmXG4gICAgLy8gdGhpcy5jYWNoZS5zZXQoY3VycmVudC51cmwuaHJlZiwgUHJvbWlzZS5yZXNvbHZlKGN1cnJlbnQuaHRtbCksICdpbml0Jyk7XG5cbiAgICAvLyA2LiBCaW5kIGNvbnRleHRcbiAgICB0aGlzLl9vbkxpbmtFbnRlciA9IHRoaXMuX29uTGlua0VudGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25MaW5rQ2xpY2sgPSB0aGlzLl9vbkxpbmtDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU3RhdGVDaGFuZ2UgPSB0aGlzLl9vblN0YXRlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYmluZCgpO1xuXG4gICAgLy8gNy4gSW5pdCBwbHVnaW5zXG4gICAgdGhpcy5wbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHBsdWdpbi5pbml0KCkpO1xuXG4gICAgLy8gOC4gQmFyYmEgcmVhZHlcbiAgICAvLyBTZXQgbmV4dCArIHRyaWdnZXIgZm9yIG9uY2UgYW5kIGBiZWZvcmVFbnRlcmAvYGFmdGVyRW50ZXJgIHZpZXcgb24gcGFnZSBsb2FkLlxuICAgIGNvbnN0IG9uY2VEYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgb25jZURhdGEudHJpZ2dlciA9ICdiYXJiYSc7XG4gICAgb25jZURhdGEubmV4dCA9IG9uY2VEYXRhLmN1cnJlbnQ7XG4gICAgb25jZURhdGEuY3VycmVudCA9IHsgLi4udGhpcy5zY2hlbWFQYWdlIH07XG4gICAgdGhpcy5ob29rcy5kbygncmVhZHknLCBvbmNlRGF0YSk7XG5cbiAgICAvLyA5LiBGaW5hbGx5LCBkbyBvbmNl4oCmXG4gICAgdGhpcy5vbmNlKG9uY2VEYXRhKTtcblxuICAgIC8vIENsZWFuIGRhdGEgZm9yIGZpcnN0IGJhcmJhIHRyYW5zaXRpb27igKZcbiAgICB0aGlzLl9yZXNldERhdGEoKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3Jlc2V0RGF0YSgpO1xuICAgIHRoaXMuX3VuYmluZCgpO1xuICAgIHRoaXMuaGlzdG9yeS5jbGVhcigpO1xuICAgIHRoaXMuaG9va3MuY2xlYXIoKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgfVxuXG4gIGdldCBkYXRhKCk6IElUcmFuc2l0aW9uRGF0YSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cblxuICBnZXQgd3JhcHBlcigpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogIyMjIEZvcmNlIGEgcGFnZSBjaGFuZ2Ugd2l0aG91dCBCYXJiYSB0cmFuc2l0aW9uLlxuICAgKi9cbiAgcHVibGljIGZvcmNlKGhyZWY6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIERFVlxuICAgIC8vIENhbiBiZSB1c2VkIHdhaXRpbmcgYW5pbWF0aW9uIGNhbmNlbGxhdGlvbiBtYW5hZ2VtZW504oCmXG4gICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihocmVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgR28gZm9yIGEgQmFyYmEgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogTWFuYWdlIFwic2VsZiBwYWdlXCIgaHJlZjpcbiAgICpcbiAgICogLSBpZiBzYW1lIHVybCBhbmQgbm8gc2VsZiB0cmFuc2l0aW9uLCBrZWVwIGRlZmF1bHQgYmVoYXZpb3JcbiAgICogICAtIGxpbms6IHJlbG9hZCB0aGUgcGFnZVxuICAgKiAgIC0gYW5jaG9yOiBzY3JvbGwgdG9cbiAgICogLSBpZiBzYW1lIHVybCB3aXRoIHNlbGYgdHJhbnNpdGlvbiwgdXNlIGl0XG4gICAqIC0gdGhlbiBzdGFydCBhIHBhZ2UgdHJhbnNpdGlvbi5cbiAgICovXG4gIHB1YmxpYyBnbyhcbiAgICBocmVmOiBzdHJpbmcsXG4gICAgdHJpZ2dlcjogVHJpZ2dlciA9ICdiYXJiYScsXG4gICAgZT86IExpbmtFdmVudCB8IFBvcFN0YXRlRXZlbnRcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gSWYgYW5pbWF0aW9uIHJ1bm5pbmcsIGZvcmNlIHJlbG9hZFxuICAgIGlmICh0aGlzLnRyYW5zaXRpb25zLmlzUnVubmluZykge1xuICAgICAgdGhpcy5mb3JjZShocmVmKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzZWxmID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBwcmV2ZW50IHNhbWVVUkwgYWdhaW5zdCBjdXJyZW50IGhpc3RvcnlcbiAgICAvLyArIHN0YXRlIGNoZWNrXG4gICAgLy8gKyB1cGRhdGUgdHJpZ2dlciB3aXRoIGRpcmVjdGlvblxuICAgIGlmICh0cmlnZ2VyID09PSAncG9wc3RhdGUnKSB7XG4gICAgICBzZWxmID1cbiAgICAgICAgdGhpcy5oaXN0b3J5LmN1cnJlbnQgJiZcbiAgICAgICAgdGhpcy51cmwuZ2V0UGF0aCh0aGlzLmhpc3RvcnkuY3VycmVudC51cmwpID09PSB0aGlzLnVybC5nZXRQYXRoKGhyZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmID0gdGhpcy5wcmV2ZW50LnJ1bignc2FtZVVybCcsIG51bGwsIG51bGwsIGhyZWYpO1xuICAgIH1cblxuICAgIGlmIChzZWxmICYmICF0aGlzLnRyYW5zaXRpb25zLmhhc1NlbGYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmlnZ2VyID0gdGhpcy5oaXN0b3J5LmNoYW5nZShocmVmLCB0cmlnZ2VyLCBlKTtcblxuICAgIGlmIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhZ2UoaHJlZiwgdHJpZ2dlciwgc2VsZik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIFN0YXJ0IGFuIFwib25jZVwiIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIElmIHNvbWUgcmVnaXN0ZXJlZCBcIm9uY2VcIiB0cmFuc2l0aW9uLFxuICAgKiBnZXQgdGhlIFwicmVzb2x2ZWRcIiB0cmFuc2l0aW9uIGZyb20gdGhlIHN0b3JlIGFuZCBzdGFydCBpdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBvbmNlKHJlYWR5RGF0YTogSVRyYW5zaXRpb25EYXRhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5ob29rcy5kbygnYmVmb3JlRW50ZXInLCByZWFkeURhdGEpO1xuXG4gICAgLy8gQ2hlY2sgaWYgb25jZSB0cmFuc2l0aW9uXG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbnMuaGFzT25jZSkge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbnMuZ2V0KHJlYWR5RGF0YSwge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgfSkgYXMgSVRyYW5zaXRpb25PbmNlO1xuXG4gICAgICBhd2FpdCB0aGlzLnRyYW5zaXRpb25zLmRvT25jZSh7IHRyYW5zaXRpb24sIGRhdGE6IHJlYWR5RGF0YSB9KTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmhvb2tzLmRvKCdhZnRlckVudGVyJywgcmVhZHlEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgU3RhcnQgYSBcInBhZ2VcIiB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiAxLiBJZiBubyBydW5uaW5nIHRyYW5zaXRpb24sIHVwZGF0ZXMgZGF0YSB3aXRoIGZ1bGwgVVJMIHByb3BlcnRpZXMgYW5kIHRyaWdnZXIuXG4gICAqIDIuIEdldCBwYWdlIGZyb20gY2FjaGUgb3IgaW5pdCByZXF1ZXN0LlxuICAgKiAzLiBXYWl0IGlmIHNvbWUgdHJhbnNpdGlvbnMgbmVlZCBcIm5leHRcIiBkYXRhIChgc3luYzogdHJ1ZWAsIGB0bzog4oCmYCkuXG4gICAqIDQuIE1hbmFnZSB0aGUgaGlzdG9yeSwgZGVwZW5kaW5nIG9uIHRyaWdnZXIuXG4gICAqIDUuIEdldCBcImRhdGFcIiBhbmQgdHJpZ2dlciBcImdvXCIgaG9vay5cbiAgICogNi4gR2V0IHRoZSBcInJlc29sdmVkXCIgdHJhbnNpdGlvbiBmcm9tIHRoZSBzdG9yZSBhbmQgc3RhcnQgaXQuXG4gICAqIDcuIFVwZGF0ZSB0aXRsZSBhbmQgcmVzZXQgZGF0YSAoY3VycmVudCwgbmV4dCA9IHVuZGVmaW5lZCkuXG4gICAqXG4gICAqID4gSWYgXCJzZWxmXCIsIHVzZSB0aGUgXCJzZWxmXCIgdHJhbnNpdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIHBhZ2UoXG4gICAgaHJlZjogc3RyaW5nLFxuICAgIHRyaWdnZXI6IFRyaWdnZXIsXG4gICAgc2VsZjogYm9vbGVhblxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmRhdGEubmV4dC51cmwgPSB7XG4gICAgICBocmVmLFxuICAgICAgLi4udGhpcy51cmwucGFyc2UoaHJlZiksXG4gICAgfTtcbiAgICB0aGlzLmRhdGEudHJpZ2dlciA9IHRyaWdnZXI7XG5cbiAgICBjb25zdCBwYWdlID0gdGhpcy5jYWNoZS5oYXMoaHJlZilcbiAgICAgID8gdGhpcy5jYWNoZS51cGRhdGUoaHJlZiwgeyBhY3Rpb246ICdjbGljaycgfSkucmVxdWVzdFxuICAgICAgOiB0aGlzLmNhY2hlLnNldChcbiAgICAgICAgICBocmVmLFxuICAgICAgICAgIHRoaXMucmVxdWVzdChcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQsXG4gICAgICAgICAgICB0aGlzLm9uUmVxdWVzdEVycm9yLmJpbmQodGhpcywgdHJpZ2dlcilcbiAgICAgICAgICApLFxuICAgICAgICAgICdjbGljaydcbiAgICAgICAgKS5yZXF1ZXN0O1xuXG4gICAgLy8gTmVlZCB0byB3YWl0IGJlZm9yZSBnZXR0aW5nIHRoZSByaWdodCB0cmFuc2l0aW9uXG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbnMuc2hvdWxkV2FpdCkge1xuICAgICAgYXdhaXQgaGVscGVycy51cGRhdGUocGFnZSwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgLy8gSG9vazogYmV0d2VlbiB0cmlnZ2VyIGFuZCB0cmFuc2l0aW9uXG4gICAgLy8gQ2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBcInJvdXRlXCLigKZcbiAgICBhd2FpdCB0aGlzLmhvb2tzLmRvKCdwYWdlJywgZGF0YSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbnMuZ2V0KGRhdGEsIHtcbiAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgIHNlbGYsXG4gICAgICB9KSBhcyBJVHJhbnNpdGlvblBhZ2U7XG5cbiAgICAgIGF3YWl0IHRoaXMudHJhbnNpdGlvbnMuZG9QYWdlKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdHJhbnNpdGlvbixcbiAgICAgICAgd3JhcHBlcjogdGhpcy5fd3JhcHBlcixcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXNldERhdGEoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gU29tZXRoaW5nIHdlbnQgd3JvbmcgKHJlamVjdGVkIHByb21pc2UsIGVycm9yLCA0MDQsIDUwNSwgb3RoZXLigKYpXG4gICAgICAvLyBUT0RPOiBtYW5hZ2UgLyB1c2UgY2FzZXMgZm9yIGNhbmNlbGxhdGlvblxuICAgICAgLy8gdGhpcy5sb2dnZXIuZGVidWcoJ1RyYW5zaXRpb24gY2FuY2VsbGVkJyk7XG5cbiAgICAgIC8vIElmIHRyYW5zaXRpb24gZXJyb3IgYW5kIG5vIGRlYnVnIG1vZGUsIGZvcmNlIHJlbG9hZCBwYWdlLlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChMb2dnZXIuZ2V0TGV2ZWwoKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmZvcmNlKGRhdGEuY3VycmVudC51cmwuaHJlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICpcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gbWFuYWdlIHJlcXVlc3QgZXJyb3IuIChFLmc6IDQwNClcbiAgICovXG4gIHB1YmxpYyBvblJlcXVlc3RFcnJvcih0cmlnZ2VyOiBUcmlnZ2VyLCAuLi5hcmdzOiBhbnkpOiBib29sZWFuIHtcbiAgICAvLyBDYW5jZWwgdHJhbnNpdGlvbiBzdGF0dXNcbiAgICB0aGlzLnRyYW5zaXRpb25zLmlzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgY29uc3QgW2hyZWYsIHJlc3BvbnNlXTogW3N0cmluZywgUmVxdWVzdEVycm9yT3JSZXNwb25zZV0gPSBhcmdzO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuY2FjaGUuZ2V0QWN0aW9uKGhyZWYpO1xuICAgIHRoaXMuY2FjaGUuZGVsZXRlKGhyZWYpO1xuXG4gICAgLy8gQ3VzdG9tIHJlcXVlc3RFcnJvciByZXR1cm5pbmcgZmFsc2Ugd2lsbCByZXR1cm4gaGVyZS5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9yZXF1ZXN0Q3VzdG9tRXJyb3IgJiZcbiAgICAgIHRoaXMuX3JlcXVlc3RDdXN0b21FcnJvcih0cmlnZ2VyLCBhY3Rpb24sIGhyZWYsIHJlc3BvbnNlKSA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBwYWdlIGNoYW5nZVxuICAgIGlmIChhY3Rpb24gPT09ICdjbGljaycpIHtcbiAgICAgIHRoaXMuZm9yY2UoaHJlZik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9ncmFtbWF0aWNhbGx5IHByZWZldGNoXG4gICAqL1xuICBwdWJsaWMgcHJlZmV0Y2goaHJlZjogc3RyaW5nKSB7XG4gICAgLy8gQWxyZWFkeSBpbiBjYWNoZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKGhyZWYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZS5zZXQoXG4gICAgICBocmVmLFxuICAgICAgdGhpcy5yZXF1ZXN0KFxuICAgICAgICBocmVmLFxuICAgICAgICB0aGlzLnRpbWVvdXQsXG4gICAgICAgIHRoaXMub25SZXF1ZXN0RXJyb3IuYmluZCh0aGlzLCAnYmFyYmEnKVxuICAgICAgKS5jYXRjaCgoZXJyb3I6IFJlcXVlc3RFcnJvck9yUmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfSksXG4gICAgICAncHJlZmV0Y2gnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIGV2ZW50IGxpc3RlbmVycy5cbiAgICovXG4gIHByaXZhdGUgX2JpbmQoKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5wcmVmZXRjaElnbm9yZSAhPT0gdHJ1ZSkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25MaW5rRW50ZXIpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uTGlua0VudGVyKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkxpbmtDbGljayk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5fb25TdGF0ZUNoYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogQmluZCBldmVudCBsaXN0ZW5lcnMuXG4gICAqL1xuICBwcml2YXRlIF91bmJpbmQoKTogdm9pZCB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5wcmVmZXRjaElnbm9yZSAhPT0gdHJ1ZSkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fb25MaW5rRW50ZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uTGlua0VudGVyKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkxpbmtDbGljayk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5fb25TdGF0ZUNoYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIGVsZW1lbnQgaXMgZW50ZXJlZC5cbiAgICpcbiAgICogR2V0IHZhbGlkIGxpbmsgZWxlbWVudC5cbiAgICogQ2FjaGUgVVJMIGlmIG5lZWRlZC5cbiAgICovXG4gIHByaXZhdGUgX29uTGlua0VudGVyKGU6IExpbmtFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGxpbmsgPSB0aGlzLl9nZXRMaW5rRWxlbWVudChlKTtcblxuICAgIGlmICghbGluaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhyZWYgPSB0aGlzLmRvbS5nZXRIcmVmKGxpbmspO1xuXG4gICAgaWYgKHRoaXMucHJldmVudC5jaGVja0hyZWYoaHJlZikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbHJlYWR5IGluIGNhY2hlXG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKGhyZWYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZS5zZXQoXG4gICAgICBocmVmLFxuICAgICAgdGhpcy5yZXF1ZXN0KFxuICAgICAgICBocmVmLFxuICAgICAgICB0aGlzLnRpbWVvdXQsXG4gICAgICAgIHRoaXMub25SZXF1ZXN0RXJyb3IuYmluZCh0aGlzLCBsaW5rKVxuICAgICAgKS5jYXRjaCgoZXJyb3I6IFJlcXVlc3RFcnJvck9yUmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfSksXG4gICAgICAnZW50ZXInXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGFuIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICpcbiAgICogR2V0IHZhbGlkIGxpbmsgZWxlbWVudC5cbiAgICogUHJldmVudCBzYW1lIFVSTC5cbiAgICogR28gZm9yIGEgQmFyYmEgdHJhbnNpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX29uTGlua0NsaWNrKGU6IExpbmtFdmVudCk6IHZvaWQge1xuICAgIC8vIFRoaXMgdXNlIGBwcmV2ZW50LmNoZWNrTGlua2AgdW5kZXIgdGhlIGhvb2QgdG8gZ2V0IGVsaWdpYmxlIGxpbmsuXG4gICAgY29uc3QgbGluayA9IHRoaXMuX2dldExpbmtFbGVtZW50KGUpO1xuXG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbnMuaXNSdW5uaW5nICYmIHRoaXMucHJldmVudFJ1bm5pbmcpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmdvKHRoaXMuZG9tLmdldEhyZWYobGluayksIGxpbmssIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gSGlzdG9yeSBzdGF0ZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBHZXQgXCJocmVmXCIgZnJvbSBVUkxcbiAgICogR28gZm9yIGEgQmFyYmEgdHJhbnNpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX29uU3RhdGVDaGFuZ2UoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZ28odGhpcy51cmwuZ2V0SHJlZigpLCAncG9wc3RhdGUnLCBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWxpZCBsaW5rIGFuY2VzdG9yLlxuICAgKlxuICAgKiBDaGVjayBmb3IgYSBcImhyZWZcIiBhdHRyaWJ1dGUuXG4gICAqIFRoZW4gY2hlY2sgaWYgZWxpZ2libGUgZm9yIEJhcmJhLlxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0TGlua0VsZW1lbnQoZTogTGlua0V2ZW50KTogTGluayB7XG4gICAgbGV0IGVsID0gZS50YXJnZXQgYXMgTGluaztcblxuICAgIHdoaWxlIChlbCAmJiAhdGhpcy5kb20uZ2V0SHJlZihlbCkpIHtcbiAgICAgIGVsID0gKGVsIGFzIEhUTUxFbGVtZW50KS5wYXJlbnROb2RlIGFzIExpbms7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcHJldmVudFxuICAgIGlmICghZWwgfHwgdGhpcy5wcmV2ZW50LmNoZWNrTGluayhlbCwgZSwgdGhpcy5kb20uZ2V0SHJlZihlbCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHBhZ2VzIGRhdGEuXG4gICAqXG4gICAqIFNldCBcImN1cnJlbnRcIiBhbmQgdW5zZXQgXCJuZXh0XCIuXG4gICAqL1xuICBwcml2YXRlIF9yZXNldERhdGEoKSB7XG4gICAgY29uc3QgaHJlZiA9IHRoaXMudXJsLmdldEhyZWYoKTtcbiAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgY29udGFpbmVyOiB0aGlzLmRvbS5nZXRDb250YWluZXIoKSxcbiAgICAgIGh0bWw6IHRoaXMuZG9tLmdldEh0bWwoKSxcbiAgICAgIG5hbWVzcGFjZTogdGhpcy5kb20uZ2V0TmFtZXNwYWNlKCksXG4gICAgICB1cmw6IHtcbiAgICAgICAgaHJlZixcbiAgICAgICAgLi4udGhpcy51cmwucGFyc2UoaHJlZiksXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0aGlzLl9kYXRhID0ge1xuICAgICAgY3VycmVudCxcbiAgICAgIG5leHQ6IHsgLi4udGhpcy5zY2hlbWFQYWdlIH0sXG4gICAgICB0cmlnZ2VyOiB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIHRoaXMuaG9va3MuZG8oJ3Jlc2V0JywgdGhpcy5kYXRhKTtcbiAgfVxufVxuXG5jb25zdCBjb3JlID0gbmV3IENvcmUoKTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZTtcbiIsIjsoZnVuY3Rpb24gKHdpbmRvdywgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhY3Rvcnkod2luZG93KVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAvLyBsaWtlIE5vZGUuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHdpbmRvdylcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICB3aW5kb3cubWVkaWFMb2FkZWQgPSBmYWN0b3J5KHdpbmRvdylcbiAgfVxufSkodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiBmYWN0b3J5KHdpbmRvdykge1xuICBmdW5jdGlvbiBtYWtlQXJyYXkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5TGlrZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcidcbiAgICBpZiAoaXNBcnJheUxpa2UpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gW3ZhbHVlXVxuICB9XG5cbiAgZnVuY3Rpb24gbWVkaWFMb2FkZWQoZWwsIG9uQ29tcGxldGUpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBlbFxuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWwpXG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgY29uc29sZS5lcnJvcignbWVkaWFMb2FkZWQ6IEludmFsaWQgZWxlbWVudCcsIGVsKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBtYWtlQXJyYXkoZWxlbWVudHMpXG5cbiAgICB2YXIgaW1hZ2VzID0gW11cbiAgICB2YXIgdmlkZW9zID0gW11cbiAgICB2YXIgcG9zdGVycyA9IFtdXG5cbiAgICAvLyBGaW5kIGFsbCB2aWRlb3MgJiBpbWFnZXNcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnSU1HJykge1xuICAgICAgICBpbWFnZXMudW5zaGlmdChlbGVtZW50KVxuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdWSURFTycpIHtcbiAgICAgICAgdmlkZW9zLnVuc2hpZnQoZWxlbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlcyA9IGltYWdlcy5jb25jYXQobWFrZUFycmF5KGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpKSlcbiAgICAgICAgdmlkZW9zID0gdmlkZW9zLmNvbmNhdChtYWtlQXJyYXkoZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKSkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEZpbmQgYWxsIHBvc3RlcnNcbiAgICB2aWRlb3MuZm9yRWFjaChmdW5jdGlvbiAodmlkZW8pIHtcbiAgICAgIGlmICh2aWRlby5wb3N0ZXIpIHtcbiAgICAgICAgdmFyIHBvc3RlciA9IG5ldyBJbWFnZSgpXG4gICAgICAgIHBvc3Rlci5zcmMgPSB2aWRlby5wb3N0ZXJcbiAgICAgICAgcG9zdGVycy5wdXNoKHBvc3RlcilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gV2l0aCBhbGwgcG9zdGVycyBmb3VuZCwgZmlsdGVyIG91dCBub24gYXV0b3BsYXkgdmlkZW9zIGZvciB0b3VjaCBkZXZpY2VzXG4gICAgLy8gYXMgdmlkZW8gZXZlbnRzIHdvbid0IHRyaWdnZXIgdW50aWwgdXNlciBpbnRlcmFjdGlvbi5cbiAgICB2YXIgaXNUb3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwXG4gICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgIHZpZGVvcyA9IHZpZGVvcy5maWx0ZXIoZnVuY3Rpb24gKHZpZGVvKSB7XG4gICAgICAgIHJldHVybiB2aWRlby5hdXRvcGxheVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB2YXIgdG90YWwgPSBpbWFnZXMubGVuZ3RoICsgdmlkZW9zLmxlbmd0aCArIHBvc3RlcnMubGVuZ3RoXG4gICAgdmFyIGhhc0Jyb2tlbiA9IGZhbHNlXG4gICAgdmFyIGNvdW50ID0gMFxuXG4gICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICBvbkNvbXBsZXRlKHtcbiAgICAgICAgICBpbWFnZXM6IGltYWdlcyxcbiAgICAgICAgICB2aWRlb3M6IHZpZGVvcyxcbiAgICAgICAgICBwb3N0ZXJzOiBwb3N0ZXJzLFxuICAgICAgICAgIGhhc0Jyb2tlbjogaGFzQnJva2VuLFxuICAgICAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNZWRpYUxvYWRlZChldmVudCkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGhhbmRsZU1lZGlhTG9hZGVkKVxuXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgaGFzQnJva2VuID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvdW50ICs9IDFcblxuICAgICAgaWYgKHRvdGFsID09PSBjb3VudCkge1xuICAgICAgICBjb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcGxldGUgaWYgbm8gbWVkaWEgZm91bmQuXG4gICAgaWYgKHRvdGFsID09PSAwKSB7XG4gICAgICBjb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpbWFnZXMuY29uY2F0KHBvc3RlcnMpLmZvckVhY2goZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAvLyBDaGVjayBmb3Igbm9uLXplcm8sIG5vbi11bmRlZmluZWQgbmF0dXJhbFdpZHRoXG4gICAgICBpZiAoIWltYWdlLmNvbXBsZXRlIHx8ICFpbWFnZS5uYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZU1lZGlhTG9hZGVkKVxuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZU1lZGlhTG9hZGVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTWVkaWFMb2FkZWQoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB2aWRlb3MuZm9yRWFjaChmdW5jdGlvbiAodmlkZW8pIHtcbiAgICAgIGlmICh2aWRlby5yZWFkeVN0YXRlIDwgMikge1xuICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgaGFuZGxlTWVkaWFMb2FkZWQpXG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlTWVkaWFMb2FkZWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVNZWRpYUxvYWRlZCgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBtZWRpYUxvYWRlZFxufSlcbiIsIi8qIVxuICogQ1NTUGx1Z2luIDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtIC8vZm9yIHRoZSBjb21tZW50ZWQtb3V0IGNsYXNzTmFtZSBmZWF0dXJlLlxufSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcblxudmFyIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfcGx1Z2luSW5pdHRlZCxcbiAgICBfdGVtcERpdixcbiAgICBfdGVtcERpdlN0eWxlcixcbiAgICBfcmVjZW50U2V0dGVyUGx1Z2luLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3BzID0ge30sXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgIF9iaWdOdW0gPSAxZTgsXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxuICAgIF9ob3Jpem9udGFsRXhwID0gLyhsZWZ0fHJpZ2h0fHdpZHRofG1hcmdpbnxwYWRkaW5nfHgpL2ksXG4gICAgX2NvbXBsZXhFeHAgPSAvW1xccyxcXChdXFxTLyxcbiAgICBfcHJvcGVydHlBbGlhc2VzID0ge1xuICBhdXRvQWxwaGE6IFwib3BhY2l0eSx2aXNpYmlsaXR5XCIsXG4gIHNjYWxlOiBcInNjYWxlWCxzY2FsZVlcIixcbiAgYWxwaGE6IFwib3BhY2l0eVwiXG59LFxuICAgIF9yZW5kZXJDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wV2l0aEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJQcm9wV2l0aEVuZChyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmcocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51IDogZGF0YS5iLCBkYXRhKTtcbn0sXG4gICAgLy9pZiB1bml0cyBjaGFuZ2UsIHdlIG5lZWQgYSB3YXkgdG8gcmVuZGVyIHRoZSBvcmlnaW5hbCB1bml0L3ZhbHVlIHdoZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nIChyYXRpbzowKVxuX3JlbmRlclJvdW5kZWRDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlclJvdW5kZWRDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEucyArIGRhdGEuYyAqIHJhdGlvO1xuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgfn4odmFsdWUgKyAodmFsdWUgPCAwID8gLS41IDogLjUpKSArIGRhdGEudSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kID0gZnVuY3Rpb24gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyAhPT0gMSA/IGRhdGEuYiA6IGRhdGEuZSwgZGF0YSk7XG59LFxuICAgIF9zZXR0ZXJDU1NTdHlsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NTdHlsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9zZXR0ZXJDU1NQcm9wKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbn0sXG4gICAgX3NldHRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlID0gZnVuY3Rpb24gX3NldHRlclNjYWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAuc2NhbGVYID0gdGFyZ2V0Ll9nc2FwLnNjYWxlWSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclNjYWxlV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICBjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSB2YWx1ZTtcbiAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGVbcHJvcGVydHldID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG4gICAgX3N1cHBvcnRzM0QsXG4gICAgX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCh0eXBlLCBucykge1xuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoKG5zIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKS5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgc2VydmVycyBzd2FwIGluIGh0dHBzIGZvciBodHRwIGluIHRoZSBuYW1lc3BhY2Ugd2hpY2ggY2FuIGJyZWFrIHRoaW5ncywgbWFraW5nIFwic3R5bGVcIiBpbmFjY2Vzc2libGUuXG5cbiAgcmV0dXJuIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMjE1LXByb2JsZW0tdXNpbmctdHdlZW5tYXgtaW4tc3RhbmRhbG9uZS1zZWxmLWNvbnRhaW5pbmctc3ZnLWZpbGUtZXJyLWNhbm5vdC1zZXQtcHJvcGVydHktY3NzdGV4dC1vZi11bmRlZmluZWQvKS5cbn0sXG4gICAgX2dldENvbXB1dGVkUHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBza2lwUHJlZml4RmFsbGJhY2spIHtcbiAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICByZXR1cm4gY3NbcHJvcGVydHldIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSkgfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgfHwgIXNraXBQcmVmaXhGYWxsYmFjayAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHkpIHx8IHByb3BlcnR5LCAxKSB8fCBcIlwiOyAvL2NzcyB2YXJpYWJsZXMgbWF5IG5vdCBuZWVkIGNhcHMgc3dhcHBlZCBvdXQgZm9yIGRhc2hlcyBhbmQgbG93ZXJjYXNlLlxufSxcbiAgICBfcHJlZml4ZXMgPSBcIk8sTW96LG1zLE1zLFdlYmtpdFwiLnNwbGl0KFwiLFwiKSxcbiAgICBfY2hlY2tQcm9wUHJlZml4ID0gZnVuY3Rpb24gX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSwgZWxlbWVudCwgcHJlZmVyUHJlZml4KSB7XG4gIHZhciBlID0gZWxlbWVudCB8fCBfdGVtcERpdixcbiAgICAgIHMgPSBlLnN0eWxlLFxuICAgICAgaSA9IDU7XG5cbiAgaWYgKHByb3BlcnR5IGluIHMgJiYgIXByZWZlclByZWZpeCkge1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIHByb3BlcnR5ID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XG5cbiAgd2hpbGUgKGktLSAmJiAhKF9wcmVmaXhlc1tpXSArIHByb3BlcnR5IGluIHMpKSB7fVxuXG4gIHJldHVybiBpIDwgMCA/IG51bGwgOiAoaSA9PT0gMyA/IFwibXNcIiA6IGkgPj0gMCA/IF9wcmVmaXhlc1tpXSA6IFwiXCIpICsgcHJvcGVydHk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgaWYgKF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBfd2luLmRvY3VtZW50O1xuICAgIF9kb2NFbGVtZW50ID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSB8fCB7XG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICAgIF90ZW1wRGl2U3R5bGVyID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3RyYW5zZm9ybVByb3AgPSBfY2hlY2tQcm9wUHJlZml4KF90cmFuc2Zvcm1Qcm9wKTtcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcbiAgICBfdGVtcERpdi5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXItd2lkdGg6MDtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmc6MFwiOyAvL21ha2Ugc3VyZSB0byBvdmVycmlkZSBjZXJ0YWluIHByb3BlcnRpZXMgdGhhdCBtYXkgY29udGFtaW5hdGUgbWVhc3VyZW1lbnRzLCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBvdmVycmVhY2hpbmcgc3R5bGUgc2hlZXRzLlxuXG4gICAgX3N1cHBvcnRzM0QgPSAhIV9jaGVja1Byb3BQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKTtcbiAgICBfcGx1Z2luSW5pdHRlZCA9IDE7XG4gIH1cbn0sXG4gICAgX2dldEJCb3hIYWNrID0gZnVuY3Rpb24gX2dldEJCb3hIYWNrKHN3YXBJZlBvc3NpYmxlKSB7XG4gIC8vd29ya3MgYXJvdW5kIGlzc3VlcyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHRoYXQgZG9uJ3QgY29ycmVjdGx5IHJlcG9ydCBnZXRCQm94KCkgb24gU1ZHIGVsZW1lbnRzIGluc2lkZSBhIDxkZWZzPiBlbGVtZW50IGFuZC9vciA8bWFzaz4uIFdlIHRyeSBjcmVhdGluZyBhbiBTVkcsIGFkZGluZyBpdCB0byB0aGUgZG9jdW1lbnRFbGVtZW50IGFuZCB0b3NzIHRoZSBlbGVtZW50IGluIHRoZXJlIHNvIHRoYXQgaXQncyBkZWZpbml0ZWx5IHBhcnQgb2YgdGhlIHJlbmRlcmluZyB0cmVlLCB0aGVuIGdyYWIgdGhlIGJib3ggYW5kIGlmIGl0IHdvcmtzLCB3ZSBhY3R1YWxseSBzd2FwIG91dCB0aGUgb3JpZ2luYWwgZ2V0QkJveCgpIG1ldGhvZCBmb3Igb3VyIG93biB0aGF0IGRvZXMgdGhlc2UgZXh0cmEgc3RlcHMgd2hlbmV2ZXIgZ2V0QkJveCBpcyBuZWVkZWQuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgcGVyZm9ybWFuY2UgaXMgb3B0aW1hbCAob25seSBkbyBhbGwgdGhlc2UgZXh0cmEgc3RlcHMgd2hlbiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeS4uLm1vc3QgZWxlbWVudHMgZG9uJ3QgbmVlZCBpdCkuXG4gIHZhciBzdmcgPSBfY3JlYXRlRWxlbWVudChcInN2Z1wiLCB0aGlzLm93bmVyU1ZHRWxlbWVudCAmJiB0aGlzLm93bmVyU1ZHRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSB8fCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpLFxuICAgICAgb2xkUGFyZW50ID0gdGhpcy5wYXJlbnROb2RlLFxuICAgICAgb2xkU2libGluZyA9IHRoaXMubmV4dFNpYmxpbmcsXG4gICAgICBvbGRDU1MgPSB0aGlzLnN0eWxlLmNzc1RleHQsXG4gICAgICBiYm94O1xuXG4gIF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHN2Zyk7XG5cbiAgc3ZnLmFwcGVuZENoaWxkKHRoaXMpO1xuICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgaWYgKHN3YXBJZlBvc3NpYmxlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgIHRoaXMuX2dzYXBCQm94ID0gdGhpcy5nZXRCQm94OyAvL3N0b3JlIHRoZSBvcmlnaW5hbFxuXG4gICAgICB0aGlzLmdldEJCb3ggPSBfZ2V0QkJveEhhY2s7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSBlbHNlIGlmICh0aGlzLl9nc2FwQkJveCkge1xuICAgIGJib3ggPSB0aGlzLl9nc2FwQkJveCgpO1xuICB9XG5cbiAgaWYgKG9sZFBhcmVudCkge1xuICAgIGlmIChvbGRTaWJsaW5nKSB7XG4gICAgICBvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIG9sZFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgX2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblxuICB0aGlzLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gIHJldHVybiBiYm94O1xufSxcbiAgICBfZ2V0QXR0cmlidXRlRmFsbGJhY2tzID0gZnVuY3Rpb24gX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIGF0dHJpYnV0ZXNBcnJheSkge1xuICB2YXIgaSA9IGF0dHJpYnV0ZXNBcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9nZXRCQm94ID0gZnVuY3Rpb24gX2dldEJCb3godGFyZ2V0KSB7XG4gIHZhciBib3VuZHM7XG5cbiAgdHJ5IHtcbiAgICBib3VuZHMgPSB0YXJnZXQuZ2V0QkJveCgpOyAvL0ZpcmVmb3ggdGhyb3dzIGVycm9ycyBpZiB5b3UgdHJ5IGNhbGxpbmcgZ2V0QkJveCgpIG9uIGFuIFNWRyBlbGVtZW50IHRoYXQncyBub3QgcmVuZGVyZWQgKGxpa2UgaW4gYSA8c3ltYm9sPiBvciA8ZGVmcz4pLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MTIxMThcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveEhhY2suY2FsbCh0YXJnZXQsIHRydWUpO1xuICB9XG5cbiAgYm91bmRzICYmIChib3VuZHMud2lkdGggfHwgYm91bmRzLmhlaWdodCkgfHwgdGFyZ2V0LmdldEJCb3ggPT09IF9nZXRCQm94SGFjayB8fCAoYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKSk7IC8vc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSBtaXNyZXBvcnQgdGhlIGJvdW5kcyBpZiB0aGUgZWxlbWVudCBoYXMgemVybyB3aWR0aCBhbmQgaGVpZ2h0IChpdCBqdXN0IGFzc3VtZXMgaXQncyBhdCB4OjAsIHk6MCksIHRodXMgd2UgbmVlZCB0byBtYW51YWxseSBncmFiIHRoZSBwb3NpdGlvbiBpbiB0aGF0IGNhc2UuXG5cbiAgcmV0dXJuIGJvdW5kcyAmJiAhYm91bmRzLndpZHRoICYmICFib3VuZHMueCAmJiAhYm91bmRzLnkgPyB7XG4gICAgeDogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ4XCIsIFwiY3hcIiwgXCJ4MVwiXSkgfHwgMCxcbiAgICB5OiArX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIFtcInlcIiwgXCJjeVwiLCBcInkxXCJdKSB8fCAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9IDogYm91bmRzO1xufSxcbiAgICBfaXNTVkcgPSBmdW5jdGlvbiBfaXNTVkcoZSkge1xuICByZXR1cm4gISEoZS5nZXRDVE0gJiYgKCFlLnBhcmVudE5vZGUgfHwgZS5vd25lclNWR0VsZW1lbnQpICYmIF9nZXRCQm94KGUpKTtcbn0sXG4gICAgLy9yZXBvcnRzIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWRyBvbiB3aGljaCBnZXRCQm94KCkgYWN0dWFsbHkgd29ya3Ncbl9yZW1vdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSkge1xuICAgIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZTtcblxuICAgIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB7XG4gICAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgaWYgKHByb3BlcnR5LnN1YnN0cigwLCAyKSA9PT0gXCJtc1wiIHx8IHByb3BlcnR5LnN1YnN0cigwLCA2KSA9PT0gXCJ3ZWJraXRcIikge1xuICAgICAgICAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHByb3BlcnR5ID0gXCItXCIgKyBwcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQgPSBmdW5jdGlvbiBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpIHtcbiAgdmFyIHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBvbmx5U2V0QXRFbmQgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKTtcbiAgcGx1Z2luLl9wdCA9IHB0O1xuICBwdC5iID0gYmVnaW5uaW5nO1xuICBwdC5lID0gZW5kO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfbm9uQ29udmVydGlibGVVbml0cyA9IHtcbiAgZGVnOiAxLFxuICByYWQ6IDEsXG4gIHR1cm46IDFcbn0sXG4gICAgLy90YWtlcyBhIHNpbmdsZSB2YWx1ZSBsaWtlIDIwcHggYW5kIGNvbnZlcnRzIGl0IHRvIHRoZSB1bml0IHNwZWNpZmllZCwgbGlrZSBcIiVcIiwgcmV0dXJuaW5nIG9ubHkgdGhlIG51bWVyaWMgYW1vdW50LlxuX2NvbnZlcnRUb1VuaXQgPSBmdW5jdGlvbiBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkge1xuICB2YXIgY3VyVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwLFxuICAgICAgY3VyVW5pdCA9ICh2YWx1ZSArIFwiXCIpLnRyaW0oKS5zdWJzdHIoKGN1clZhbHVlICsgXCJcIikubGVuZ3RoKSB8fCBcInB4XCIsXG4gICAgICAvLyBzb21lIGJyb3dzZXJzIGxlYXZlIGV4dHJhIHdoaXRlc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiBDU1MgdmFyaWFibGVzLCBoZW5jZSB0aGUgbmVlZCB0byB0cmltKClcbiAgc3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcbiAgICAgIGhvcml6b250YWwgPSBfaG9yaXpvbnRhbEV4cC50ZXN0KHByb3BlcnR5KSxcbiAgICAgIGlzUm9vdFNWRyA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIsXG4gICAgICBtZWFzdXJlUHJvcGVydHkgPSAoaXNSb290U1ZHID8gXCJjbGllbnRcIiA6IFwib2Zmc2V0XCIpICsgKGhvcml6b250YWwgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiKSxcbiAgICAgIGFtb3VudCA9IDEwMCxcbiAgICAgIHRvUGl4ZWxzID0gdW5pdCA9PT0gXCJweFwiLFxuICAgICAgdG9QZXJjZW50ID0gdW5pdCA9PT0gXCIlXCIsXG4gICAgICBweCxcbiAgICAgIHBhcmVudCxcbiAgICAgIGNhY2hlLFxuICAgICAgaXNTVkc7XG5cbiAgaWYgKHVuaXQgPT09IGN1clVuaXQgfHwgIWN1clZhbHVlIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW3VuaXRdIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW2N1clVuaXRdKSB7XG4gICAgcmV0dXJuIGN1clZhbHVlO1xuICB9XG5cbiAgY3VyVW5pdCAhPT0gXCJweFwiICYmICF0b1BpeGVscyAmJiAoY3VyVmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgXCJweFwiKSk7XG4gIGlzU1ZHID0gdGFyZ2V0LmdldENUTSAmJiBfaXNTVkcodGFyZ2V0KTtcblxuICBpZiAoKHRvUGVyY2VudCB8fCBjdXJVbml0ID09PSBcIiVcIikgJiYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wZXJ0eV0gfHwgfnByb3BlcnR5LmluZGV4T2YoXCJhZGl1c1wiKSkpIHtcbiAgICBweCA9IGlzU1ZHID8gdGFyZ2V0LmdldEJCb3goKVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gOiB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICByZXR1cm4gX3JvdW5kKHRvUGVyY2VudCA/IGN1clZhbHVlIC8gcHggKiBhbW91bnQgOiBjdXJWYWx1ZSAvIDEwMCAqIHB4KTtcbiAgfVxuXG4gIHN0eWxlW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IGFtb3VudCArICh0b1BpeGVscyA/IGN1clVuaXQgOiB1bml0KTtcbiAgcGFyZW50ID0gfnByb3BlcnR5LmluZGV4T2YoXCJhZGl1c1wiKSB8fCB1bml0ID09PSBcImVtXCIgJiYgdGFyZ2V0LmFwcGVuZENoaWxkICYmICFpc1Jvb3RTVkcgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZTtcblxuICBpZiAoaXNTVkcpIHtcbiAgICBwYXJlbnQgPSAodGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCB8fCB7fSkucGFyZW50Tm9kZTtcbiAgfVxuXG4gIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gX2RvYyB8fCAhcGFyZW50LmFwcGVuZENoaWxkKSB7XG4gICAgcGFyZW50ID0gX2RvYy5ib2R5O1xuICB9XG5cbiAgY2FjaGUgPSBwYXJlbnQuX2dzYXA7XG5cbiAgaWYgKGNhY2hlICYmIHRvUGVyY2VudCAmJiBjYWNoZS53aWR0aCAmJiBob3Jpem9udGFsICYmIGNhY2hlLnRpbWUgPT09IF90aWNrZXIudGltZSkge1xuICAgIHJldHVybiBfcm91bmQoY3VyVmFsdWUgLyBjYWNoZS53aWR0aCAqIGFtb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgKHRvUGVyY2VudCB8fCBjdXJVbml0ID09PSBcIiVcIikgJiYgKHN0eWxlLnBvc2l0aW9uID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcInBvc2l0aW9uXCIpKTtcbiAgICBwYXJlbnQgPT09IHRhcmdldCAmJiAoc3R5bGUucG9zaXRpb24gPSBcInN0YXRpY1wiKTsgLy8gbGlrZSBmb3IgYm9yZGVyUmFkaXVzLCBpZiBpdCdzIGEgJSB3ZSBtdXN0IGhhdmUgaXQgcmVsYXRpdmUgdG8gdGhlIHRhcmdldCBpdHNlbGYgYnV0IHRoYXQgbWF5IG5vdCBoYXZlIHBvc2l0aW9uOiByZWxhdGl2ZSBvciBwb3NpdGlvbjogYWJzb2x1dGUgaW4gd2hpY2ggY2FzZSBpdCdkIGdvIHVwIHRoZSBjaGFpbiB1bnRpbCBpdCBmaW5kcyBpdHMgb2Zmc2V0UGFyZW50IChiYWQpLiBwb3NpdGlvbjogc3RhdGljIHByb3RlY3RzIGFnYWluc3QgdGhhdC5cblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChfdGVtcERpdik7XG4gICAgcHggPSBfdGVtcERpdlttZWFzdXJlUHJvcGVydHldO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChfdGVtcERpdik7XG4gICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICBpZiAoaG9yaXpvbnRhbCAmJiB0b1BlcmNlbnQpIHtcbiAgICAgIGNhY2hlID0gX2dldENhY2hlKHBhcmVudCk7XG4gICAgICBjYWNoZS50aW1lID0gX3RpY2tlci50aW1lO1xuICAgICAgY2FjaGUud2lkdGggPSBwYXJlbnRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX3JvdW5kKHRvUGl4ZWxzID8gcHggKiBjdXJWYWx1ZSAvIGFtb3VudCA6IHB4ICYmIGN1clZhbHVlID8gYW1vdW50IC8gcHggKiBjdXJWYWx1ZSA6IDApO1xufSxcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gIHZhciB2YWx1ZTtcbiAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG5cbiAgaWYgKHByb3BlcnR5IGluIF9wcm9wZXJ0eUFsaWFzZXMgJiYgcHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xuXG4gICAgaWYgKH5wcm9wZXJ0eS5pbmRleE9mKFwiLFwiKSkge1xuICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdChcIixcIilbMF07XG4gICAgfVxuICB9XG5cbiAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wZXJ0eV0gJiYgcHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICB2YWx1ZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHVuY2FjaGUpO1xuICAgIHZhbHVlID0gcHJvcGVydHkgIT09IFwidHJhbnNmb3JtT3JpZ2luXCIgPyB2YWx1ZVtwcm9wZXJ0eV0gOiB2YWx1ZS5zdmcgPyB2YWx1ZS5vcmlnaW4gOiBfZmlyc3RUd29Pbmx5KF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApKSArIFwiIFwiICsgdmFsdWUuek9yaWdpbiArIFwicHhcIjtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV07XG5cbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09PSBcImF1dG9cIiB8fCB1bmNhY2hlIHx8IH4odmFsdWUgKyBcIlwiKS5pbmRleE9mKFwiY2FsYyhcIikpIHtcbiAgICAgIHZhbHVlID0gX3NwZWNpYWxQcm9wc1twcm9wZXJ0eV0gJiYgX3NwZWNpYWxQcm9wc1twcm9wZXJ0eV0odGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCkgfHwgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkgfHwgX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IChwcm9wZXJ0eSA9PT0gXCJvcGFjaXR5XCIgPyAxIDogMCk7IC8vIG5vdGU6IHNvbWUgYnJvd3NlcnMsIGxpa2UgRmlyZWZveCwgZG9uJ3QgcmVwb3J0IGJvcmRlclJhZGl1cyBjb3JyZWN0bHkhIEluc3RlYWQsIGl0IG9ubHkgcmVwb3J0cyBldmVyeSBjb3JuZXIgbGlrZSAgYm9yZGVyVG9wTGVmdFJhZGl1c1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bml0ICYmICF+KHZhbHVlICsgXCJcIikudHJpbSgpLmluZGV4T2YoXCIgXCIpID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpICsgdW5pdCA6IHZhbHVlO1xufSxcbiAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nID0gZnVuY3Rpb24gX3R3ZWVuQ29tcGxleENTU1N0cmluZyh0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQpIHtcbiAgLy8gbm90ZTogd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA9PT0gXCJub25lXCIpIHtcbiAgICAvLyBzb21lIGJyb3dzZXJzIGxpa2UgU2FmYXJpIGFjdHVhbGx5IFBSRUZFUiB0aGUgcHJlZml4ZWQgcHJvcGVydHkgYW5kIG1pcy1yZXBvcnQgdGhlIHVucHJlZml4ZWQgdmFsdWUgbGlrZSBjbGlwUGF0aCAoQlVHKS4gSW4gb3RoZXIgd29yZHMsIGV2ZW4gdGhvdWdoIGNsaXBQYXRoIGV4aXN0cyBpbiB0aGUgc3R5bGUgKFwiY2xpcFBhdGhcIiBpbiB0YXJnZXQuc3R5bGUpIGFuZCBpdCdzIHNldCBpbiB0aGUgQ1NTIHByb3Blcmx5IChhbG9uZyB3aXRoIC13ZWJraXQtY2xpcC1wYXRoKSwgU2FmYXJpIHJlcG9ydHMgY2xpcFBhdGggYXMgXCJub25lXCIgd2hlcmVhcyBXZWJraXRDbGlwUGF0aCByZXBvcnRzIGFjY3VyYXRlbHkgbGlrZSBcImVsbGlwc2UoMTAwJSAwJSBhdCA1MCUgMCUpXCIsIHNvIGluIHRoaXMgY2FzZSB3ZSBtdXN0IFNXSVRDSCB0byB1c2luZyB0aGUgcHJlZml4ZWQgcHJvcGVydHkgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMTgzMTAtY2xpcHBhdGgtZG9lc250LXdvcmstb24taW9zL1xuICAgIHZhciBwID0gX2NoZWNrUHJvcFByZWZpeChwcm9wLCB0YXJnZXQsIDEpLFxuICAgICAgICBzID0gcCAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHAsIDEpO1xuXG4gICAgaWYgKHMgJiYgcyAhPT0gc3RhcnQpIHtcbiAgICAgIHByb3AgPSBwO1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG4gICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVmFsdWVzO1xuICBwdC5iID0gc3RhcnQ7XG4gIHB0LmUgPSBlbmQ7XG4gIHN0YXJ0ICs9IFwiXCI7IC8vIGVuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcblxuICBlbmQgKz0gXCJcIjtcblxuICBpZiAoZW5kID09PSBcImF1dG9cIikge1xuICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IGVuZDtcbiAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHx8IGVuZDtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydDtcbiAgfVxuXG4gIGEgPSBbc3RhcnQsIGVuZF07XG5cbiAgX2NvbG9yU3RyaW5nRmlsdGVyKGEpOyAvLyBwYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLiBJZiBjb2xvcnMgYXJlIGZvdW5kLCBpdCByZXR1cm5zIHRydWUgYW5kIHRoZW4gd2UgbXVzdCBtYXRjaCB3aGVyZSB0aGUgY29sb3Igc2hvd3MgdXAgb3JkZXItd2lzZSBiZWNhdXNlIGZvciB0aGluZ3MgbGlrZSBib3hTaGFkb3csIHNvbWV0aW1lcyB0aGUgYnJvd3NlciBwcm92aWRlcyB0aGUgY29tcHV0ZWQgdmFsdWVzIHdpdGggdGhlIGNvbG9yIEZJUlNULCBidXQgdGhlIHVzZXIgcHJvdmlkZXMgaXQgd2l0aCB0aGUgY29sb3IgTEFTVCwgc28gZmxpcCB0aGVtIGlmIG5lY2Vzc2FyeS4gU2FtZSBmb3IgZHJvcC1zaGFkb3coKS5cblxuXG4gIHN0YXJ0ID0gYVswXTtcbiAgZW5kID0gYVsxXTtcbiAgc3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICBpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xuICAgIHdoaWxlIChyZXN1bHQgPSBfbnVtV2l0aFVuaXRFeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIgfHwgY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJoc2xhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZhbHVlICE9PSAoc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzW21hdGNoSW5kZXgrK10gfHwgXCJcIikpIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG4gICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgKGVuZFZhbHVlID0gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZFZhbHVlKSArIHN0YXJ0VW5pdCk7XG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBpbmRleCA9IF9udW1XaXRoVW5pdEV4cC5sYXN0SW5kZXggLSBlbmRVbml0Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIWVuZFVuaXQpIHtcbiAgICAgICAgICAvL2lmIHNvbWV0aGluZyBsaWtlIFwicGVyc3BlY3RpdmU6MzAwXCIgaXMgcGFzc2VkIGluIGFuZCB3ZSBtdXN0IGFkZCBhIHVuaXQgdG8gdGhlIGVuZFxuICAgICAgICAgIGVuZFVuaXQgPSBlbmRVbml0IHx8IF9jb25maWcudW5pdHNbcHJvcF0gfHwgc3RhcnRVbml0O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgKz0gZW5kVW5pdDtcbiAgICAgICAgICAgIHB0LmUgKz0gZW5kVW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgIH0gLy8gdGhlc2UgbmVzdGVkIFByb3BUd2VlbnMgYXJlIGhhbmRsZWQgaW4gYSBzcGVjaWFsIHdheSAtIHdlJ2xsIG5ldmVyIGFjdHVhbGx5IGNhbGwgYSByZW5kZXIgb3Igc2V0dGVyIG1ldGhvZCBvbiB0aGVtLiBXZSdsbCBqdXN0IGxvb3AgdGhyb3VnaCB0aGVtIGluIHRoZSBwYXJlbnQgY29tcGxleCBzdHJpbmcgUHJvcFR3ZWVuJ3MgcmVuZGVyIG1ldGhvZC5cblxuXG4gICAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgICBfbmV4dDogcHQuX3B0LFxuICAgICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAgIC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuICAgICAgICAgIHM6IHN0YXJ0TnVtLFxuICAgICAgICAgIGM6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgX3JlbEV4cC50ZXN0KGVuZCkgJiYgKHB0LmUgPSAwKTsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1XG4gICAgICBhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG4gICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB4T3JpZ2luID0geDtcbiAgICB5T3JpZ2luID0geTtcbiAgfVxuXG4gIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgIHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG4gICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIH1cblxuICBjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICBjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjsgLy9vdGhlcndpc2UsIGlmIHNvbWVvbmUgc2V0cyAgYW4gb3JpZ2luIHZpYSBDU1MsIGl0IHdpbGwgbGlrZWx5IGludGVyZmVyZSB3aXRoIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvbmVzIChiZWNhdXNlIHJlbWVtYmVyLCB3ZSdyZSBiYWtpbmcgdGhlIG9yaWdpbiBpbnRvIHRoZSBtYXRyaXgoKSB2YWx1ZSkuXG5cbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xufSxcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcbiAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIHQxID0gKCFjYWNoZS51bmNhY2hlIHx8IG9yaWdpbiA9PT0gXCIwcHggMHB4XCIpICYmICF1bmNhY2hlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7IC8vIGlmIG9yaWdpbiBpcyAwLDAgYW5kIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSwgbGV0IHRoZSByZWNvcmRlZCBkYXRhLXN2Zy1vcmlnaW4gc3RheS4gT3RoZXJ3aXNlLCB3aGVuZXZlciB3ZSBzZXQgY2FjaGUudW5jYWNoZSB0byB0cnVlLCB3ZSdkIG5lZWQgdG8gc2V0IGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gKGNhY2hlLnhPcmlnaW4gLSBiYm94LngpICsgXCJweCBcIiArIChjYWNoZS55T3JpZ2luIC0gYmJveC55KSArIFwicHhcIi4gUmVtZW1iZXIsIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIHdlIGFsd2F5cyBmb3JjZSBTVkcgZWxlbWVudHMnIHRyYW5zZm9ybU9yaWdpbiB0byAwLDAgYW5kIG9mZnNldCB0aGUgdHJhbnNsYXRpb24gYWNjb3JkaW5nbHkuXG5cbiAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCB0MSB8fCBvcmlnaW4sICEhdDEgfHwgY2FjaGUub3JpZ2luSXNBYnNvbHV0ZSwgY2FjaGUuc21vb3RoICE9PSBmYWxzZSwgbWF0cml4KTtcbiAgfVxuXG4gIHhPcmlnaW4gPSBjYWNoZS54T3JpZ2luIHx8IDA7XG4gIHlPcmlnaW4gPSBjYWNoZS55T3JpZ2luIHx8IDA7XG5cbiAgaWYgKG1hdHJpeCAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHtcbiAgICBhID0gbWF0cml4WzBdOyAvL2ExMVxuXG4gICAgYiA9IG1hdHJpeFsxXTsgLy9hMjFcblxuICAgIGMgPSBtYXRyaXhbMl07IC8vYTMxXG5cbiAgICBkID0gbWF0cml4WzNdOyAvL2E0MVxuXG4gICAgeCA9IGExMiA9IG1hdHJpeFs0XTtcbiAgICB5ID0gYTIyID0gbWF0cml4WzVdOyAvLzJEIG1hdHJpeFxuXG4gICAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgIHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcbiAgICAgIHJvdGF0aW9uID0gYSB8fCBiID8gX2F0YW4yKGIsIGEpICogX1JBRDJERUcgOiAwOyAvL25vdGU6IGlmIHNjYWxlWCBpcyAwLCB3ZSBjYW5ub3QgYWNjdXJhdGVseSBtZWFzdXJlIHJvdGF0aW9uLiBTYW1lIGZvciBza2V3WCB3aXRoIGEgc2NhbGVZIG9mIDAuIFRoZXJlZm9yZSwgd2UgZGVmYXVsdCB0byB0aGUgcHJldmlvdXNseSByZWNvcmRlZCB2YWx1ZSAob3IgemVybyBpZiB0aGF0IGRvZXNuJ3QgZXhpc3QpLlxuXG4gICAgICBza2V3WCA9IGMgfHwgZCA/IF9hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiAwO1xuICAgICAgc2tld1ggJiYgKHNjYWxlWSAqPSBNYXRoLmFicyhNYXRoLmNvcyhza2V3WCAqIF9ERUcyUkFEKSkpO1xuXG4gICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgIHggLT0geE9yaWdpbiAtICh4T3JpZ2luICogYSArIHlPcmlnaW4gKiBjKTtcbiAgICAgICAgeSAtPSB5T3JpZ2luIC0gKHhPcmlnaW4gKiBiICsgeU9yaWdpbiAqIGQpO1xuICAgICAgfSAvLzNEIG1hdHJpeFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGEzMiA9IG1hdHJpeFs2XTtcbiAgICAgIGE0MiA9IG1hdHJpeFs3XTtcbiAgICAgIGExMyA9IG1hdHJpeFs4XTtcbiAgICAgIGEyMyA9IG1hdHJpeFs5XTtcbiAgICAgIGEzMyA9IG1hdHJpeFsxMF07XG4gICAgICBhNDMgPSBtYXRyaXhbMTFdO1xuICAgICAgeCA9IG1hdHJpeFsxMl07XG4gICAgICB5ID0gbWF0cml4WzEzXTtcbiAgICAgIHogPSBtYXRyaXhbMTRdO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTMyLCBhMzMpO1xuICAgICAgcm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRzsgLy9yb3RhdGlvblhcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYTEyICogY29zICsgYTEzICogc2luO1xuICAgICAgICB0MiA9IGEyMiAqIGNvcyArIGEyMyAqIHNpbjtcbiAgICAgICAgdDMgPSBhMzIgKiBjb3MgKyBhMzMgKiBzaW47XG4gICAgICAgIGExMyA9IGExMiAqIC1zaW4gKyBhMTMgKiBjb3M7XG4gICAgICAgIGEyMyA9IGEyMiAqIC1zaW4gKyBhMjMgKiBjb3M7XG4gICAgICAgIGEzMyA9IGEzMiAqIC1zaW4gKyBhMzMgKiBjb3M7XG4gICAgICAgIGE0MyA9IGE0MiAqIC1zaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGExMiA9IHQxO1xuICAgICAgICBhMjIgPSB0MjtcbiAgICAgICAgYTMyID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25ZXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoLWMsIGEzMyk7XG4gICAgICByb3RhdGlvblkgPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zIC0gYTEzICogc2luO1xuICAgICAgICB0MiA9IGIgKiBjb3MgLSBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYyAqIGNvcyAtIGEzMyAqIHNpbjtcbiAgICAgICAgYTQzID0gZCAqIHNpbiArIGE0MyAqIGNvcztcbiAgICAgICAgYSA9IHQxO1xuICAgICAgICBiID0gdDI7XG4gICAgICAgIGMgPSB0MztcbiAgICAgIH0gLy9yb3RhdGlvblpcblxuXG4gICAgICBhbmdsZSA9IF9hdGFuMihiLCBhKTtcbiAgICAgIHJvdGF0aW9uID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB0MSA9IGEgKiBjb3MgKyBiICogc2luO1xuICAgICAgICB0MiA9IGExMiAqIGNvcyArIGEyMiAqIHNpbjtcbiAgICAgICAgYiA9IGIgKiBjb3MgLSBhICogc2luO1xuICAgICAgICBhMjIgPSBhMjIgKiBjb3MgLSBhMTIgKiBzaW47XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYTEyID0gdDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3RhdGlvblggJiYgTWF0aC5hYnMocm90YXRpb25YKSArIE1hdGguYWJzKHJvdGF0aW9uKSA+IDM1OS45KSB7XG4gICAgICAgIC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuICAgICAgICByb3RhdGlvblggPSByb3RhdGlvbiA9IDA7XG4gICAgICAgIHJvdGF0aW9uWSA9IDE4MCAtIHJvdGF0aW9uWTtcbiAgICAgIH1cblxuICAgICAgc2NhbGVYID0gX3JvdW5kKE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpKTtcbiAgICAgIHNjYWxlWSA9IF9yb3VuZChNYXRoLnNxcnQoYTIyICogYTIyICsgYTMyICogYTMyKSk7XG4gICAgICBhbmdsZSA9IF9hdGFuMihhMTIsIGEyMik7XG4gICAgICBza2V3WCA9IE1hdGguYWJzKGFuZ2xlKSA+IDAuMDAwMiA/IGFuZ2xlICogX1JBRDJERUcgOiAwO1xuICAgICAgcGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKGE0MyA8IDAgPyAtYTQzIDogYTQzKSA6IDA7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgLy9zZW5zZSBpZiB0aGVyZSBhcmUgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvbiBhbiBTVkcgZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gd2hlbiByZW5kZXJpbmcuIFRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlzIG1vcmUgcmVsaWFibGUgY3Jvc3MtYnJvd3NlciwgYnV0IHdlIGNhbid0IGp1c3QgcmVtb3ZlIHRoZSBDU1Mgb25lcyBiZWNhdXNlIHRoZXkgbWF5IGJlIGFwcGxpZWQgaW4gYSBDU1MgcnVsZSBzb21ld2hlcmUgKG5vdCBqdXN0IGlubGluZSkuXG4gICAgICB0MSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICBjYWNoZS5mb3JjZUNTUyA9IHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIikgfHwgIV9pc051bGxUcmFuc2Zvcm0oX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCkpO1xuICAgICAgdDEgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0MSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKE1hdGguYWJzKHNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHNrZXdYKSA8IDI3MCkge1xuICAgIGlmIChpbnZlcnRlZFNjYWxlWCkge1xuICAgICAgc2NhbGVYICo9IC0xO1xuICAgICAgc2tld1ggKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgICByb3RhdGlvbiArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVZICo9IC0xO1xuICAgICAgc2tld1ggKz0gc2tld1ggPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfVxuICB9XG5cbiAgdW5jYWNoZSA9IHVuY2FjaGUgfHwgY2FjaGUudW5jYWNoZTtcbiAgY2FjaGUueCA9IHggLSAoKGNhY2hlLnhQZXJjZW50ID0geCAmJiAoIXVuY2FjaGUgJiYgY2FjaGUueFBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldFdpZHRoIC8gMikgPT09IE1hdGgucm91bmQoLXgpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRXaWR0aCAqIGNhY2hlLnhQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueSA9IHkgLSAoKGNhY2hlLnlQZXJjZW50ID0geSAmJiAoIXVuY2FjaGUgJiYgY2FjaGUueVBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldEhlaWdodCAvIDIpID09PSBNYXRoLnJvdW5kKC15KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0SGVpZ2h0ICogY2FjaGUueVBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuICBjYWNoZS56ID0geiArIHB4O1xuICBjYWNoZS5zY2FsZVggPSBfcm91bmQoc2NhbGVYKTtcbiAgY2FjaGUuc2NhbGVZID0gX3JvdW5kKHNjYWxlWSk7XG4gIGNhY2hlLnJvdGF0aW9uID0gX3JvdW5kKHJvdGF0aW9uKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25YID0gX3JvdW5kKHJvdGF0aW9uWCkgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWSA9IF9yb3VuZChyb3RhdGlvblkpICsgZGVnO1xuICBjYWNoZS5za2V3WCA9IHNrZXdYICsgZGVnO1xuICBjYWNoZS5za2V3WSA9IHNrZXdZICsgZGVnO1xuICBjYWNoZS50cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlICsgcHg7XG5cbiAgaWYgKGNhY2hlLnpPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpbi5zcGxpdChcIiBcIilbMl0pIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcbiAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTsgLy9zb21lIGJyb3dzZXJzIHByaW9yaXRpemUgQ1NTIHRyYW5zZm9ybXMgb3ZlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS4gV2hlbiB3ZSBzZW5zZSB0aGF0IHRoZSB1c2VyIGhhcyBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkLCB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHRoaXMgd2F5IChvdGhlcndpc2Ugc29tZSBicm93c2VyIHNpbXBseSB3b24ndCByZW5kZXIgdGhlICB0cmFuc2Zvcm0gYXR0cmlidXRlIGNoYW5nZXMhKVxufSxcbiAgICBfYWRkUm90YXRpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGVuZFZhbHVlKSB7XG4gIHZhciBjYXAgPSAzNjAsXG4gICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKSAqIChpc1N0cmluZyAmJiB+ZW5kVmFsdWUuaW5kZXhPZihcInJhZFwiKSA/IF9SQUQyREVHIDogMSksXG4gICAgICBjaGFuZ2UgPSBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBwdDtcblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBkaXJlY3Rpb24gPSBlbmRWYWx1ZS5zcGxpdChcIl9cIilbMV07XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInNob3J0XCIpIHtcbiAgICAgIGNoYW5nZSAlPSBjYXA7XG5cbiAgICAgIGlmIChjaGFuZ2UgIT09IGNoYW5nZSAlIChjYXAgLyAyKSkge1xuICAgICAgICBjaGFuZ2UgKz0gY2hhbmdlIDwgMCA/IGNhcCA6IC1jYXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJjd1wiICYmIGNoYW5nZSA8IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgKyBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiY2N3XCIgJiYgY2hhbmdlID4gMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9XG4gIH1cblxuICBwbHVnaW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBjaGFuZ2UsIF9yZW5kZXJQcm9wV2l0aEVuZCk7XG4gIHB0LmUgPSBmaW5hbFZhbHVlO1xuICBwdC51ID0gXCJkZWdcIjtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2Fzc2lnbiA9IGZ1bmN0aW9uIF9hc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCBoYXZlIE9iamVjdC5hc3NpZ24oKSwgc28gd2UgcmVjcmVhdGUgaXQgaGVyZS5cbiAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICB0YXJnZXRbcF0gPSBzb3VyY2VbcF07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSxcbiAgICBfYWRkUmF3VHJhbnNmb3JtUFRzID0gZnVuY3Rpb24gX2FkZFJhd1RyYW5zZm9ybVBUcyhwbHVnaW4sIHRyYW5zZm9ybXMsIHRhcmdldCkge1xuICAvL2ZvciBoYW5kbGluZyBjYXNlcyB3aGVyZSBzb21lb25lIHBhc3NlcyBpbiBhIHdob2xlIHRyYW5zZm9ybSBzdHJpbmcsIGxpa2UgdHJhbnNmb3JtOiBcInNjYWxlKDIsIDMpIHJvdGF0ZSgyMGRlZykgdHJhbnNsYXRlWSgzMGVtKVwiXG4gIHZhciBzdGFydENhY2hlID0gX2Fzc2lnbih7fSwgdGFyZ2V0Ll9nc2FwKSxcbiAgICAgIGV4Y2x1ZGUgPSBcInBlcnNwZWN0aXZlLGZvcmNlM0QsdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpblwiLFxuICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBlbmRDYWNoZSxcbiAgICAgIHAsXG4gICAgICBzdGFydFZhbHVlLFxuICAgICAgZW5kVmFsdWUsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGVuZE51bSxcbiAgICAgIHN0YXJ0VW5pdCxcbiAgICAgIGVuZFVuaXQ7XG5cbiAgaWYgKHN0YXJ0Q2FjaGUuc3ZnKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIlwiKTtcbiAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuICAgIGVuZENhY2hlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG5cbiAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0YXJ0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0VmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldClbX3RyYW5zZm9ybVByb3BdO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcbiAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBzdGFydFZhbHVlO1xuICB9XG5cbiAgZm9yIChwIGluIF90cmFuc2Zvcm1Qcm9wcykge1xuICAgIHN0YXJ0VmFsdWUgPSBzdGFydENhY2hlW3BdO1xuICAgIGVuZFZhbHVlID0gZW5kQ2FjaGVbcF07XG5cbiAgICBpZiAoc3RhcnRWYWx1ZSAhPT0gZW5kVmFsdWUgJiYgZXhjbHVkZS5pbmRleE9mKHApIDwgMCkge1xuICAgICAgLy90d2VlbmluZyB0byBubyBwZXJzcGVjdGl2ZSBnaXZlcyB2ZXJ5IHVuaW50dWl0aXZlIHJlc3VsdHMgLSBqdXN0IGtlZXAgdGhlIHNhbWUgcGVyc3BlY3RpdmUgaW4gdGhhdCBjYXNlLlxuICAgICAgc3RhcnRVbml0ID0gZ2V0VW5pdChzdGFydFZhbHVlKTtcbiAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgIHN0YXJ0TnVtID0gc3RhcnRVbml0ICE9PSBlbmRVbml0ID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSA6IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgIHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIGVuZENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgIHBsdWdpbi5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxuXG4gIF9hc3NpZ24oZW5kQ2FjaGUsIHN0YXJ0Q2FjaGUpO1xufTsgLy8gaGFuZGxlIHNwbGl0dGluZyBhcGFydCBwYWRkaW5nLCBtYXJnaW4sIGJvcmRlcldpZHRoLCBhbmQgYm9yZGVyUmFkaXVzIGludG8gdGhlaXIgNCBjb21wb25lbnRzLiBGaXJlZm94LCBmb3IgZXhhbXBsZSwgd29uJ3QgcmVwb3J0IGJvcmRlclJhZGl1cyBjb3JyZWN0bHkgLSBpdCB3aWxsIG9ubHkgZG8gYm9yZGVyVG9wTGVmdFJhZGl1cyBhbmQgdGhlIG90aGVyIGNvcm5lcnMuIFdlIGFsc28gd2FudCB0byBoYW5kbGUgcGFkZGluZ1RvcCwgbWFyZ2luTGVmdCwgYm9yZGVyUmlnaHRXaWR0aCwgZXRjLlxuXG5cbl9mb3JFYWNoTmFtZShcInBhZGRpbmcsbWFyZ2luLFdpZHRoLFJhZGl1c1wiLCBmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgdmFyIHQgPSBcIlRvcFwiLFxuICAgICAgciA9IFwiUmlnaHRcIixcbiAgICAgIGIgPSBcIkJvdHRvbVwiLFxuICAgICAgbCA9IFwiTGVmdFwiLFxuICAgICAgcHJvcHMgPSAoaW5kZXggPCAzID8gW3QsIHIsIGIsIGxdIDogW3QgKyBsLCB0ICsgciwgYiArIHIsIGIgKyBsXSkubWFwKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIGluZGV4IDwgMiA/IG5hbWUgKyBzaWRlIDogXCJib3JkZXJcIiArIHNpZGUgKyBuYW1lO1xuICB9KTtcblxuICBfc3BlY2lhbFByb3BzW2luZGV4ID4gMSA/IFwiYm9yZGVyXCIgKyBuYW1lIDogbmFtZV0gPSBmdW5jdGlvbiAocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICB2YXIgYSwgdmFycztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkge1xuICAgICAgLy8gZ2V0dGVyLCBwYXNzZWQgdGFyZ2V0LCBwcm9wZXJ0eSwgYW5kIHVuaXQgKGZyb20gX2dldCgpKVxuICAgICAgYSA9IHByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gX2dldChwbHVnaW4sIHByb3AsIHByb3BlcnR5KTtcbiAgICAgIH0pO1xuICAgICAgdmFycyA9IGEuam9pbihcIiBcIik7XG4gICAgICByZXR1cm4gdmFycy5zcGxpdChhWzBdKS5sZW5ndGggPT09IDUgPyBhWzBdIDogdmFycztcbiAgICB9XG5cbiAgICBhID0gKGVuZFZhbHVlICsgXCJcIikuc3BsaXQoXCIgXCIpO1xuICAgIHZhcnMgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICByZXR1cm4gdmFyc1twcm9wXSA9IGFbaV0gPSBhW2ldIHx8IGFbKGkgLSAxKSAvIDIgfCAwXTtcbiAgICB9KTtcbiAgICBwbHVnaW4uaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKTtcbiAgfTtcbn0pO1xuXG5leHBvcnQgdmFyIENTU1BsdWdpbiA9IHtcbiAgbmFtZTogXCJjc3NcIixcbiAgcmVnaXN0ZXI6IF9pbml0Q29yZSxcbiAgdGFyZ2V0VGVzdDogZnVuY3Rpb24gdGFyZ2V0VGVzdCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnN0eWxlICYmIHRhcmdldC5ub2RlVHlwZTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzLFxuICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgc3RhcnRBdCA9IHR3ZWVuLnZhcnMuc3RhcnRBdCxcbiAgICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgICAgZW5kVmFsdWUsXG4gICAgICAgIGVuZE51bSxcbiAgICAgICAgc3RhcnROdW0sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHNwZWNpYWxQcm9wLFxuICAgICAgICBwLFxuICAgICAgICBzdGFydFVuaXQsXG4gICAgICAgIGVuZFVuaXQsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQsXG4gICAgICAgIHRyYW5zZm9ybVByb3BUd2VlbixcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIHNtb290aCxcbiAgICAgICAgaGFzUHJpb3JpdHk7XG4gICAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG5cbiAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgaWYgKHAgPT09IFwiYXV0b1JvdW5kXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGVuZFZhbHVlID0gdmFyc1twXTtcblxuICAgICAgaWYgKF9wbHVnaW5zW3BdICYmIF9jaGVja1BsdWdpbihwLCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpIHtcbiAgICAgICAgLy8gcGx1Z2luc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIHNwZWNpYWxQcm9wID0gX3NwZWNpYWxQcm9wc1twXTtcblxuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICAgICAgICB0eXBlID0gdHlwZW9mIGVuZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiB+ZW5kVmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBfcmVwbGFjZVJhbmRvbShlbmRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVjaWFsUHJvcCkge1xuICAgICAgICBzcGVjaWFsUHJvcCh0aGlzLCB0YXJnZXQsIHAsIGVuZFZhbHVlLCB0d2VlbikgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XG4gICAgICB9IGVsc2UgaWYgKHAuc3Vic3RyKDAsIDIpID09PSBcIi0tXCIpIHtcbiAgICAgICAgLy9DU1MgdmFyaWFibGVcbiAgICAgICAgc3RhcnRWYWx1ZSA9IChnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwKSArIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgZW5kVmFsdWUgKz0gXCJcIjtcbiAgICAgICAgX2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgICAgaWYgKCFfY29sb3JFeHAudGVzdChzdGFydFZhbHVlKSkge1xuICAgICAgICAgIC8vIGNvbG9ycyBkb24ndCBoYXZlIHVuaXRzXG4gICAgICAgICAgc3RhcnRVbml0ID0gZ2V0VW5pdChzdGFydFZhbHVlKTtcbiAgICAgICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbmRVbml0ID8gc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydFZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSArIGVuZFVuaXQpIDogc3RhcnRVbml0ICYmIChlbmRWYWx1ZSArPSBzdGFydFVuaXQpO1xuICAgICAgICB0aGlzLmFkZChzdHlsZSwgXCJzZXRQcm9wZXJ0eVwiLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgaW5kZXgsIHRhcmdldHMsIDAsIDAsIHApO1xuICAgICAgICBwcm9wcy5wdXNoKHApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChzdGFydEF0ICYmIHAgaW4gc3RhcnRBdCkge1xuICAgICAgICAgIC8vIGluIGNhc2Ugc29tZW9uZSBoYXJkLWNvZGVzIGEgY29tcGxleCB2YWx1ZSBhcyB0aGUgc3RhcnQsIGxpa2UgdG9wOiBcImNhbGMoMnZoIC8gMilcIi4gV2l0aG91dCB0aGlzLCBpdCdkIHVzZSB0aGUgY29tcHV0ZWQgdmFsdWUgKGFsd2F5cyBpbiBweClcbiAgICAgICAgICBzdGFydFZhbHVlID0gdHlwZW9mIHN0YXJ0QXRbcF0gPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QXRbcF0uY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiBzdGFydEF0W3BdO1xuICAgICAgICAgIF9pc1N0cmluZyhzdGFydFZhbHVlKSAmJiB+c3RhcnRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSAmJiAoc3RhcnRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKHN0YXJ0VmFsdWUpKTtcbiAgICAgICAgICBnZXRVbml0KHN0YXJ0VmFsdWUgKyBcIlwiKSB8fCAoc3RhcnRWYWx1ZSArPSBfY29uZmlnLnVuaXRzW3BdIHx8IGdldFVuaXQoX2dldCh0YXJnZXQsIHApKSB8fCBcIlwiKTsgLy8gZm9yIGNhc2VzIHdoZW4gc29tZW9uZSBwYXNzZXMgaW4gYSB1bml0bGVzcyB2YWx1ZSBsaWtlIHt4OiAxMDB9OyBpZiB3ZSB0cnkgc2V0dGluZyB0cmFuc2xhdGUoMTAwLCAwcHgpIGl0IHdvbid0IHdvcmsuXG5cbiAgICAgICAgICAoc3RhcnRWYWx1ZSArIFwiXCIpLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgKHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCkpOyAvLyBjYW4ndCB3b3JrIHdpdGggcmVsYXRpdmUgdmFsdWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgICAgcmVsYXRpdmUgPSB0eXBlID09PSBcInN0cmluZ1wiICYmIGVuZFZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgZW5kVmFsdWUuc3Vic3RyKDAsIDIpO1xuICAgICAgICByZWxhdGl2ZSAmJiAoZW5kVmFsdWUgPSBlbmRWYWx1ZS5zdWJzdHIoMikpO1xuICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcblxuICAgICAgICBpZiAocCBpbiBfcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgICAgICAgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcbiAgICAgICAgICAgIC8vc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgYWxvbmcgd2l0aCBvcGFjaXR5LiBXZSBzdGlsbCBhbGxvdyB0aGUgb3BhY2l0eSB2YWx1ZSB0byBwYXNzIHRocm91Z2ggYW5kIGdldCB0d2VlbmVkLlxuICAgICAgICAgICAgaWYgKHN0YXJ0TnVtID09PSAxICYmIF9nZXQodGFyZ2V0LCBcInZpc2liaWxpdHlcIikgPT09IFwiaGlkZGVuXCIgJiYgZW5kTnVtKSB7XG4gICAgICAgICAgICAgIC8vaWYgdmlzaWJpbGl0eSBpcyBpbml0aWFsbHkgc2V0IHRvIFwiaGlkZGVuXCIsIHdlIHNob3VsZCBpbnRlcnByZXQgdGhhdCBhcyBpbnRlbnQgdG8gbWFrZSBvcGFjaXR5IDAgKGEgY29udmVuaWVuY2UpXG4gICAgICAgICAgICAgIHN0YXJ0TnVtID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIFwidmlzaWJpbGl0eVwiLCBzdGFydE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgZW5kTnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCAhZW5kTnVtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCAhPT0gXCJzY2FsZVwiICYmIHAgIT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIHAgPSBfcHJvcGVydHlBbGlhc2VzW3BdO1xuICAgICAgICAgICAgfnAuaW5kZXhPZihcIixcIikgJiYgKHAgPSBwLnNwbGl0KFwiLFwiKVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkID0gcCBpbiBfdHJhbnNmb3JtUHJvcHM7IC8vLS0tIFRSQU5TRk9STS1SRUxBVEVEIC0tLVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQpIHtcbiAgICAgICAgICBpZiAoIXRyYW5zZm9ybVByb3BUd2Vlbikge1xuICAgICAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gICAgICAgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gJiYgIXZhcnMucGFyc2VUcmFuc2Zvcm0gfHwgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdmFycy5wYXJzZVRyYW5zZm9ybSk7IC8vIGlmLCBmb3IgZXhhbXBsZSwgZ3NhcC5zZXQoLi4uIHt0cmFuc2Zvcm06XCJ0cmFuc2xhdGVYKDUwdncpXCJ9KSwgdGhlIF9nZXQoKSBjYWxsIGRvZXNuJ3QgcGFyc2UgdGhlIHRyYW5zZm9ybSwgdGh1cyBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gd29uJ3QgYmUgc2V0IHlldCBzbyBmb3JjZSB0aGUgcGFyc2luZyBvZiB0aGUgdHJhbnNmb3JtIGhlcmUuXG5cbiAgICAgICAgICAgIHNtb290aCA9IHZhcnMuc21vb3RoT3JpZ2luICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGg7XG4gICAgICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4gPSB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHN0eWxlLCBfdHJhbnNmb3JtUHJvcCwgMCwgMSwgY2FjaGUucmVuZGVyVHJhbnNmb3JtLCBjYWNoZSwgMCwgLTEpOyAvL3RoZSBmaXJzdCB0aW1lIHRocm91Z2gsIGNyZWF0ZSB0aGUgcmVuZGVyaW5nIFByb3BUd2VlbiBzbyB0aGF0IGl0IHJ1bnMgTEFTVCAoaW4gdGhlIGxpbmtlZCBsaXN0LCB3ZSBrZWVwIGFkZGluZyB0byB0aGUgYmVnaW5uaW5nKVxuXG4gICAgICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4uZGVwID0gMTsgLy9mbGFnIGl0IGFzIGRlcGVuZGVudCBzbyB0aGF0IGlmIHRoaW5ncyBnZXQga2lsbGVkL292ZXJ3cml0dGVuIGFuZCB0aGlzIGlzIHRoZSBvbmx5IFByb3BUd2VlbiBsZWZ0LCB3ZSBjYW4gc2FmZWx5IGtpbGwgdGhlIHdob2xlIHR3ZWVuLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwID09PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgY2FjaGUsIFwic2NhbGVZXCIsIGNhY2hlLnNjYWxlWSwgKHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoY2FjaGUuc2NhbGVZLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gY2FjaGUuc2NhbGVZIHx8IDApO1xuICAgICAgICAgICAgcHJvcHMucHVzaChcInNjYWxlWVwiLCBwKTtcbiAgICAgICAgICAgIHAgKz0gXCJYXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSB7XG4gICAgICAgICAgICBlbmRWYWx1ZSA9IF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKGVuZFZhbHVlKTsgLy9pbiBjYXNlIHNvbWV0aGluZyBsaWtlIFwibGVmdCB0b3BcIiBvciBcImJvdHRvbSByaWdodFwiIGlzIHBhc3NlZCBpbi4gQ29udmVydCB0byBwZXJjZW50YWdlcy5cblxuICAgICAgICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMCwgc21vb3RoLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZFVuaXQgPSBwYXJzZUZsb2F0KGVuZFZhbHVlLnNwbGl0KFwiIFwiKVsyXSkgfHwgMDsgLy9oYW5kbGUgdGhlIHpPcmlnaW4gc2VwYXJhdGVseSFcblxuICAgICAgICAgICAgICBlbmRVbml0ICE9PSBjYWNoZS56T3JpZ2luICYmIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInpPcmlnaW5cIiwgY2FjaGUuek9yaWdpbiwgZW5kVW5pdCk7XG5cbiAgICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIHAsIF9maXJzdFR3b09ubHkoc3RhcnRWYWx1ZSksIF9maXJzdFR3b09ubHkoZW5kVmFsdWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XG4gICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwIGluIF9yb3RhdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCByZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZFZhbHVlKSA6IGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInNtb290aE9yaWdpblwiKSB7XG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcbiAgICAgICAgICAgIGNhY2hlW3BdID0gZW5kVmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHModGhpcywgZW5kVmFsdWUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgcCA9IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIHAgaW4gc3R5bGUpIHtcbiAgICAgICAgICBzdGFydFVuaXQgPSAoc3RhcnRWYWx1ZSArIFwiXCIpLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICAgIGVuZE51bSB8fCAoZW5kTnVtID0gMCk7IC8vIHByb3RlY3QgYWdhaW5zdCBOYU5cblxuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKSB8fCAocCBpbiBfY29uZmlnLnVuaXRzID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG4gICAgICAgICAgc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkpO1xuICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gc3RhcnROdW0sICFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgdGhpcy5fcHQudSA9IGVuZFVuaXQgfHwgMDtcblxuICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgZW5kVW5pdCAhPT0gXCIlXCIpIHtcbiAgICAgICAgICAgIC8vd2hlbiB0aGUgdHdlZW4gZ29lcyBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmV2ZXJ0IGl0IHRvIHRoZSBPTEQvT1JJR0lOQUwgdmFsdWUgKHdpdGggdGhvc2UgdW5pdHMpLiBXZSByZWNvcmQgdGhhdCBhcyBhIFwiYlwiIChiZWdpbm5pbmcpIHByb3BlcnR5IGFuZCBwb2ludCB0byBhIHJlbmRlciBtZXRob2QgdGhhdCBoYW5kbGVzIHRoYXQuIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG4gICAgICAgICAgICB0aGlzLl9wdC5iID0gc3RhcnRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEocCBpbiBzdHlsZSkpIHtcbiAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vbWF5YmUgaXQncyBub3QgYSBzdHlsZSAtIGl0IGNvdWxkIGJlIGEgcHJvcGVydHkgYWRkZWQgZGlyZWN0bHkgdG8gYW4gZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlJ2xsIHRyeSB0byBhbmltYXRlIHRoYXQuXG4gICAgICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUgfHwgdGFyZ2V0W3BdLCByZWxhdGl2ZSA/IHJlbGF0aXZlICsgZW5kVmFsdWUgOiBlbmRWYWx1ZSwgaW5kZXgsIHRhcmdldHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfbWlzc2luZ1BsdWdpbihwLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBzdGFydFZhbHVlLCByZWxhdGl2ZSA/IHJlbGF0aXZlICsgZW5kVmFsdWUgOiBlbmRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodGhpcyk7XG4gIH0sXG4gIGdldDogX2dldCxcbiAgYWxpYXNlczogX3Byb3BlcnR5QWxpYXNlcyxcbiAgZ2V0U2V0dGVyOiBmdW5jdGlvbiBnZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSwgcGx1Z2luKSB7XG4gICAgLy9yZXR1cm5zIGEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSBhbmQgYXBwbGllcyBpdCBhY2NvcmRpbmdseS4gUmVtZW1iZXIsIHByb3BlcnRpZXMgbGlrZSBcInhcIiBhcmVuJ3QgYXMgc2ltcGxlIGFzIHRhcmdldC5zdHlsZS5wcm9wZXJ0eSA9IHZhbHVlIGJlY2F1c2UgdGhleSd2ZSBnb3QgdG8gYmUgYXBwbGllZCB0byBhIHByb3h5IG9iamVjdCBhbmQgdGhlbiBtZXJnZWQgaW50byBhIHRyYW5zZm9ybSBzdHJpbmcgaW4gYSByZW5kZXJlci5cbiAgICB2YXIgcCA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xuICAgIHAgJiYgcC5pbmRleE9mKFwiLFwiKSA8IDAgJiYgKHByb3BlcnR5ID0gcCk7XG4gICAgcmV0dXJuIHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3AgJiYgKHRhcmdldC5fZ3NhcC54IHx8IF9nZXQodGFyZ2V0LCBcInhcIikpID8gcGx1Z2luICYmIF9yZWNlbnRTZXR0ZXJQbHVnaW4gPT09IHBsdWdpbiA/IHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGUgOiBfc2V0dGVyVHJhbnNmb3JtIDogKF9yZWNlbnRTZXR0ZXJQbHVnaW4gPSBwbHVnaW4gfHwge30pICYmIChwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlV2l0aFJlbmRlciA6IF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKSA6IHRhcmdldC5zdHlsZSAmJiAhX2lzVW5kZWZpbmVkKHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0pID8gX3NldHRlckNTU1N0eWxlIDogfnByb3BlcnR5LmluZGV4T2YoXCItXCIpID8gX3NldHRlckNTU1Byb3AgOiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpO1xuICB9LFxuICBjb3JlOiB7XG4gICAgX3JlbW92ZVByb3BlcnR5OiBfcmVtb3ZlUHJvcGVydHksXG4gICAgX2dldE1hdHJpeDogX2dldE1hdHJpeFxuICB9XG59O1xuZ3NhcC51dGlscy5jaGVja1ByZWZpeCA9IF9jaGVja1Byb3BQcmVmaXg7XG5cbihmdW5jdGlvbiAocG9zaXRpb25BbmRTY2FsZSwgcm90YXRpb24sIG90aGVycywgYWxpYXNlcykge1xuICB2YXIgYWxsID0gX2ZvckVhY2hOYW1lKHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uICsgXCIsXCIgKyBvdGhlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX3RyYW5zZm9ybVByb3BzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX2ZvckVhY2hOYW1lKHJvdGF0aW9uLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF9jb25maWcudW5pdHNbbmFtZV0gPSBcImRlZ1wiO1xuICAgIF9yb3RhdGlvbmFsUHJvcGVydGllc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9wcm9wZXJ0eUFsaWFzZXNbYWxsWzEzXV0gPSBwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbjtcblxuICBfZm9yRWFjaE5hbWUoYWxpYXNlcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3BsaXQgPSBuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICBfcHJvcGVydHlBbGlhc2VzW3NwbGl0WzFdXSA9IGFsbFtzcGxpdFswXV07XG4gIH0pO1xufSkoXCJ4LHkseixzY2FsZSxzY2FsZVgsc2NhbGVZLHhQZXJjZW50LHlQZXJjZW50XCIsIFwicm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxza2V3WCxza2V3WVwiLCBcInRyYW5zZm9ybSx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLGZvcmNlM0Qsc21vb3RoT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsIFwiMDp0cmFuc2xhdGVYLDE6dHJhbnNsYXRlWSwyOnRyYW5zbGF0ZVosODpyb3RhdGUsODpyb3RhdGlvblosODpyb3RhdGVaLDk6cm90YXRlWCwxMDpyb3RhdGVZXCIpO1xuXG5fZm9yRWFjaE5hbWUoXCJ4LHkseix0b3AscmlnaHQsYm90dG9tLGxlZnQsd2lkdGgsaGVpZ2h0LGZvbnRTaXplLHBhZGRpbmcsbWFyZ2luLHBlcnNwZWN0aXZlXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIF9jb25maWcudW5pdHNbbmFtZV0gPSBcInB4XCI7XG59KTtcblxuZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pO1xuZXhwb3J0IHsgQ1NTUGx1Z2luIGFzIGRlZmF1bHQsIF9nZXRCQm94LCBfY3JlYXRlRWxlbWVudCwgX2NoZWNrUHJvcFByZWZpeCBhcyBjaGVja1ByZWZpeCB9OyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyohXG4gKiBHU0FQIDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfY29uZmlnID0ge1xuICBhdXRvU2xlZXA6IDEyMCxcbiAgZm9yY2UzRDogXCJhdXRvXCIsXG4gIG51bGxUYXJnZXRXYXJuOiAxLFxuICB1bml0czoge1xuICAgIGxpbmVIZWlnaHQ6IFwiXCJcbiAgfVxufSxcbiAgICBfZGVmYXVsdHMgPSB7XG4gIGR1cmF0aW9uOiAuNSxcbiAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgZGVsYXk6IDBcbn0sXG4gICAgX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG4gICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgIF9IQUxGX1BJID0gXzJQSSAvIDQsXG4gICAgX2dzSUQgPSAwLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9jb3MgPSBNYXRoLmNvcyxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgfHwgX2lzU3RyaW5nKHZhbHVlKTtcbn0sXG4gICAgX2lzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAvLyBub3RlOiBJRTEwIGhhcyBBcnJheUJ1ZmZlciwgYnV0IE5PVCBBcnJheUJ1ZmZlci5pc1ZpZXcoKS5cbl9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBfc3RyaWN0TnVtRXhwID0gLyg/Oi0/XFwuP1xcZHxcXC4pKy9naSxcbiAgICAvL29ubHkgbnVtYmVycyAoaW5jbHVkaW5nIG5lZ2F0aXZlcyBhbmQgZGVjaW1hbHMpIGJ1dCBOT1QgcmVsYXRpdmUgdmFsdWVzLlxuX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcbiAgICAvL2ZpbmRzIGFueSBudW1iZXJzLCBpbmNsdWRpbmcgb25lcyB0aGF0IHN0YXJ0IHdpdGggKz0gb3IgLT0sIG5lZ2F0aXZlIG51bWJlcnMsIGFuZCBvbmVzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAxZS04LlxuX251bVdpdGhVbml0RXhwID0gL1stKz0uXSpcXGQrWy5lLV0qXFxkKlthLXolXSovZyxcbiAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcbiAgICAvL2R1cGxpY2F0ZSBzbyB0aGF0IHdoaWxlIHdlJ3JlIGxvb3BpbmcgdGhyb3VnaCBtYXRjaGVzIGZyb20gZXhlYygpLCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBsYXN0SW5kZXggb2YgX251bUV4cCB3aGljaCB3ZSB1c2UgdG8gc2VhcmNoIGZvciBjb2xvcnMgdG9vLlxuX3JlbEV4cCA9IC9bKy1dPS0/Wy5cXGRdKy8sXG4gICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxuICAgIC8vIHByZXZpb3VzbHkgL1sjXFwtKy5dKlxcYlthLXpcXGRcXC09KyUuXSsvZ2kgYnV0IGRpZG4ndCBjYXRjaCBzcGVjaWFsIGNoYXJhY3RlcnMuXG5fdW5pdEV4cCA9IC9eWytcXC09ZVxcc1xcZF0qXFxkK1suXFxkXSooW2Etel0qfCUpXFxzKiQvaSxcbiAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2RvYyxcbiAgICBfZ2xvYmFscyA9IHt9LFxuICAgIF9pbnN0YWxsU2NvcGUgPSB7fSxcbiAgICBfY29yZVJlYWR5LFxuICAgIF9pbnN0YWxsID0gZnVuY3Rpb24gX2luc3RhbGwoc2NvcGUpIHtcbiAgcmV0dXJuIChfaW5zdGFsbFNjb3BlID0gX21lcmdlKHNjb3BlLCBfZ2xvYmFscykpICYmIGdzYXA7XG59LFxuICAgIF9taXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gX21pc3NpbmdQbHVnaW4ocHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UsIHN1cHByZXNzKSB7XG4gIHJldHVybiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufSxcbiAgICBfYWRkR2xvYmFsID0gZnVuY3Rpb24gX2FkZEdsb2JhbChuYW1lLCBvYmopIHtcbiAgcmV0dXJuIG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiBfaW5zdGFsbFNjb3BlICYmIChfaW5zdGFsbFNjb3BlW25hbWVdID0gb2JqKSB8fCBfZ2xvYmFscztcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiAwO1xufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuICAgIF9sYXp5VHdlZW5zID0gW10sXG4gICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICBfbGFzdFJlbmRlcmVkRnJhbWUsXG4gICAgX3BsdWdpbnMgPSB7fSxcbiAgICBfZWZmZWN0cyA9IHt9LFxuICAgIF9uZXh0R0NGcmFtZSA9IDMwLFxuICAgIF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICBfaGFybmVzcyA9IGZ1bmN0aW9uIF9oYXJuZXNzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbMF0sXG4gICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgaTtcbiAgX2lzT2JqZWN0KHRhcmdldCkgfHwgX2lzRnVuY3Rpb24odGFyZ2V0KSB8fCAodGFyZ2V0cyA9IFt0YXJnZXRzXSk7XG5cbiAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggYSBoYXJuZXNzLiBXZSBhc3N1bWUgdGFyZ2V0cyBwYXNzZWQgaW50byBhbiBhbmltYXRpb24gd2lsbCBiZSBvZiBzaW1pbGFyIHR5cGUsIG1lYW5pbmcgdGhlIHNhbWUga2luZCBvZiBoYXJuZXNzIGNhbiBiZSB1c2VkIGZvciB0aGVtIGFsbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgIGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG4gIH1cblxuICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldHM7XG59LFxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwO1xufSxcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICByZXR1cm4gKHYgPSB0YXJnZXRbcHJvcGVydHldKSAmJiBfaXNGdW5jdGlvbih2KSA/IHRhcmdldFtwcm9wZXJ0eV0oKSA6IF9pc1VuZGVmaW5lZCh2KSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpIHx8IHY7XG59LFxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICByZXR1cm4gKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpIHx8IG5hbWVzO1xufSxcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMDApIC8gMTAwMDAwMDAgfHwgMDtcbn0sXG4gICAgLy8gaW5jcmVhc2VkIHByZWNpc2lvbiBtb3N0bHkgZm9yIHRpbWluZyB2YWx1ZXMuXG5fcGFyc2VSZWxhdGl2ZSA9IGZ1bmN0aW9uIF9wYXJzZVJlbGF0aXZlKHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXG4gICAgICBlbmQgPSBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cigyKSk7XG4gIHN0YXJ0ID0gcGFyc2VGbG9hdChzdGFydCk7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcbn0sXG4gICAgX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKGV4Y2x1ZGVEdXJhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgICBwIGluIG9iaiB8fCBwID09PSBcImR1cmF0aW9uXCIgJiYgZXhjbHVkZUR1cmF0aW9uIHx8IHAgPT09IFwiZWFzZVwiIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gICAgfVxuICB9O1xufSxcbiAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gdG9NZXJnZVtwXTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIHAgIT09IFwiX19wcm90b19fXCIgJiYgcCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIHAgIT09IFwicHJvdG90eXBlXCIgJiYgKGJhc2VbcF0gPSBfaXNPYmplY3QodG9NZXJnZVtwXSkgPyBfbWVyZ2VEZWVwKGJhc2VbcF0gfHwgKGJhc2VbcF0gPSB7fSksIHRvTWVyZ2VbcF0pIDogdG9NZXJnZVtwXSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgcCBpbiBleGNsdWRpbmcgfHwgKGNvcHlbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcbiAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgIGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzKF9pc0FycmF5KHZhcnMua2V5ZnJhbWVzKSkgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICBjaGlsZC5fYWN0ID0gMDtcbn0sXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG4gICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICB3aGlsZSAoYSkge1xuICAgICAgYS5fZGlydHkgPSAxO1xuICAgICAgYSA9IGEucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgdmFyIHdob2xlID0gTWF0aC5mbG9vcih0VGltZSAvPSBjeWNsZUR1cmF0aW9uKTtcbiAgcmV0dXJuIHRUaW1lICYmIHdob2xlID09PSB0VGltZSA/IHdob2xlIC0gMSA6IHdob2xlO1xufSxcbiAgICBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSA9IGZ1bmN0aW9uIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudFRpbWUsIGNoaWxkKSB7XG4gIHJldHVybiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpO1xufSxcbiAgICBfc2V0RW5kID0gZnVuY3Rpb24gX3NldEVuZChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kUHJlY2lzZShhbmltYXRpb24uX3N0YXJ0ICsgKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pIHx8IDApKTtcbn0sXG4gICAgX2FsaWduUGxheWhlYWQgPSBmdW5jdGlvbiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIHRvdGFsVGltZSkge1xuICAvLyBhZGp1c3RzIHRoZSBhbmltYXRpb24ncyBfc3RhcnQgYW5kIF9lbmQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCB0b3RhbFRpbWUgKG9ubHkgaWYgdGhlIHBhcmVudCdzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUgYW5kIHRoZSBhbmltYXRpb24gaXNuJ3QgcGF1c2VkKS4gSXQgZG9lc24ndCBkbyBhbnkgcmVuZGVyaW5nIG9yIGZvcmNpbmcgdGhpbmdzIGJhY2sgaW50byBwYXJlbnQgdGltZWxpbmVzLCBldGMuIC0gdGhhdCdzIHdoYXQgdG90YWxUaW1lKCkgaXMgZm9yLlxuICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLl9kcDtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiBhbmltYXRpb24uX3RzKSB7XG4gICAgYW5pbWF0aW9uLl9zdGFydCA9IF9yb3VuZFByZWNpc2UocGFyZW50Ll90aW1lIC0gKGFuaW1hdGlvbi5fdHMgPiAwID8gdG90YWxUaW1lIC8gYW5pbWF0aW9uLl90cyA6ICgoYW5pbWF0aW9uLl9kaXJ0eSA/IGFuaW1hdGlvbi50b3RhbER1cmF0aW9uKCkgOiBhbmltYXRpb24uX3REdXIpIC0gdG90YWxUaW1lKSAvIC1hbmltYXRpb24uX3RzKSk7XG5cbiAgICBfc2V0RW5kKGFuaW1hdGlvbik7XG5cbiAgICBwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCwgYW5pbWF0aW9uKTsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcblxuLypcbl90b3RhbFRpbWVUb1RpbWUgPSAoY2xhbXBlZFRvdGFsVGltZSwgZHVyYXRpb24sIHJlcGVhdCwgcmVwZWF0RGVsYXksIHlveW8pID0+IHtcblx0bGV0IGN5Y2xlRHVyYXRpb24gPSBkdXJhdGlvbiArIHJlcGVhdERlbGF5LFxuXHRcdHRpbWUgPSBfcm91bmQoY2xhbXBlZFRvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24pO1xuXHRpZiAodGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0dGltZSA9IGR1cmF0aW9uO1xuXHR9XG5cdHJldHVybiAoeW95byAmJiAofn4oY2xhbXBlZFRvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pICYgMSkpID8gZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbn0sXG4qL1xuX3Bvc3RBZGRDaGVja3MgPSBmdW5jdGlvbiBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpIHtcbiAgdmFyIHQ7XG5cbiAgaWYgKGNoaWxkLl90aW1lIHx8IGNoaWxkLl9pbml0dGVkICYmICFjaGlsZC5fZHVyKSB7XG4gICAgLy9pbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydCBpcyBtb3ZlZCBvbiBhIHR3ZWVuIHRoYXQgaGFzIGFscmVhZHkgcmVuZGVyZWQuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuXG4gICAgdCA9IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWVsaW5lLnJhd1RpbWUoKSwgY2hpbGQpO1xuXG4gICAgaWYgKCFjaGlsZC5fZHVyIHx8IF9jbGFtcCgwLCBjaGlsZC50b3RhbER1cmF0aW9uKCksIHQpIC0gY2hpbGQuX3RUaW1lID4gX3RpbnlOdW0pIHtcbiAgICAgIGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcbiAgICB9XG4gIH0gLy9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cblxuICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZSgoX2lzTnVtYmVyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24gfHwgdGltZWxpbmUgIT09IF9nbG9iYWxUaW1lbGluZSA/IF9wYXJzZVBvc2l0aW9uKHRpbWVsaW5lLCBwb3NpdGlvbiwgY2hpbGQpIDogdGltZWxpbmUuX3RpbWUpICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICBfaXNGcm9tT3JGcm9tU3RhcnQoY2hpbGQpIHx8ICh0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQpO1xuICBza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG4gIHJldHVybiB0aW1lbGluZTtcbn0sXG4gICAgX3Njcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2Nyb2xsVHJpZ2dlcihhbmltYXRpb24sIHRyaWdnZXIpIHtcbiAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcbn0sXG4gICAgX2F0dGVtcHRJbml0VHdlZW4gPSBmdW5jdGlvbiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgX2luaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lKTtcblxuICBpZiAoIXR3ZWVuLl9pbml0dGVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoIWZvcmNlICYmIHR3ZWVuLl9wdCAmJiAodHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkgIT09IGZhbHNlIHx8ICF0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSkgJiYgX2xhc3RSZW5kZXJlZEZyYW1lICE9PSBfdGlja2VyLmZyYW1lKSB7XG4gICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cbiAgICB0d2Vlbi5fbGF6eSA9IFt0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChfcmVmKSB7XG4gIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xufSxcbiAgICAvLyBjaGVjayBwYXJlbnQncyBfbG9jayBiZWNhdXNlIHdoZW4gYSB0aW1lbGluZSByZXBlYXRzL3lveW9zIGFuZCBkb2VzIGl0cyBhcnRpZmljaWFsIHdyYXBwaW5nLCB3ZSBzaG91bGRuJ3QgZm9yY2UgdGhlIHJhdGlvIGJhY2sgdG8gMFxuX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgcmV0dXJuIGRhdGEgPT09IFwiaXNGcm9tU3RhcnRcIiB8fCBkYXRhID09PSBcImlzU3RhcnRcIjtcbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLiBFZGdlIGNhc2U6IGlmIGEgZnJvbSgpIG9yIGZyb21UbygpIHN0YWdnZXIgdHdlZW4gaXMgcGxhY2VkIGxhdGVyIGluIGEgdGltZWxpbmUsIHRoZSBcInN0YXJ0QXRcIiB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGNvdWxkIGluaXRpYWxseSByZW5kZXIgYXQgYSB0aW1lIHdoZW4gdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGlzIHRlY2huaWNhbGx5IEJFRk9SRSB3aGVyZSB0aGlzIHR3ZWVuIGlzLCBzbyBtYWtlIHN1cmUgdGhhdCBhbnkgXCJmcm9tXCIgYW5kIFwiZnJvbVRvXCIgc3RhcnRBdCB0d2VlbnMgYXJlIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lIGF0IGEgcmF0aW8gb2YgMS5cbiAgcmVwZWF0RGVsYXkgPSB0d2Vlbi5fckRlbGF5LFxuICAgICAgdFRpbWUgPSAwLFxuICAgICAgcHQsXG4gICAgICBpdGVyYXRpb24sXG4gICAgICBwcmV2SXRlcmF0aW9uO1xuXG4gIGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy8gaW4gY2FzZSB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiB0aGF0IGhhcyBhIHJlcGVhdCB3aXRoIGEgcmVwZWF0RGVsYXlcbiAgICB0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcbiAgICBpdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIHJlcGVhdERlbGF5KTtcbiAgICB0d2Vlbi5feW95byAmJiBpdGVyYXRpb24gJiAxICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG5cbiAgICBpZiAoaXRlcmF0aW9uICE9PSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSkpIHtcbiAgICAgIC8vIGlmIGl0ZXJhdGlvbiBjaGFuZ2VkXG4gICAgICBwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IGZvcmNlIHx8IHR3ZWVuLl96VGltZSA9PT0gX3RpbnlOdW0gfHwgIXRvdGFsVGltZSAmJiB0d2Vlbi5felRpbWUpIHtcbiAgICBpZiAoIXR3ZWVuLl9pbml0dGVkICYmIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykpIHtcbiAgICAgIC8vIGlmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2SXRlcmF0aW9uID0gdHdlZW4uX3pUaW1lO1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApOyAvLyB3aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgIHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7IC8vIGlmIGl0IHdhcyByZW5kZXJlZCBwcmV2aW91c2x5IGF0IGV4YWN0bHkgMCAoX3pUaW1lKSBhbmQgbm93IHRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcgYXdheSwgRE9OJ1QgZmlyZSBjYWxsYmFja3Mgb3RoZXJ3aXNlIHRoZXknbGwgc2VlbSBsaWtlIGR1cGxpY2F0ZXMuXG5cbiAgICB0d2Vlbi5yYXRpbyA9IHJhdGlvO1xuICAgIHR3ZWVuLl9mcm9tICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG4gICAgdHdlZW4uX3RpbWUgPSAwO1xuICAgIHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuICAgIHB0ID0gdHdlZW4uX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgdHdlZW4uX3N0YXJ0QXQgJiYgdG90YWxUaW1lIDwgMCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICB0d2Vlbi5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICB0VGltZSAmJiB0d2Vlbi5fcmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0d2Vlbi5wYXJlbnQgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgaWYgKCh0b3RhbFRpbWUgPj0gdHdlZW4uX3REdXIgfHwgdG90YWxUaW1lIDwgMCkgJiYgdHdlZW4ucmF0aW8gPT09IHJhdGlvKSB7XG4gICAgICByYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cbiAgICAgIGlmICghc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHR3ZWVuLCByYXRpbyA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICB0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghdHdlZW4uX3pUaW1lKSB7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lO1xuICB9XG59LFxuICAgIF9maW5kTmV4dFBhdXNlVHdlZW4gPSBmdW5jdGlvbiBfZmluZE5leHRQYXVzZVR3ZWVuKGFuaW1hdGlvbiwgcHJldlRpbWUsIHRpbWUpIHtcbiAgdmFyIGNoaWxkO1xuXG4gIGlmICh0aW1lID4gcHJldlRpbWUpIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0IDw9IHRpbWUpIHtcbiAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNoaWxkID0gYW5pbWF0aW9uLl9sYXN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA+PSB0aW1lKSB7XG4gICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0IDwgcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9wcmV2O1xuICAgIH1cbiAgfVxufSxcbiAgICBfc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpIHtcbiAgdmFyIHJlcGVhdCA9IGFuaW1hdGlvbi5fcmVwZWF0LFxuICAgICAgZHVyID0gX3JvdW5kUHJlY2lzZShkdXJhdGlvbikgfHwgMCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICBhbmltYXRpb24uX2R1ciA9IGR1cjtcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kUHJlY2lzZShkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG4gIHRvdGFsUHJvZ3Jlc3MgPiAwICYmICFsZWF2ZVBsYXloZWFkID8gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCBhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcykgOiBhbmltYXRpb24ucGFyZW50ICYmIF9zZXRFbmQoYW5pbWF0aW9uKTtcbiAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24gaW5zdGFuY2VvZiBUaW1lbGluZSA/IF91bmNhY2hlKGFuaW1hdGlvbikgOiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24uX2R1cik7XG59LFxuICAgIF96ZXJvUG9zaXRpb24gPSB7XG4gIF9zdGFydDogMCxcbiAgZW5kVGltZTogX2VtcHR5RnVuYyxcbiAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xufSxcbiAgICBfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICByZWNlbnQgPSBhbmltYXRpb24uX3JlY2VudCB8fCBfemVyb1Bvc2l0aW9uLFxuICAgICAgY2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLFxuICAgICAgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjaGlsZCB0aGF0IGluZmluaXRlbHkgcmVwZWF0cywgdXNlcnMgYWxtb3N0IG5ldmVyIGludGVuZCBmb3IgdGhlIGluc2VydGlvbiBwb2ludCBvZiBhIG5ldyBjaGlsZCB0byBiZSBiYXNlZCBvbiBhIFNVUEVSIGxvbmcgdmFsdWUgbGlrZSB0aGF0IHNvIHdlIGNsaXAgaXQgYW5kIGFzc3VtZSB0aGUgbW9zdCByZWNlbnRseS1hZGRlZCBjaGlsZCdzIGVuZFRpbWUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgaSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGlzUGVyY2VudDtcblxuICBpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IHBvc2l0aW9uIGluIGxhYmVscykpIHtcbiAgICAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuICAgIG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcbiAgICBpc1BlcmNlbnQgPSBwb3NpdGlvbi5zdWJzdHIoLTEpID09PSBcIiVcIjtcbiAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cbiAgICBpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG4gICAgICBpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcbiAgICAgIHJldHVybiAob2Zmc2V0ID09PSBcIjxcIiA/IHJlY2VudC5fc3RhcnQgOiByZWNlbnQuZW5kVGltZShyZWNlbnQuX3JlcGVhdCA+PSAwKSkgKyAocGFyc2VGbG9hdChwb3NpdGlvbi5zdWJzdHIoMSkpIHx8IDApICogKGlzUGVyY2VudCA/IChpIDwgMCA/IHJlY2VudCA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKSAvIDEwMCA6IDEpO1xuICAgIH1cblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcG9zaXRpb24gaW4gbGFiZWxzIHx8IChsYWJlbHNbcG9zaXRpb25dID0gY2xpcHBlZER1cmF0aW9uKTtcbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGlzUGVyY2VudCAmJiBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbn0sXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSA9IGZ1bmN0aW9uIF9jcmVhdGVUd2VlblR5cGUodHlwZSwgcGFyYW1zLCB0aW1lbGluZSkge1xuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycyxcbiAgICAgIHBhcmVudDtcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpclZhcnMgPSB2YXJzO1xuICAgIHBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkge1xuICAgICAgLy8gaW5oZXJpdGFuY2UgaGFzbid0IGhhcHBlbmVkIHlldCwgYnV0IHNvbWVvbmUgbWF5IGhhdmUgc2V0IGEgZGVmYXVsdCBpbiBhbiBhbmNlc3RvciB0aW1lbGluZS4gV2UgY291bGQgZG8gdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlcikgYnV0IHRoYXQnZCBleGFjdCBhIHNsaWdodCBwZXJmb3JtYW5jZSBwZW5hbHR5IGJlY2F1c2UgX2luaGVyaXREZWZhdWx0cygpIGFsc28gcnVucyBpbiB0aGUgVHdlZW4gY29uc3RydWN0b3IuIFdlJ3JlIHBheWluZyBhIHNtYWxsIGtiIHByaWNlIGhlcmUgdG8gZ2FpbiBzcGVlZC5cbiAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgcGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHR5cGUgPCAyID8gdmFycy5ydW5CYWNrd2FyZHMgPSAxIDogdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdOyAvLyBcImZyb21cIiB2YXJzXG4gIH1cblxuICByZXR1cm4gbmV3IFR3ZWVuKHBhcmFtc1swXSwgdmFycywgcGFyYW1zW3ZhcnNJbmRleCArIDFdKTtcbn0sXG4gICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IGZ1bmModmFsdWUpIDogZnVuYztcbn0sXG4gICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufSxcbiAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSwgdikge1xuICByZXR1cm4gIV9pc1N0cmluZyh2YWx1ZSkgfHwgISh2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSkpID8gXCJcIiA6IHZbMV07XG59LFxuICAgIC8vIG5vdGU6IHByb3RlY3QgYWdhaW5zdCBwYWRkZWQgbnVtYmVycyBhcyBzdHJpbmdzLCBsaWtlIFwiMTAwLjEwMFwiLiBUaGF0IHNob3VsZG4ndCByZXR1cm4gXCIwMFwiIGFzIHRoZSB1bml0LiBJZiBpdCdzIG51bWVyaWMsIHJldHVybiBubyB1bml0LlxuY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gX2NsYW1wKG1pbiwgbWF4LCB2KTtcbiAgfSk7XG59LFxuICAgIF9zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG59LFxuICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICBhY2N1bXVsYXRvciA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hY2N1bXVsYXRvcjtcblxuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICB9KSB8fCBhY2N1bXVsYXRvcjtcbn0sXG4gICAgLy90YWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYW4gYXJyYXkuIElmIGl0J3MgYSBzdHJpbmcgKGFuZCBsZWF2ZVN0cmluZ3MgaXNuJ3QgdHJ1ZSksIGl0J2xsIHVzZSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCkgYW5kIGNvbnZlcnQgdGhhdCB0byBhbiBhcnJheS4gSXQnbGwgYWxzbyBhY2NlcHQgaXRlcmFibGVzIGxpa2UgalF1ZXJ5IG9iamVjdHMuXG50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgc2NvcGUsIGxlYXZlU3RyaW5ncykge1xuICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoKHNjb3BlIHx8IF9kb2MpLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xufSxcbiAgICBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKHZhbHVlKSB7XG4gIHZhbHVlID0gdG9BcnJheSh2YWx1ZSlbMF0gfHwgX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgZWwgPSB2YWx1ZS5jdXJyZW50IHx8IHZhbHVlLm5hdGl2ZUVsZW1lbnQgfHwgdmFsdWU7XG4gICAgcmV0dXJuIHRvQXJyYXkodiwgZWwucXVlcnlTZWxlY3RvckFsbCA/IGVsIDogZWwgPT09IHZhbHVlID8gX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSA6IHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgc2h1ZmZsZSA9IGZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICByZXR1cm4gYS5zb3J0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gLjUgLSBNYXRoLnJhbmRvbSgpO1xuICB9KTtcbn0sXG4gICAgLy8gYWx0ZXJuYXRpdmUgdGhhdCdzIGEgYml0IGZhc3RlciBhbmQgbW9yZSByZWxpYWJseSBkaXZlcnNlIGJ1dCBiaWdnZXI6ICAgZm9yIChsZXQgaiwgdiwgaSA9IGEubGVuZ3RoOyBpOyBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSksIHYgPSBhWy0taV0sIGFbaV0gPSBhW2pdLCBhW2pdID0gdik7IHJldHVybiBhO1xuLy9mb3IgZGlzdHJpYnV0aW5nIHZhbHVlcyBhY3Jvc3MgYW4gYXJyYXkuIENhbiBhY2NlcHQgYSBudW1iZXIsIGEgZnVuY3Rpb24gb3IgKG1vc3QgY29tbW9ubHkpIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiB7YmFzZSwgYW1vdW50LCBmcm9tLCBlYXNlLCBncmlkLCBheGlzLCBsZW5ndGgsIGVhY2h9LiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogaW5kZXgsIHRhcmdldCwgYXJyYXkuIFJlY29nbml6ZXMgdGhlIGZvbGxvd2luZ1xuZGlzdHJpYnV0ZSA9IGZ1bmN0aW9uIGRpc3RyaWJ1dGUodikge1xuICBpZiAoX2lzRnVuY3Rpb24odikpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHZhciB2YXJzID0gX2lzT2JqZWN0KHYpID8gdiA6IHtcbiAgICBlYWNoOiB2XG4gIH0sXG4gICAgICAvL246MSBpcyBqdXN0IHRvIGluZGljYXRlIHYgd2FzIGEgbnVtYmVyOyB3ZSBsZXZlcmFnZSB0aGF0IGxhdGVyIHRvIHNldCB2IGFjY29yZGluZyB0byB0aGUgbGVuZ3RoIHdlIGdldC4gSWYgYSBudW1iZXIgaXMgcGFzc2VkIGluLCB3ZSB0cmVhdCBpdCBsaWtlIHRoZSBvbGQgc3RhZ2dlciB2YWx1ZSB3aGVyZSAwLjEsIGZvciBleGFtcGxlLCB3b3VsZCBtZWFuIHRoYXQgdGhpbmdzIHdvdWxkIGJlIGRpc3RyaWJ1dGVkIHdpdGggMC4xIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSByYXRoZXIgdGhhbiBhIHRvdGFsIFwiYW1vdW50XCIgdGhhdCdzIGNodW5rZWQgb3V0IGFtb25nIHRoZW0gYWxsLlxuICBlYXNlID0gX3BhcnNlRWFzZSh2YXJzLmVhc2UpLFxuICAgICAgZnJvbSA9IHZhcnMuZnJvbSB8fCAwLFxuICAgICAgYmFzZSA9IHBhcnNlRmxvYXQodmFycy5iYXNlKSB8fCAwLFxuICAgICAgY2FjaGUgPSB7fSxcbiAgICAgIGlzRGVjaW1hbCA9IGZyb20gPiAwICYmIGZyb20gPCAxLFxuICAgICAgcmF0aW9zID0gaXNOYU4oZnJvbSkgfHwgaXNEZWNpbWFsLFxuICAgICAgYXhpcyA9IHZhcnMuYXhpcyxcbiAgICAgIHJhdGlvWCA9IGZyb20sXG4gICAgICByYXRpb1kgPSBmcm9tO1xuXG4gIGlmIChfaXNTdHJpbmcoZnJvbSkpIHtcbiAgICByYXRpb1ggPSByYXRpb1kgPSB7XG4gICAgICBjZW50ZXI6IC41LFxuICAgICAgZWRnZXM6IC41LFxuICAgICAgZW5kOiAxXG4gICAgfVtmcm9tXSB8fCAwO1xuICB9IGVsc2UgaWYgKCFpc0RlY2ltYWwgJiYgcmF0aW9zKSB7XG4gICAgcmF0aW9YID0gZnJvbVswXTtcbiAgICByYXRpb1kgPSBmcm9tWzFdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpLCB0YXJnZXQsIGEpIHtcbiAgICB2YXIgbCA9IChhIHx8IHZhcnMpLmxlbmd0aCxcbiAgICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0sXG4gICAgICAgIG9yaWdpblgsXG4gICAgICAgIG9yaWdpblksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGQsXG4gICAgICAgIGosXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICB3cmFwQXQ7XG5cbiAgICBpZiAoIWRpc3RhbmNlcykge1xuICAgICAgd3JhcEF0ID0gdmFycy5ncmlkID09PSBcImF1dG9cIiA/IDAgOiAodmFycy5ncmlkIHx8IFsxLCBfYmlnTnVtXSlbMV07XG5cbiAgICAgIGlmICghd3JhcEF0KSB7XG4gICAgICAgIG1heCA9IC1fYmlnTnVtO1xuXG4gICAgICAgIHdoaWxlIChtYXggPCAobWF4ID0gYVt3cmFwQXQrK10uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgJiYgd3JhcEF0IDwgbCkge31cblxuICAgICAgICB3cmFwQXQtLTtcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0gPSBbXTtcbiAgICAgIG9yaWdpblggPSByYXRpb3MgPyBNYXRoLm1pbih3cmFwQXQsIGwpICogcmF0aW9YIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xuICAgICAgb3JpZ2luWSA9IHdyYXBBdCA9PT0gX2JpZ051bSA/IDAgOiByYXRpb3MgPyBsICogcmF0aW9ZIC8gd3JhcEF0IC0gLjUgOiBmcm9tIC8gd3JhcEF0IHwgMDtcbiAgICAgIG1heCA9IDA7XG4gICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIHggPSBqICUgd3JhcEF0IC0gb3JpZ2luWDtcbiAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICBkaXN0YW5jZXNbal0gPSBkID0gIWF4aXMgPyBfc3FydCh4ICogeCArIHkgKiB5KSA6IE1hdGguYWJzKGF4aXMgPT09IFwieVwiID8geSA6IHgpO1xuICAgICAgICBkID4gbWF4ICYmIChtYXggPSBkKTtcbiAgICAgICAgZCA8IG1pbiAmJiAobWluID0gZCk7XG4gICAgICB9XG5cbiAgICAgIGZyb20gPT09IFwicmFuZG9tXCIgJiYgc2h1ZmZsZShkaXN0YW5jZXMpO1xuICAgICAgZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcbiAgICAgIGRpc3RhbmNlcy5taW4gPSBtaW47XG4gICAgICBkaXN0YW5jZXMudiA9IGwgPSAocGFyc2VGbG9hdCh2YXJzLmFtb3VudCkgfHwgcGFyc2VGbG9hdCh2YXJzLmVhY2gpICogKHdyYXBBdCA+IGwgPyBsIC0gMSA6ICFheGlzID8gTWF0aC5tYXgod3JhcEF0LCBsIC8gd3JhcEF0KSA6IGF4aXMgPT09IFwieVwiID8gbCAvIHdyYXBBdCA6IHdyYXBBdCkgfHwgMCkgKiAoZnJvbSA9PT0gXCJlZGdlc1wiID8gLTEgOiAxKTtcbiAgICAgIGRpc3RhbmNlcy5iID0gbCA8IDAgPyBiYXNlIC0gbCA6IGJhc2U7XG4gICAgICBkaXN0YW5jZXMudSA9IGdldFVuaXQodmFycy5hbW91bnQgfHwgdmFycy5lYWNoKSB8fCAwOyAvL3VuaXRcblxuICAgICAgZWFzZSA9IGVhc2UgJiYgbCA8IDAgPyBfaW52ZXJ0RWFzZShlYXNlKSA6IGVhc2U7XG4gICAgfVxuXG4gICAgbCA9IChkaXN0YW5jZXNbaV0gLSBkaXN0YW5jZXMubWluKSAvIGRpc3RhbmNlcy5tYXggfHwgMDtcbiAgICByZXR1cm4gX3JvdW5kUHJlY2lzZShkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gTWF0aC5wb3coMTAsICgodiArIFwiXCIpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGgpOyAvL3RvIGF2b2lkIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChsaWtlIDI0ICogMC4xID09IDIuNDAwMDAwMDAwMDAwMDAwNCksIHdlIGNob3Agb2ZmIGF0IGEgc3BlY2lmaWMgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIChtdWNoIGZhc3RlciB0aGFuIHRvRml4ZWQoKSlcblxuICByZXR1cm4gZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciBuID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHJhdykgLyB2KSAqIHYgKiBwO1xuICAgIHJldHVybiAobiAtIG4gJSAxKSAvIHAgKyAoX2lzTnVtYmVyKHJhdykgPyAwIDogZ2V0VW5pdChyYXcpKTsgLy8gbiAtIG4gJSAxIHJlcGxhY2VzIE1hdGguZmxvb3IoKSBpbiBvcmRlciB0byBoYW5kbGUgbmVnYXRpdmUgdmFsdWVzIHByb3Blcmx5LiBGb3IgZXhhbXBsZSwgTWF0aC5mbG9vcigtMTUwLjAwMDAwMDAwMDAwMDAzKSBpcyAxNTEhXG4gIH07XG59LFxuICAgIHNuYXAgPSBmdW5jdGlvbiBzbmFwKHNuYXBUbywgdmFsdWUpIHtcbiAgdmFyIGlzQXJyYXkgPSBfaXNBcnJheShzbmFwVG8pLFxuICAgICAgcmFkaXVzLFxuICAgICAgaXMyRDtcblxuICBpZiAoIWlzQXJyYXkgJiYgX2lzT2JqZWN0KHNuYXBUbykpIHtcbiAgICByYWRpdXMgPSBpc0FycmF5ID0gc25hcFRvLnJhZGl1cyB8fCBfYmlnTnVtO1xuXG4gICAgaWYgKHNuYXBUby52YWx1ZXMpIHtcbiAgICAgIHNuYXBUbyA9IHRvQXJyYXkoc25hcFRvLnZhbHVlcyk7XG5cbiAgICAgIGlmIChpczJEID0gIV9pc051bWJlcihzbmFwVG9bMF0pKSB7XG4gICAgICAgIHJhZGl1cyAqPSByYWRpdXM7IC8vcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHNvIHdlIGRvbid0IGhhdmUgdG8gTWF0aC5zcXJ0KCkgaW4gdGhlIGxvb3AuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNuYXBUbyA9IF9yb3VuZE1vZGlmaWVyKHNuYXBUby5pbmNyZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsICFpc0FycmF5ID8gX3JvdW5kTW9kaWZpZXIoc25hcFRvKSA6IF9pc0Z1bmN0aW9uKHNuYXBUbykgPyBmdW5jdGlvbiAocmF3KSB7XG4gICAgaXMyRCA9IHNuYXBUbyhyYXcpO1xuICAgIHJldHVybiBNYXRoLmFicyhpczJEIC0gcmF3KSA8PSByYWRpdXMgPyBpczJEIDogcmF3O1xuICB9IDogZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciB4ID0gcGFyc2VGbG9hdChpczJEID8gcmF3LnggOiByYXcpLFxuICAgICAgICB5ID0gcGFyc2VGbG9hdChpczJEID8gcmF3LnkgOiAwKSxcbiAgICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgIGkgPSBzbmFwVG8ubGVuZ3RoLFxuICAgICAgICBkeCxcbiAgICAgICAgZHk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoaXMyRCkge1xuICAgICAgICBkeCA9IHNuYXBUb1tpXS54IC0geDtcbiAgICAgICAgZHkgPSBzbmFwVG9baV0ueSAtIHk7XG4gICAgICAgIGR4ID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IE1hdGguYWJzKHNuYXBUb1tpXSAtIHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHggPCBtaW4pIHtcbiAgICAgICAgbWluID0gZHg7XG4gICAgICAgIGNsb3Nlc3QgPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsb3Nlc3QgPSAhcmFkaXVzIHx8IG1pbiA8PSByYWRpdXMgPyBzbmFwVG9bY2xvc2VzdF0gOiByYXc7XG4gICAgcmV0dXJuIGlzMkQgfHwgY2xvc2VzdCA9PT0gcmF3IHx8IF9pc051bWJlcihyYXcpID8gY2xvc2VzdCA6IGNsb3Nlc3QgKyBnZXRVbml0KHJhdyk7XG4gIH0pO1xufSxcbiAgICByYW5kb20gPSBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIHJvdW5kaW5nSW5jcmVtZW50LCByZXR1cm5GdW5jdGlvbikge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKF9pc0FycmF5KG1pbikgPyAhbWF4IDogcm91bmRpbmdJbmNyZW1lbnQgPT09IHRydWUgPyAhIShyb3VuZGluZ0luY3JlbWVudCA9IDApIDogIXJldHVybkZ1bmN0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBtaW5bfn4oTWF0aC5yYW5kb20oKSAqIG1pbi5sZW5ndGgpXSA6IChyb3VuZGluZ0luY3JlbWVudCA9IHJvdW5kaW5nSW5jcmVtZW50IHx8IDFlLTUpICYmIChyZXR1cm5GdW5jdGlvbiA9IHJvdW5kaW5nSW5jcmVtZW50IDwgMSA/IE1hdGgucG93KDEwLCAocm91bmRpbmdJbmNyZW1lbnQgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDEpICYmIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgobWluIC0gcm91bmRpbmdJbmNyZW1lbnQgLyAyICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyByb3VuZGluZ0luY3JlbWVudCAqIC45OSkpIC8gcm91bmRpbmdJbmNyZW1lbnQpICogcm91bmRpbmdJbmNyZW1lbnQgKiByZXR1cm5GdW5jdGlvbikgLyByZXR1cm5GdW5jdGlvbjtcbiAgfSk7XG59LFxuICAgIHBpcGUgPSBmdW5jdGlvbiBwaXBlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3Rpb25zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmN0aW9uc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAodiwgZikge1xuICAgICAgcmV0dXJuIGYodik7XG4gICAgfSwgdmFsdWUpO1xuICB9O1xufSxcbiAgICB1bml0aXplID0gZnVuY3Rpb24gdW5pdGl6ZShmdW5jLCB1bml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyhwYXJzZUZsb2F0KHZhbHVlKSkgKyAodW5pdCB8fCBnZXRVbml0KHZhbHVlKSk7XG4gIH07XG59LFxuICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIG1hcFJhbmdlKG1pbiwgbWF4LCAwLCAxLCB2YWx1ZSk7XG59LFxuICAgIF93cmFwQXJyYXkgPSBmdW5jdGlvbiBfd3JhcEFycmF5KGEsIHdyYXBwZXIsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBhW35+d3JhcHBlcihpbmRleCldO1xuICB9KTtcbn0sXG4gICAgd3JhcCA9IGZ1bmN0aW9uIHdyYXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIC8vIE5PVEU6IHdyYXAoKSBDQU5OT1QgYmUgYW4gYXJyb3cgZnVuY3Rpb24hIEEgdmVyeSBvZGQgY29tcGlsaW5nIGJ1ZyBjYXVzZXMgcHJvYmxlbXMgKHVucmVsYXRlZCB0byBHU0FQKS5cbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwKDAsIG1pbi5sZW5ndGgpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKHJhbmdlICsgKHZhbHVlIC0gbWluKSAlIHJhbmdlKSAlIHJhbmdlICsgbWluO1xuICB9KTtcbn0sXG4gICAgd3JhcFlveW8gPSBmdW5jdGlvbiB3cmFwWW95byhtaW4sIG1heCwgdmFsdWUpIHtcbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluLFxuICAgICAgdG90YWwgPSByYW5nZSAqIDI7XG4gIHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXBZb3lvKDAsIG1pbi5sZW5ndGggLSAxKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSAodG90YWwgKyAodmFsdWUgLSBtaW4pICUgdG90YWwpICUgdG90YWwgfHwgMDtcbiAgICByZXR1cm4gbWluICsgKHZhbHVlID4gcmFuZ2UgPyB0b3RhbCAtIHZhbHVlIDogdmFsdWUpO1xuICB9KTtcbn0sXG4gICAgX3JlcGxhY2VSYW5kb20gPSBmdW5jdGlvbiBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkge1xuICAvL3JlcGxhY2VzIGFsbCBvY2N1cnJlbmNlcyBvZiByYW5kb20oLi4uKSBpbiBhIHN0cmluZyB3aXRoIHRoZSBjYWxjdWxhdGVkIHJhbmRvbSB2YWx1ZS4gY2FuIGJlIGEgcmFuZ2UgbGlrZSByYW5kb20oLTEwMCwgMTAwLCA1KSBvciBhbiBhcnJheSBsaWtlIHJhbmRvbShbMCwgMTAwLCA1MDBdKVxuICB2YXIgcHJldiA9IDAsXG4gICAgICBzID0gXCJcIixcbiAgICAgIGksXG4gICAgICBudW1zLFxuICAgICAgZW5kLFxuICAgICAgaXNBcnJheTtcblxuICB3aGlsZSAofihpID0gdmFsdWUuaW5kZXhPZihcInJhbmRvbShcIiwgcHJldikpKSB7XG4gICAgZW5kID0gdmFsdWUuaW5kZXhPZihcIilcIiwgaSk7XG4gICAgaXNBcnJheSA9IHZhbHVlLmNoYXJBdChpICsgNykgPT09IFwiW1wiO1xuICAgIG51bXMgPSB2YWx1ZS5zdWJzdHIoaSArIDcsIGVuZCAtIGkgLSA3KS5tYXRjaChpc0FycmF5ID8gX2RlbGltaXRlZFZhbHVlRXhwIDogX3N0cmljdE51bUV4cCk7XG4gICAgcyArPSB2YWx1ZS5zdWJzdHIocHJldiwgaSAtIHByZXYpICsgcmFuZG9tKGlzQXJyYXkgPyBudW1zIDogK251bXNbMF0sIGlzQXJyYXkgPyAwIDogK251bXNbMV0sICtudW1zWzJdIHx8IDFlLTUpO1xuICAgIHByZXYgPSBlbmQgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHMgKyB2YWx1ZS5zdWJzdHIocHJldiwgdmFsdWUubGVuZ3RoIC0gcHJldik7XG59LFxuICAgIG1hcFJhbmdlID0gZnVuY3Rpb24gbWFwUmFuZ2UoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCwgdmFsdWUpIHtcbiAgdmFyIGluUmFuZ2UgPSBpbk1heCAtIGluTWluLFxuICAgICAgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBvdXRNaW4gKyAoKHZhbHVlIC0gaW5NaW4pIC8gaW5SYW5nZSAqIG91dFJhbmdlIHx8IDApO1xuICB9KTtcbn0sXG4gICAgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBwcm9ncmVzcywgbXV0YXRlKSB7XG4gIHZhciBmdW5jID0gaXNOYU4oc3RhcnQgKyBlbmQpID8gMCA6IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuICgxIC0gcCkgKiBzdGFydCArIHAgKiBlbmQ7XG4gIH07XG5cbiAgaWYgKCFmdW5jKSB7XG4gICAgdmFyIGlzU3RyaW5nID0gX2lzU3RyaW5nKHN0YXJ0KSxcbiAgICAgICAgbWFzdGVyID0ge30sXG4gICAgICAgIHAsXG4gICAgICAgIGksXG4gICAgICAgIGludGVycG9sYXRvcnMsXG4gICAgICAgIGwsXG4gICAgICAgIGlsO1xuXG4gICAgcHJvZ3Jlc3MgPT09IHRydWUgJiYgKG11dGF0ZSA9IDEpICYmIChwcm9ncmVzcyA9IG51bGwpO1xuXG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgcDogc3RhcnRcbiAgICAgIH07XG4gICAgICBlbmQgPSB7XG4gICAgICAgIHA6IGVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pc0FycmF5KHN0YXJ0KSAmJiAhX2lzQXJyYXkoZW5kKSkge1xuICAgICAgaW50ZXJwb2xhdG9ycyA9IFtdO1xuICAgICAgbCA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgIGlsID0gbCAtIDI7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW50ZXJwb2xhdG9ycy5wdXNoKGludGVycG9sYXRlKHN0YXJ0W2kgLSAxXSwgc3RhcnRbaV0pKTsgLy9idWlsZCB0aGUgaW50ZXJwb2xhdG9ycyB1cCBmcm9udCBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB0aGF0IHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBtYW55IHRpbWVzLCBpdCBjYW4ganVzdCByZXVzZSB0aGVtLlxuICAgICAgfVxuXG4gICAgICBsLS07XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcCAqPSBsO1xuICAgICAgICB2YXIgaSA9IE1hdGgubWluKGlsLCB+fnApO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yc1tpXShwIC0gaSk7XG4gICAgICB9O1xuXG4gICAgICBwcm9ncmVzcyA9IGVuZDtcbiAgICB9IGVsc2UgaWYgKCFtdXRhdGUpIHtcbiAgICAgIHN0YXJ0ID0gX21lcmdlKF9pc0FycmF5KHN0YXJ0KSA/IFtdIDoge30sIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWludGVycG9sYXRvcnMpIHtcbiAgICAgIGZvciAocCBpbiBlbmQpIHtcbiAgICAgICAgX2FkZFByb3BUd2Vlbi5jYWxsKG1hc3Rlciwgc3RhcnQsIHAsIFwiZ2V0XCIsIGVuZFtwXSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcmV0dXJuIF9yZW5kZXJQcm9wVHdlZW5zKHAsIG1hc3RlcikgfHwgKGlzU3RyaW5nID8gc3RhcnQucCA6IHN0YXJ0KTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihwcm9ncmVzcywgZnVuYyk7XG59LFxuICAgIF9nZXRMYWJlbEluRGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsSW5EaXJlY3Rpb24odGltZWxpbmUsIGZyb21UaW1lLCBiYWNrd2FyZCkge1xuICAvL3VzZWQgZm9yIG5leHRMYWJlbCgpIGFuZCBwcmV2aW91c0xhYmVsKClcbiAgdmFyIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcbiAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICBwLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBsYWJlbDtcblxuICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgZGlzdGFuY2UgPSBsYWJlbHNbcF0gLSBmcm9tVGltZTtcblxuICAgIGlmIChkaXN0YW5jZSA8IDAgPT09ICEhYmFja3dhcmQgJiYgZGlzdGFuY2UgJiYgbWluID4gKGRpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpKSkge1xuICAgICAgbGFiZWwgPSBwO1xuICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsO1xufSxcbiAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbiBfY2FsbGJhY2soYW5pbWF0aW9uLCB0eXBlLCBleGVjdXRlTGF6eUZpcnN0KSB7XG4gIHZhciB2ID0gYW5pbWF0aW9uLnZhcnMsXG4gICAgICBjYWxsYmFjayA9IHZbdHlwZV0sXG4gICAgICBwYXJhbXMsXG4gICAgICBzY29wZTtcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcGFyYW1zID0gdlt0eXBlICsgXCJQYXJhbXNcIl07XG4gIHNjb3BlID0gdi5jYWxsYmFja1Njb3BlIHx8IGFuaW1hdGlvbjtcbiAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cbiAgcmV0dXJuIHBhcmFtcyA/IGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBwYXJhbXMpIDogY2FsbGJhY2suY2FsbChzY29wZSk7XG59LFxuICAgIF9pbnRlcnJ1cHQgPSBmdW5jdGlvbiBfaW50ZXJydXB0KGFuaW1hdGlvbikge1xuICBfcmVtb3ZlRnJvbVBhcmVudChhbmltYXRpb24pO1xuXG4gIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyICYmIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmtpbGwoZmFsc2UpO1xuICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3F1aWNrVHdlZW4sXG4gICAgX2NyZWF0ZVBsdWdpbiA9IGZ1bmN0aW9uIF9jcmVhdGVQbHVnaW4oY29uZmlnKSB7XG4gIGNvbmZpZyA9ICFjb25maWcubmFtZSAmJiBjb25maWdbXCJkZWZhdWx0XCJdIHx8IGNvbmZpZzsgLy9VTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cbiAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgIGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG4gICAgICBQbHVnaW4gPSBuYW1lICYmICFpc0Z1bmMgJiYgY29uZmlnLmluaXQgPyBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgfSA6IGNvbmZpZyxcbiAgICAgIC8vaW4gY2FzZSBzb21lb25lIHBhc3NlcyBpbiBhbiBvYmplY3QgdGhhdCdzIG5vdCBhIHBsdWdpbiwgbGlrZSBDdXN0b21FYXNlXG4gIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICByZW5kZXI6IF9yZW5kZXJQcm9wVHdlZW5zLFxuICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICBtb2RpZmllcjogX2FkZFBsdWdpbk1vZGlmaWVyLFxuICAgIHJhd1ZhcnM6IDBcbiAgfSxcbiAgICAgIHN0YXRpY3MgPSB7XG4gICAgdGFyZ2V0VGVzdDogMCxcbiAgICBnZXQ6IDAsXG4gICAgZ2V0U2V0dGVyOiBfZ2V0U2V0dGVyLFxuICAgIGFsaWFzZXM6IHt9LFxuICAgIHJlZ2lzdGVyOiAwXG4gIH07XG5cbiAgX3dha2UoKTtcblxuICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICBpZiAoX3BsdWdpbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfc2V0RGVmYXVsdHMoUGx1Z2luLCBfc2V0RGVmYXVsdHMoX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBpbnN0YW5jZURlZmF1bHRzKSwgc3RhdGljcykpOyAvL3N0YXRpYyBtZXRob2RzXG5cblxuICAgIF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblxuXG4gICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcblxuICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuICAgICAgX2hhcm5lc3NQbHVnaW5zLnB1c2goUGx1Z2luKTtcblxuICAgICAgX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICAgIH1cblxuICAgIG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cbiAgfVxuXG4gIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblxuICBjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ09MT1JTXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fMjU1ID0gMjU1LFxuICAgIF9jb2xvckxvb2t1cCA9IHtcbiAgYXF1YTogWzAsIF8yNTUsIF8yNTVdLFxuICBsaW1lOiBbMCwgXzI1NSwgMF0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICBibHVlOiBbMCwgMCwgXzI1NV0sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgeWVsbG93OiBbXzI1NSwgXzI1NSwgMF0sXG4gIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIHJlZDogW18yNTUsIDAsIDBdLFxuICBwaW5rOiBbXzI1NSwgMTkyLCAyMDNdLFxuICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXG4gIHRyYW5zcGFyZW50OiBbXzI1NSwgXzI1NSwgXzI1NSwgMF1cbn0sXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGlkZWEgdG8gcmVwbGFjZSB0aGUgaGFyZC1jb2RlZCBjb2xvciBuYW1lIHZhbHVlcyAtIHB1dCB0aGlzIGluIHRoZSB0aWNrZXIud2FrZSgpIHdoZXJlIHdlIHNldCB0aGUgX2RvYzpcbi8vIGxldCBjdHggPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO1xuLy8gX2ZvckVhY2hOYW1lKFwiYXF1YSxsaW1lLHNpbHZlcixibGFjayxtYXJvb24sdGVhbCxibHVlLG5hdnksd2hpdGUsb2xpdmUseWVsbG93LG9yYW5nZSxncmF5LHB1cnBsZSxncmVlbixyZWQscGluayxjeWFuXCIsIGNvbG9yID0+IHtjdHguZmlsbFN0eWxlID0gY29sb3I7IF9jb2xvckxvb2t1cFtjb2xvcl0gPSBzcGxpdENvbG9yKGN0eC5maWxsU3R5bGUpfSk7XG5faHVlID0gZnVuY3Rpb24gX2h1ZShoLCBtMSwgbTIpIHtcbiAgaCArPSBoIDwgMCA/IDEgOiBoID4gMSA/IC0xIDogMDtcbiAgcmV0dXJuIChoICogNiA8IDEgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogaCA8IC41ID8gbTIgOiBoICogMyA8IDIgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIF8yNTUgKyAuNSB8IDA7XG59LFxuICAgIHNwbGl0Q29sb3IgPSBmdW5jdGlvbiBzcGxpdENvbG9yKHYsIHRvSFNMLCBmb3JjZUFscGhhKSB7XG4gIHZhciBhID0gIXYgPyBfY29sb3JMb29rdXAuYmxhY2sgOiBfaXNOdW1iZXIodikgPyBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdIDogMCxcbiAgICAgIHIsXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIGgsXG4gICAgICBzLFxuICAgICAgbCxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIGQsXG4gICAgICB3YXNIU0w7XG5cbiAgaWYgKCFhKSB7XG4gICAgaWYgKHYuc3Vic3RyKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgIC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG4gICAgICB2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG4gICAgICBhID0gX2NvbG9yTG9va3VwW3ZdO1xuICAgIH0gZWxzZSBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICBpZiAodi5sZW5ndGggPCA2KSB7XG4gICAgICAgIC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjAgb3IgIzlGMEYgKGNvdWxkIGhhdmUgYWxwaGEpXG4gICAgICAgIHIgPSB2LmNoYXJBdCgxKTtcbiAgICAgICAgZyA9IHYuY2hhckF0KDIpO1xuICAgICAgICBiID0gdi5jaGFyQXQoMyk7XG4gICAgICAgIHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYiArICh2Lmxlbmd0aCA9PT0gNSA/IHYuY2hhckF0KDQpICsgdi5jaGFyQXQoNCkgOiBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIC8vIGhleCB3aXRoIGFscGhhLCBsaWtlICNmZDVlNTNmZlxuICAgICAgICBhID0gcGFyc2VJbnQodi5zdWJzdHIoMSwgNiksIDE2KTtcbiAgICAgICAgcmV0dXJuIFthID4+IDE2LCBhID4+IDggJiBfMjU1LCBhICYgXzI1NSwgcGFyc2VJbnQodi5zdWJzdHIoNyksIDE2KSAvIDI1NV07XG4gICAgICB9XG5cbiAgICAgIHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuICAgICAgYSA9IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV07XG4gICAgfSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuICAgICAgYSA9IHdhc0hTTCA9IHYubWF0Y2goX3N0cmljdE51bUV4cCk7XG5cbiAgICAgIGlmICghdG9IU0wpIHtcbiAgICAgICAgaCA9ICthWzBdICUgMzYwIC8gMzYwO1xuICAgICAgICBzID0gK2FbMV0gLyAxMDA7XG4gICAgICAgIGwgPSArYVsyXSAvIDEwMDtcbiAgICAgICAgZyA9IGwgPD0gLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHIgPSBsICogMiAtIGc7XG4gICAgICAgIGEubGVuZ3RoID4gMyAmJiAoYVszXSAqPSAxKTsgLy9jYXN0IGFzIG51bWJlclxuXG4gICAgICAgIGFbMF0gPSBfaHVlKGggKyAxIC8gMywgciwgZyk7XG4gICAgICAgIGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuICAgICAgICBhWzJdID0gX2h1ZShoIC0gMSAvIDMsIHIsIGcpO1xuICAgICAgfSBlbHNlIGlmICh+di5pbmRleE9mKFwiPVwiKSkge1xuICAgICAgICAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cbiAgICAgICAgYSA9IHYubWF0Y2goX251bUV4cCk7XG4gICAgICAgIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG4gICAgfVxuXG4gICAgYSA9IGEubWFwKE51bWJlcik7XG4gIH1cblxuICBpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xuICAgIHIgPSBhWzBdIC8gXzI1NTtcbiAgICBnID0gYVsxXSAvIF8yNTU7XG4gICAgYiA9IGFbMl0gLyBfMjU1O1xuICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgIGggPSBtYXggPT09IHIgPyAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSA6IG1heCA9PT0gZyA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcbiAgICAgIGggKj0gNjA7XG4gICAgfVxuXG4gICAgYVswXSA9IH5+KGggKyAuNSk7XG4gICAgYVsxXSA9IH5+KHMgKiAxMDAgKyAuNSk7XG4gICAgYVsyXSA9IH5+KGwgKiAxMDAgKyAuNSk7XG4gIH1cblxuICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICByZXR1cm4gYTtcbn0sXG4gICAgX2NvbG9yT3JkZXJEYXRhID0gZnVuY3Rpb24gX2NvbG9yT3JkZXJEYXRhKHYpIHtcbiAgLy8gc3RyaXBzIG91dCB0aGUgY29sb3JzIGZyb20gdGhlIHN0cmluZywgZmluZHMgYWxsIHRoZSBudW1lcmljIHNsb3RzICh3aXRoIHVuaXRzKSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZS4gVGhlIEFycmF5IGFsc28gaGFzIGEgXCJjXCIgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkgb2YgdGhlIGluZGV4IHZhbHVlcyB3aGVyZSB0aGUgY29sb3JzIGJlbG9uZy4gVGhpcyBpcyB0byBoZWxwIHdvcmsgYXJvdW5kIGlzc3VlcyB3aGVyZSB0aGVyZSdzIGEgbWlzLW1hdGNoZWQgb3JkZXIgb2YgY29sb3IvbnVtZXJpYyBkYXRhIGxpa2UgZHJvcC1zaGFkb3coI2YwMCAwcHggMXB4IDJweCkgYW5kIGRyb3Atc2hhZG93KDB4IDFweCAycHggI2YwMCkuIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGVscGVyIGZ1bmN0aW9uIHVzZWQgaW4gX2Zvcm1hdENvbG9ycygpXG4gIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgIGMgPSBbXSxcbiAgICAgIGkgPSAtMTtcbiAgdi5zcGxpdChfY29sb3JFeHApLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYSA9IHYubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGEpO1xuICAgIGMucHVzaChpICs9IGEubGVuZ3RoICsgMSk7XG4gIH0pO1xuICB2YWx1ZXMuYyA9IGM7XG4gIHJldHVybiB2YWx1ZXM7XG59LFxuICAgIF9mb3JtYXRDb2xvcnMgPSBmdW5jdGlvbiBfZm9ybWF0Q29sb3JzKHMsIHRvSFNMLCBvcmRlck1hdGNoRGF0YSkge1xuICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgIGNvbG9ycyA9IChzICsgcmVzdWx0KS5tYXRjaChfY29sb3JFeHApLFxuICAgICAgdHlwZSA9IHRvSFNMID8gXCJoc2xhKFwiIDogXCJyZ2JhKFwiLFxuICAgICAgaSA9IDAsXG4gICAgICBjLFxuICAgICAgc2hlbGwsXG4gICAgICBkLFxuICAgICAgbDtcblxuICBpZiAoIWNvbG9ycykge1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICByZXR1cm4gKGNvbG9yID0gc3BsaXRDb2xvcihjb2xvciwgdG9IU0wsIDEpKSAmJiB0eXBlICsgKHRvSFNMID8gY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuICB9KTtcblxuICBpZiAob3JkZXJNYXRjaERhdGEpIHtcbiAgICBkID0gX2NvbG9yT3JkZXJEYXRhKHMpO1xuICAgIGMgPSBvcmRlck1hdGNoRGF0YS5jO1xuXG4gICAgaWYgKGMuam9pbihyZXN1bHQpICE9PSBkLmMuam9pbihyZXN1bHQpKSB7XG4gICAgICBzaGVsbCA9IHMucmVwbGFjZShfY29sb3JFeHAsIFwiMVwiKS5zcGxpdChfbnVtV2l0aFVuaXRFeHApO1xuICAgICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArICh+Yy5pbmRleE9mKGkpID8gY29sb3JzLnNoaWZ0KCkgfHwgdHlwZSArIFwiMCwwLDAsMClcIiA6IChkLmxlbmd0aCA/IGQgOiBjb2xvcnMubGVuZ3RoID8gY29sb3JzIDogb3JkZXJNYXRjaERhdGEpLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2hlbGwpIHtcbiAgICBzaGVsbCA9IHMuc3BsaXQoX2NvbG9yRXhwKTtcbiAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyBjb2xvcnNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCArIHNoZWxsW2xdO1xufSxcbiAgICBfY29sb3JFeHAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezMsNH0pezEsMn1cXFxcYlwiLFxuICAgICAgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLixcbiAgcDtcblxuICBmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG4gICAgcyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChzICsgXCIpXCIsIFwiZ2lcIik7XG59KCksXG4gICAgX2hzbEV4cCA9IC9oc2xbYV0/XFwoLyxcbiAgICBfY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbiBfY29sb3JTdHJpbmdGaWx0ZXIoYSkge1xuICB2YXIgY29tYmluZWQgPSBhLmpvaW4oXCIgXCIpLFxuICAgICAgdG9IU0w7XG4gIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gIGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcbiAgICB0b0hTTCA9IF9oc2xFeHAudGVzdChjb21iaW5lZCk7XG4gICAgYVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuICAgIGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMLCBfY29sb3JPcmRlckRhdGEoYVsxXSkpOyAvLyBtYWtlIHN1cmUgdGhlIG9yZGVyIG9mIG51bWJlcnMvY29sb3JzIG1hdGNoIHdpdGggdGhlIEVORCB2YWx1ZS5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJQ0tFUlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX3RpY2tlckFjdGl2ZSxcbiAgICBfdGlja2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSA1MDAsXG4gICAgICBfYWRqdXN0ZWRMYWcgPSAzMyxcbiAgICAgIF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgX2xhc3RVcGRhdGUgPSBfc3RhcnRUaW1lLFxuICAgICAgX2dhcCA9IDEwMDAgLyAyNDAsXG4gICAgICBfbmV4dFRpbWUgPSBfZ2FwLFxuICAgICAgX2xpc3RlbmVycyA9IFtdLFxuICAgICAgX2lkLFxuICAgICAgX3JlcSxcbiAgICAgIF9yYWYsXG4gICAgICBfc2VsZixcbiAgICAgIF9kZWx0YSxcbiAgICAgIF9pLFxuICAgICAgX3RpY2sgPSBmdW5jdGlvbiBfdGljayh2KSB7XG4gICAgdmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG4gICAgICAgIG1hbnVhbCA9IHYgPT09IHRydWUsXG4gICAgICAgIG92ZXJsYXAsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICB0aW1lLFxuICAgICAgICBmcmFtZTtcblxuICAgIGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkICYmIChfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWcpO1xuICAgIF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG4gICAgdGltZSA9IF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZTtcbiAgICBvdmVybGFwID0gdGltZSAtIF9uZXh0VGltZTtcblxuICAgIGlmIChvdmVybGFwID4gMCB8fCBtYW51YWwpIHtcbiAgICAgIGZyYW1lID0gKytfc2VsZi5mcmFtZTtcbiAgICAgIF9kZWx0YSA9IHRpbWUgLSBfc2VsZi50aW1lICogMTAwMDtcbiAgICAgIF9zZWxmLnRpbWUgPSB0aW1lID0gdGltZSAvIDEwMDA7XG4gICAgICBfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyA0IDogX2dhcCAtIG92ZXJsYXApO1xuICAgICAgZGlzcGF0Y2ggPSAxO1xuICAgIH1cblxuICAgIG1hbnVhbCB8fCAoX2lkID0gX3JlcShfdGljaykpOyAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBmb3IgKF9pID0gMDsgX2kgPCBfbGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAvLyB1c2UgX2kgYW5kIGNoZWNrIF9saXN0ZW5lcnMubGVuZ3RoIGluc3RlYWQgb2YgYSB2YXJpYWJsZSBiZWNhdXNlIGEgbGlzdGVuZXIgY291bGQgZ2V0IHJlbW92ZWQgZHVyaW5nIHRoZSBsb29wLCBhbmQgaWYgdGhhdCBoYXBwZW5zIHRvIGFuIGVsZW1lbnQgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGluZGV4LCBpdCdkIHRocm93IHRoaW5ncyBvZmYgaW4gdGhlIGxvb3AuXG4gICAgICAgIF9saXN0ZW5lcnNbX2ldKHRpbWUsIF9kZWx0YSwgZnJhbWUsIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfc2VsZiA9IHtcbiAgICB0aW1lOiAwLFxuICAgIGZyYW1lOiAwLFxuICAgIHRpY2s6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICBfdGljayh0cnVlKTtcbiAgICB9LFxuICAgIGRlbHRhUmF0aW86IGZ1bmN0aW9uIGRlbHRhUmF0aW8oZnBzKSB7XG4gICAgICByZXR1cm4gX2RlbHRhIC8gKDEwMDAgLyAoZnBzIHx8IDYwKSk7XG4gICAgfSxcbiAgICB3YWtlOiBmdW5jdGlvbiB3YWtlKCkge1xuICAgICAgaWYgKF9jb3JlUmVhZHkpIHtcbiAgICAgICAgaWYgKCFfY29yZUluaXR0ZWQgJiYgX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgICAgICAgX3dpbiA9IF9jb3JlSW5pdHRlZCA9IHdpbmRvdztcbiAgICAgICAgICBfZG9jID0gX3dpbi5kb2N1bWVudCB8fCB7fTtcbiAgICAgICAgICBfZ2xvYmFscy5nc2FwID0gZ3NhcDtcbiAgICAgICAgICAoX3dpbi5nc2FwVmVyc2lvbnMgfHwgKF93aW4uZ3NhcFZlcnNpb25zID0gW10pKS5wdXNoKGdzYXAudmVyc2lvbik7XG5cbiAgICAgICAgICBfaW5zdGFsbChfaW5zdGFsbFNjb3BlIHx8IF93aW4uR3JlZW5Tb2NrR2xvYmFscyB8fCAhX3dpbi5nc2FwICYmIF93aW4gfHwge30pO1xuXG4gICAgICAgICAgX3JhZiA9IF93aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgX2lkICYmIF9zZWxmLnNsZWVwKCk7XG5cbiAgICAgICAgX3JlcSA9IF9yYWYgfHwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCBfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGlja2VyQWN0aXZlID0gMTtcblxuICAgICAgICBfdGljaygyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgIChfcmFmID8gX3dpbi5jYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcbiAgICAgIF90aWNrZXJBY3RpdmUgPSAwO1xuICAgICAgX3JlcSA9IF9lbXB0eUZ1bmM7XG4gICAgfSxcbiAgICBsYWdTbW9vdGhpbmc6IGZ1bmN0aW9uIGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG4gICAgICBfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEgLyBfdGlueU51bTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cbiAgICAgIF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcbiAgICB9LFxuICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgIF9nYXAgPSAxMDAwIC8gKF9mcHMgfHwgMjQwKTtcbiAgICAgIF9uZXh0VGltZSA9IF9zZWxmLnRpbWUgKiAxMDAwICsgX2dhcDtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gYWRkKGNhbGxiYWNrLCBvbmNlLCBwcmlvcml0aXplKSB7XG4gICAgICB2YXIgZnVuYyA9IG9uY2UgPyBmdW5jdGlvbiAodCwgZCwgZiwgdikge1xuICAgICAgICBjYWxsYmFjayh0LCBkLCBmLCB2KTtcblxuICAgICAgICBfc2VsZi5yZW1vdmUoZnVuYyk7XG4gICAgICB9IDogY2FsbGJhY2s7XG5cbiAgICAgIF9zZWxmLnJlbW92ZShjYWxsYmFjayk7XG5cbiAgICAgIF9saXN0ZW5lcnNbcHJpb3JpdGl6ZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKGZ1bmMpO1xuXG4gICAgICBfd2FrZSgpO1xuXG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrLCBpKSB7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBfc2VsZjtcbn0oKSxcbiAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICByZXR1cm4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCk7XG59LFxuICAgIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuX2Vhc2VNYXAgPSB7fSxcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgIF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcbiAgICBfcGFyc2VPYmplY3RJblN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZU9iamVjdEluU3RyaW5nKHZhbHVlKSB7XG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuICB2YXIgb2JqID0ge30sXG4gICAgICBzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAzKS5zcGxpdChcIjpcIiksXG4gICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbCA9IHNwbGl0Lmxlbmd0aCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsLFxuICAgICAgcGFyc2VkVmFsO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFsID0gc3BsaXRbaV07XG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgIG9ialtrZXldID0gaXNOYU4ocGFyc2VkVmFsKSA/IHBhcnNlZFZhbC5yZXBsYWNlKF9xdW90ZXNFeHAsIFwiXCIpLnRyaW0oKSA6ICtwYXJzZWRWYWw7XG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuICAgICAgY2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcbiAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xufSxcbiAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG4gIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgZWFzZSA9IF9lYXNlTWFwW3NwbGl0WzBdXTtcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XG59LFxuICAgIF9pbnZlcnRFYXNlID0gZnVuY3Rpb24gX2ludmVydEVhc2UoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICB9O1xufSxcbiAgICAvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuX3Byb3BhZ2F0ZVlveW9FYXNlID0gZnVuY3Rpb24gX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pIHtcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxuICAgICAgZWFzZTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4gICAgICBpZiAoY2hpbGQudGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZSA9IGNoaWxkLl9lYXNlO1xuICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcbiAgICAgICAgY2hpbGQuX3lveW8gPSBpc1lveW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgfVxufSxcbiAgICBfcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQmFja1wiLCBfY29uZmlnQmFjayhcImluXCIpLCBfY29uZmlnQmFjayhcIm91dFwiKSwgX2NvbmZpZ0JhY2soKSk7XG5cbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG4gICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXBzID0gMTtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXG4gICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgIHAzID0gaW1tZWRpYXRlU3RhcnQgPyAxIDogMCxcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xuICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSB8IDApICsgcDMpICogcDE7XG4gICAgfTtcbiAgfVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICB0aGlzLmlkID0gX2dzSUQrKztcbiAgdGFyZ2V0Ll9nc2FwID0gdGhpcztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG4gIHRoaXMuZ2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0IDogX2dldFByb3BlcnR5O1xuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG59O1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24odmFycykge1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgdGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0ID09PSBJbmZpbml0eSA/IC0yIDogdmFycy5yZXBlYXQgfHwgMCkge1xuICAgICAgLy8gVE9ETzogcmVwZWF0OiBJbmZpbml0eSBvbiBhIHRpbWVsaW5lJ3MgY2hpbGRyZW4gbXVzdCBmbGFnIHRoYXQgdGltZWxpbmUgaW50ZXJuYWxseSBhbmQgYWZmZWN0IGl0cyB0b3RhbER1cmF0aW9uLCBvdGhlcndpc2UgaXQnbGwgc3RvcCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIHdoZW4gcmVhY2hpbmcgdGhlIHN0YXJ0LlxuICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgdGhpcy5feW95byA9ICEhdmFycy55b3lvIHx8ICEhdmFycy55b3lvRWFzZTtcbiAgICB9XG5cbiAgICB0aGlzLl90cyA9IDE7XG5cbiAgICBfc2V0RHVyYXRpb24odGhpcywgK3ZhcnMuZHVyYXRpb24sIDEsIDEpO1xuXG4gICAgdGhpcy5kYXRhID0gdmFycy5kYXRhO1xuICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XG5cbiAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTsgLy8gZWRnZSBjYXNlOiBpZiB0aGlzIGlzIGEgY2hpbGQgb2YgYSB0aW1lbGluZSB0aGF0IGFscmVhZHkgY29tcGxldGVkLCBmb3IgZXhhbXBsZSwgd2UgbXVzdCByZS1hY3RpdmF0ZSB0aGUgcGFyZW50LlxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuICAgICAgLy9pZiAoIXRoaXMuX2xvY2spIHsgLy8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb24gKG5vdCBzdXJlIHdlIG5lZWQgdGhpcyB5ZXQgb3IgaWYgaXQncyB3b3J0aCB0aGUgcGVyZm9ybWFuY2UgaGl0KVxuICAgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblxuICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTsgLy8gICB0aGlzLl9sb2NrID0gMDtcbiAgICAgIC8vfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuICB9O1xuXG4gIF9wcm90by50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF0aW87XG4gIH07XG5cbiAgX3Byb3RvLnByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiAodGhpcy5feW95byAmJiAhKHRoaXMuaXRlcmF0aW9uKCkgJiAxKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5kdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuX2R1cikgOiB0aGlzLnJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5pdGVyYXRpb24gPSBmdW5jdGlvbiBpdGVyYXRpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgdmFyIGN5Y2xlRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCkgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcbiAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIGFkZGl0aW9uOlxuICAvLyBpc1BsYXlpbmdCYWNrd2FyZHMoKSB7XG4gIC8vIFx0bGV0IGFuaW1hdGlvbiA9IHRoaXMsXG4gIC8vIFx0XHRvcmllbnRhdGlvbiA9IDE7IC8vIDEgPSBmb3J3YXJkLCAtMSA9IGJhY2t3YXJkXG4gIC8vIFx0d2hpbGUgKGFuaW1hdGlvbikge1xuICAvLyBcdFx0b3JpZW50YXRpb24gKj0gYW5pbWF0aW9uLnJldmVyc2VkKCkgfHwgKGFuaW1hdGlvbi5yZXBlYXQoKSAmJiAhKGFuaW1hdGlvbi5pdGVyYXRpb24oKSAmIDEpKSA/IC0xIDogMTtcbiAgLy8gXHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXJlbnQ7XG4gIC8vIFx0fVxuICAvLyBcdHJldHVybiBvcmllbnRhdGlvbiA8IDA7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90by50aW1lU2NhbGUgPSBmdW5jdGlvbiB0aW1lU2NhbGUodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuICAgIC8vIGZ1dHVyZSBhZGRpdGlvbj8gVXAgc2lkZTogZmFzdCBhbmQgbWluaW1hbCBmaWxlIHNpemUuIERvd24gc2lkZTogb25seSB3b3JrcyBvbiB0aGlzIGFuaW1hdGlvbjsgaWYgYSB0aW1lbGluZSBpcyByZXZlcnNlZCwgZm9yIGV4YW1wbGUsIGl0cyBjaGlsZHJlbnMnIG9uUmV2ZXJzZSB3b3VsZG4ndCBnZXQgY2FsbGVkLlxuICAgIC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcbiAgICAvLyBwcmlvcml0aXplIHJlbmRlcmluZyB3aGVyZSB0aGUgcGFyZW50J3MgcGxheWhlYWQgbGluZXMgdXAgaW5zdGVhZCBvZiB0aGlzLl90VGltZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgdHdlZW4gdGhhdCdzIGFuaW1hdGluZyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIGluIHRoZSBzYW1lIHJlbmRlcmluZyBsb29wIChzYW1lIHBhcmVudCksIHRodXMgaWYgdGhlIHRpbWVTY2FsZSB0d2VlbiByZW5kZXJzIGZpcnN0LCBpdCB3b3VsZCBhbHRlciBfc3RhcnQgQkVGT1JFIF90VGltZSB3YXMgc2V0IG9uIHRoYXQgdGljayAoaW4gdGhlIHJlbmRlcmluZyBsb29wKSwgZWZmZWN0aXZlbHkgZnJlZXppbmcgaXQgdW50aWwgdGhlIHRpbWVTY2FsZSB0d2VlbiBmaW5pc2hlcy5cblxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUgd2hpY2ggd291bGQgYmUgMCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBhdXNlZC5cblxuICAgIHRoaXMudG90YWxUaW1lKF9jbGFtcCgtdGhpcy5fZGVsYXksIHRoaXMuX3REdXIsIHRUaW1lKSwgdHJ1ZSk7XG5cbiAgICBfc2V0RW5kKHRoaXMpOyAvLyBpZiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgd2FzIGZhbHNlLCB0aGUgZW5kIHRpbWUgZGlkbid0IGdldCB1cGRhdGVkIGluIHRoZSBfYWxpZ25QbGF5aGVhZCgpIG1ldGhvZCwgc28gZG8gaXQgaGVyZS5cblxuXG4gICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2xvYmFsVGltZSA9IGZ1bmN0aW9uIGdsb2JhbFRpbWUocmF3VGltZSkge1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLFxuICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgd2hpbGUgKGFuaW1hdGlvbikge1xuICAgICAgdGltZSA9IGFuaW1hdGlvbi5fc3RhcnQgKyB0aW1lIC8gKGFuaW1hdGlvbi5fdHMgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcmVwZWF0ID0gdmFsdWUgPT09IEluZmluaXR5ID8gLTIgOiB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBlYXQgPT09IC0yID8gSW5maW5pdHkgOiB0aGlzLl9yZXBlYXQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gcmVwZWF0RGVsYXkodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5fckRlbGF5ID0gdmFsdWU7XG5cbiAgICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG5cbiAgICAgIHJldHVybiB0aW1lID8gdGhpcy50aW1lKHRpbWUpIDogdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fckRlbGF5O1xuICB9O1xuXG4gIF9wcm90by55b3lvID0gZnVuY3Rpb24geW95byh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl95b3lvID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5feW95bztcbiAgfTtcblxuICBfcHJvdG8uc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGxheSA9IGZ1bmN0aW9uIHBsYXkoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBhdFRpbWUgIT0gbnVsbCAmJiB0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZWQgPSBmdW5jdGlvbiByZXZlcnNlZCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAhIXZhbHVlICE9PSB0aGlzLnJldmVyc2VkKCkgJiYgdGhpcy50aW1lU2NhbGUoLXRoaXMuX3J0cyB8fCAodmFsdWUgPyAtX3RpbnlOdW0gOiAwKSk7IC8vIGluIGNhc2UgdGltZVNjYWxlIGlzIHplcm8sIHJldmVyc2luZyB3b3VsZCBoYXZlIG5vIGVmZmVjdCBzbyB3ZSB1c2UgX3RpbnlOdW0uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9pbml0dGVkID0gdGhpcy5fYWN0ID0gMDtcbiAgICB0aGlzLl96VGltZSA9IC1fdGlueU51bTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG4gICAgICAgIHJhd1RpbWU7XG4gICAgcmV0dXJuICEhKCFwYXJlbnQgfHwgdGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90by5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gZXZlbnRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHZhcnMgPSB0aGlzLnZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIHBhcmFtcyAmJiAodmFyc1t0eXBlICsgXCJQYXJhbXNcIl0gPSBwYXJhbXMpO1xuICAgICAgICB0eXBlID09PSBcIm9uVXBkYXRlXCIgJiYgKHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyc1t0eXBlXTtcbiAgfTtcblxuICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgZiA9IF9pc0Z1bmN0aW9uKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogX3Bhc3NUaHJvdWdoLFxuICAgICAgICAgIF9yZXNvbHZlID0gZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gICAgICAgIHZhciBfdGhlbiA9IHNlbGYudGhlbjtcbiAgICAgICAgc2VsZi50aGVuID0gbnVsbDsgLy8gdGVtcG9yYXJpbHkgbnVsbCB0aGUgdGhlbigpIG1ldGhvZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zMjIpXG5cbiAgICAgICAgX2lzRnVuY3Rpb24oZikgJiYgKGYgPSBmKHNlbGYpKSAmJiAoZi50aGVuIHx8IGYgPT09IHNlbGYpICYmIChzZWxmLnRoZW4gPSBfdGhlbik7XG4gICAgICAgIHJlc29sdmUoZik7XG4gICAgICAgIHNlbGYudGhlbiA9IF90aGVuO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGYuX2luaXR0ZWQgJiYgc2VsZi50b3RhbFByb2dyZXNzKCkgPT09IDEgJiYgc2VsZi5fdHMgPj0gMCB8fCAhc2VsZi5fdFRpbWUgJiYgc2VsZi5fdHMgPCAwKSB7XG4gICAgICAgIF9yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9wcm9tID0gX3Jlc29sdmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIF9pbnRlcnJ1cHQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGlvbjtcbn0oKTtcblxuX3NldERlZmF1bHRzKEFuaW1hdGlvbi5wcm90b3R5cGUsIHtcbiAgX3RpbWU6IDAsXG4gIF9zdGFydDogMCxcbiAgX2VuZDogMCxcbiAgX3RUaW1lOiAwLFxuICBfdER1cjogMCxcbiAgX2RpcnR5OiAwLFxuICBfcmVwZWF0OiAwLFxuICBfeW95bzogZmFsc2UsXG4gIHBhcmVudDogbnVsbCxcbiAgX2luaXR0ZWQ6IGZhbHNlLFxuICBfckRlbGF5OiAwLFxuICBfdHM6IDEsXG4gIF9kcDogMCxcbiAgcmF0aW86IDAsXG4gIF96VGltZTogLV90aW55TnVtLFxuICBfcHJvbTogMCxcbiAgX3BzOiBmYWxzZSxcbiAgX3J0czogMVxufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElNRUxJTkVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVGltZWxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoVGltZWxpbmUsIF9BbmltYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lKHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX0FuaW1hdGlvbi5jYWxsKHRoaXMsIHZhcnMpIHx8IHRoaXM7XG4gICAgX3RoaXMubGFiZWxzID0ge307XG4gICAgX3RoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAhIXZhcnMuc21vb3RoQ2hpbGRUaW1pbmc7XG4gICAgX3RoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gISF2YXJzLmF1dG9SZW1vdmVDaGlsZHJlbjtcbiAgICBfdGhpcy5fc29ydCA9IF9pc05vdEZhbHNlKHZhcnMuc29ydENoaWxkcmVuKTtcbiAgICBfZ2xvYmFsVGltZWxpbmUgJiYgX2FkZFRvVGltZWxpbmUodmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgcG9zaXRpb24pO1xuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIF90aGlzLnBhdXNlZCh0cnVlKTtcbiAgICB2YXJzLnNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhcnMuc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBUaW1lbGluZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgwLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5jYWxsID0gZnVuY3Rpb24gY2FsbChjYWxsYmFjaywgcGFyYW1zLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zKSwgcG9zaXRpb24pO1xuICB9IC8vT05MWSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSEgTWF5YmUgZGVsZXRlP1xuICA7XG5cbiAgX3Byb3RvMi5zdGFnZ2VyVG8gPSBmdW5jdGlvbiBzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xuICAgIHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG4gICAgdmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbVRvKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuICAgICAgICB0RHVyID0gdGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPD0gMCA/IDAgOiBfcm91bmRQcmVjaXNlKHRvdGFsVGltZSksXG4gICAgICAgIC8vIGlmIGEgcGF1c2VkIHRpbWVsaW5lIGlzIHJlc3VtZWQgKG9yIGl0cyBfc3RhcnQgaXMgdXBkYXRlZCBmb3IgYW5vdGhlciByZWFzb24uLi53aGljaCByb3VuZHMgaXQpLCB0aGF0IGNvdWxkIHJlc3VsdCBpbiB0aGUgcGxheWhlYWQgc2hpZnRpbmcgYSAqKnRpbnkqKiBhbW91bnQgYW5kIGEgemVyby1kdXJhdGlvbiBjaGlsZCBhdCB0aGF0IHNwb3QgbWF5IGdldCByZW5kZXJlZCBhdCBhIGRpZmZlcmVudCByYXRpbywgbGlrZSBpdHMgdG90YWxUaW1lIGluIHJlbmRlcigpIG1heSBiZSAxZS0xNyBpbnN0ZWFkIG9mIDAsIGZvciBleGFtcGxlLlxuICAgIGNyb3NzaW5nU3RhcnQgPSB0aGlzLl96VGltZSA8IDAgIT09IHRvdGFsVGltZSA8IDAgJiYgKHRoaXMuX2luaXR0ZWQgfHwgIWR1ciksXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZQYXVzZWQsXG4gICAgICAgIHBhdXNlVHdlZW4sXG4gICAgICAgIHRpbWVTY2FsZSxcbiAgICAgICAgcHJldlN0YXJ0LFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICB5b3lvLFxuICAgICAgICBpc1lveW87XG4gICAgdGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRUaW1lID4gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCAmJiAodFRpbWUgPSB0RHVyKTtcblxuICAgIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgZm9yY2UgfHwgY3Jvc3NpbmdTdGFydCkge1xuICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xuICAgICAgICAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG4gICAgICAgIHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgIH1cblxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgcHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICB0aW1lU2NhbGUgPSB0aGlzLl90cztcbiAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXG4gICAgICBpZiAoY3Jvc3NpbmdTdGFydCkge1xuICAgICAgICBkdXIgfHwgKHByZXZUaW1lID0gdGhpcy5felRpbWUpOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIXN1cHByZXNzRXZlbnRzKSAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICB5b3lvID0gdGhpcy5feW95bztcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0IDwgLTEgJiYgdG90YWxUaW1lIDwgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDVcblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IGR1cjtcbiAgICAgICAgICB0aGlzLl9sb2NrID0gMTtcbiAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSB8fCAoaXNZb3lvID8gMCA6IF9yb3VuZFByZWNpc2UoaXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbikpLCBzdXBwcmVzc0V2ZW50cywgIWR1cikuX2xvY2sgPSAwO1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7IC8vIGlmIGEgdXNlciBnZXRzIHRoZSBpdGVyYXRpb24oKSBpbnNpZGUgdGhlIG9uUmVwZWF0LCBmb3IgZXhhbXBsZSwgaXQgc2hvdWxkIGJlIGFjY3VyYXRlLlxuXG4gICAgICAgICAgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICBpZiAocHJldlRpbWUgJiYgcHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzIHx8IHRoaXMudmFycy5vblJlcGVhdCAmJiAhdGhpcy5wYXJlbnQgJiYgIXRoaXMuX2FjdCkge1xuICAgICAgICAgICAgLy8gaWYgcHJldlRpbWUgaXMgMCBhbmQgd2UgcmVuZGVyIGF0IHRoZSB2ZXJ5IGVuZCwgX3RpbWUgd2lsbCBiZSB0aGUgZW5kLCB0aHVzIHdvbid0IG1hdGNoLiBTbyBpbiB0aGlzIGVkZ2UgY2FzZSwgcHJldlRpbWUgd29uJ3QgbWF0Y2ggX3RpbWUgYnV0IHRoYXQncyBva2F5LiBJZiBpdCBnZXRzIGtpbGxlZCBpbiB0aGUgb25SZXBlYXQsIGVqZWN0IGFzIHdlbGwuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkdXIgPSB0aGlzLl9kdXI7IC8vIGluIGNhc2UgdGhlIGR1cmF0aW9uIGNoYW5nZWQgaW4gdGhlIG9uUmVwZWF0XG5cbiAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cjtcblxuICAgICAgICAgIGlmIChkb2VzV3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDI7XG4gICAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IGR1ciA6IC0wLjAwMDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSAvL2luIG9yZGVyIGZvciB5b3lvRWFzZSB0byB3b3JrIHByb3Blcmx5IHdoZW4gdGhlcmUncyBhIHN0YWdnZXIsIHdlIG11c3Qgc3dhcCBvdXQgdGhlIGVhc2UgaW4gZWFjaCBzdWItdHdlZW4uXG5cblxuICAgICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZSh0aGlzLCBpc1lveW8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmRQcmVjaXNlKHByZXZUaW1lKSwgX3JvdW5kUHJlY2lzZSh0aW1lKSk7XG5cbiAgICAgICAgaWYgKHBhdXNlVHdlZW4pIHtcbiAgICAgICAgICB0VGltZSAtPSB0aW1lIC0gKHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5fYWN0ID0gIXRpbWVTY2FsZTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgIGlmICghdGhpcy5faW5pdHRlZCkge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcbiAgICAgICAgdGhpcy5faW5pdHRlZCA9IDE7XG4gICAgICAgIHRoaXMuX3pUaW1lID0gdG90YWxUaW1lO1xuICAgICAgICBwcmV2VGltZSA9IDA7IC8vIHVwb24gaW5pdCwgdGhlIHBsYXloZWFkIHNob3VsZCBhbHdheXMgZ28gZm9yd2FyZDsgc29tZW9uZSBjb3VsZCBpbnZhbGlkYXRlKCkgYSBjb21wbGV0ZWQgdGltZWxpbmUgYW5kIHRoZW4gaWYgdGhleSByZXN0YXJ0KCksIHRoYXQgd291bGQgbWFrZSBjaGlsZCB0d2VlbnMgcmVuZGVyIGluIHJldmVyc2Ugb3JkZXIgd2hpY2ggY291bGQgbG9jayBpbiB0aGUgd3Jvbmcgc3RhcnRpbmcgdmFsdWVzIGlmIHRoZXkgYnVpbGQgb24gZWFjaCBvdGhlciwgbGlrZSB0bC50byhvYmosIHt4OiAxMDB9KS50byhvYmosIHt4OiAwfSkuXG4gICAgICB9XG5cbiAgICAgIGlmICghcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZSA+PSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCB0aW1lID49IGNoaWxkLl9zdGFydCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSAtX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gZmxhZyB6VGltZSBhcyBuZWdhdGl2ZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fbGFzdDtcbiAgICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lOyAvL3doZW4gdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBtdXN0IHBhc3MgdGhhdCBpbmZvcm1hdGlvbiBkb3duIHRvIHRoZSBjaGlsZCBhbmltYXRpb25zIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMga25vdyB3aGV0aGVyIHRvIHJlbmRlciB0aGVpciBzdGFydGluZyBvciBlbmRpbmcgdmFsdWVzLlxuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fcHJldjtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gYWRqdXN0ZWRUaW1lID8gLV90aW55TnVtIDogX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gYWRqdXN0IHpUaW1lIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICBpZiAodGhpcy5fdHMpIHtcbiAgICAgICAgICAvL3RoZSBjYWxsYmFjayByZXN1bWVkIHBsYXliYWNrISBTbyBzaW5jZSB3ZSBtYXkgaGF2ZSBoZWxkIGJhY2sgdGhlIHBsYXloZWFkIGR1ZSB0byB3aGVyZSB0aGUgcGF1c2UgaXMgcG9zaXRpb25lZCwgZ28gYWhlYWQgYW5kIGp1bXAgdG8gd2hlcmUgaXQncyBTVVBQT1NFRCB0byBiZSAoaWYgbm8gcGF1c2UgaGFwcGVuZWQpLlxuICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxuXG4gICAgICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgaWYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RUaW1lID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiBwcmV2VGltZSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcbiAgICAgICAgLy8gcmVtZW1iZXIsIGEgY2hpbGQncyBjYWxsYmFjayBtYXkgYWx0ZXIgdGhpcyB0aW1lbGluZSdzIHBsYXloZWFkIG9yIHRpbWVTY2FsZSB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBhZGQgc29tZSBvZiB0aGVzZSBjaGVja3MuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUgfHwgIXREdXIpKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyICYmIHRvdGFsVGltZSA+PSAwID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoY2hpbGQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXG4gICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG4gICAgICBpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkKG9iaiwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0d2VlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdHdlZW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGltZWxpbmVzID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVsaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IC1fYmlnTnVtO1xuICAgIH1cblxuICAgIHZhciBhID0gW10sXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICAgIHR3ZWVucyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVsaW5lcyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIG5lc3RlZCAmJiBhLnB1c2guYXBwbHkoYSwgY2hpbGQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0QnlJZCA9IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oMSwgMSwgMSksXG4gICAgICAgIGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhbmltYXRpb25zW2ldLnZhcnMuaWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCkge1xuICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMua2lsbFR3ZWVuc09mKGNoaWxkKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgY2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcbiAgICAgIHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xuXG4gICAgaWYgKCF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuICAvLyB0YXJnZXRzKCkge1xuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcbiAgLy8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcbiAgLy8gXHRyZXR1cm4gcmVzdWx0LmZpbHRlcigodiwgaSkgPT4gcmVzdWx0LmluZGV4T2YodikgPT09IGkpO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBpbml0dGVkLFxuICAgICAgICB0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcblxuICAgICAgICBpZiAoIWluaXR0ZWQpIHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSk7XG4gICAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBpbml0dGVkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuXG4gICAgcmV0dXJuIGltbWVkaWF0ZVJlbmRlciA/IHR3ZWVuLnJlbmRlcigwKSA6IHR3ZWVuO1xuICB9O1xuXG4gIF9wcm90bzIudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbiB0d2VlbkZyb21Ubyhmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcbiAgICByZXR1cm4gdGhpcy50d2VlblRvKHRvUG9zaXRpb24sIF9zZXREZWZhdWx0cyh7XG4gICAgICBzdGFydEF0OiB7XG4gICAgICAgIHRpbWU6IF9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbilcbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZWNlbnQgPSBmdW5jdGlvbiByZWNlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY2VudDtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRMYWJlbCA9IGZ1bmN0aW9uIG5leHRMYWJlbChhZnRlclRpbWUpIHtcbiAgICBpZiAoYWZ0ZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuICB9O1xuXG4gIF9wcm90bzIucHJldmlvdXNMYWJlbCA9IGZ1bmN0aW9uIHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSkge1xuICAgIGlmIChiZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvMi5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbiBjdXJyZW50TGFiZWwodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8yLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgY2hpbGQuX3N0YXJ0ICs9IGFtb3VudDtcbiAgICAgICAgY2hpbGQuX2VuZCArPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLmludmFsaWRhdGUoKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xuICAgIGlmIChpbmNsdWRlTGFiZWxzID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG4gICAgaW5jbHVkZUxhYmVscyAmJiAodGhpcy5sYWJlbHMgPSB7fSk7XG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNoaWxkID0gc2VsZi5fbGFzdCxcbiAgICAgICAgcHJldlN0YXJ0ID0gX2JpZ051bSxcbiAgICAgICAgcHJldixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBhcmVudDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VsZi50aW1lU2NhbGUoKHNlbGYuX3JlcGVhdCA8IDAgPyBzZWxmLmR1cmF0aW9uKCkgOiBzZWxmLnRvdGFsRHVyYXRpb24oKSkgLyAoc2VsZi5yZXZlcnNlZCgpID8gLXZhbHVlIDogdmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgIHBhcmVudCA9IHNlbGYucGFyZW50O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cbiAgICAgICAgY2hpbGQuX2RpcnR5ICYmIGNoaWxkLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblxuICAgICAgICBzdGFydCA9IGNoaWxkLl9zdGFydDtcblxuICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcbiAgICAgICAgICAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gICAgICAgICAgc2VsZi5fbG9jayA9IDE7IC8vcHJldmVudCBlbmRsZXNzIHJlY3Vyc2l2ZSBjYWxscyAtIHRoZXJlIGFyZSBtZXRob2RzIHRoYXQgZ2V0IHRyaWdnZXJlZCB0aGF0IGNoZWNrIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gd2hlbiB3ZSBhZGQoKS5cblxuICAgICAgICAgIF9hZGRUb1RpbWVsaW5lKHNlbGYsIGNoaWxkLCBzdGFydCAtIGNoaWxkLl9kZWxheSwgMSkuX2xvY2sgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCAmJiBjaGlsZC5fdHMpIHtcbiAgICAgICAgICAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuICAgICAgICAgIG1heCAtPSBzdGFydDtcblxuICAgICAgICAgIGlmICghcGFyZW50ICYmICFzZWxmLl9kcCB8fCBwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSB7XG4gICAgICAgICAgICBzZWxmLl9zdGFydCArPSBzdGFydCAvIHNlbGYuX3RzO1xuICAgICAgICAgICAgc2VsZi5fdGltZSAtPSBzdGFydDtcbiAgICAgICAgICAgIHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuc2hpZnRDaGlsZHJlbigtc3RhcnQsIGZhbHNlLCAtMWU5OTkpO1xuICAgICAgICAgIHByZXZTdGFydCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5fZW5kID4gbWF4ICYmIGNoaWxkLl90cyAmJiAobWF4ID0gY2hpbGQuX2VuZCk7XG4gICAgICAgIGNoaWxkID0gcHJldjtcbiAgICAgIH1cblxuICAgICAgX3NldER1cmF0aW9uKHNlbGYsIHNlbGYgPT09IF9nbG9iYWxUaW1lbGluZSAmJiBzZWxmLl90aW1lID4gbWF4ID8gc2VsZi5fdGltZSA6IG1heCwgMSwgMSk7XG5cbiAgICAgIHNlbGYuX2RpcnR5ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5fdER1cjtcbiAgfTtcblxuICBUaW1lbGluZS51cGRhdGVSb290ID0gZnVuY3Rpb24gdXBkYXRlUm9vdCh0aW1lKSB7XG4gICAgaWYgKF9nbG9iYWxUaW1lbGluZS5fdHMpIHtcbiAgICAgIF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXG4gICAgICBfbGFzdFJlbmRlcmVkRnJhbWUgPSBfdGlja2VyLmZyYW1lO1xuICAgIH1cblxuICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuICAgICAgX25leHRHQ0ZyYW1lICs9IF9jb25maWcuYXV0b1NsZWVwIHx8IDEyMDtcbiAgICAgIHZhciBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuICAgICAgICB3aGlsZSAoY2hpbGQgJiYgIWNoaWxkLl90cykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCB8fCBfdGlja2VyLnNsZWVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaW1lbGluZTtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFRpbWVsaW5lLnByb3RvdHlwZSwge1xuICBfbG9jazogMCxcbiAgX2hhc1BhdXNlOiAwLFxuICBfZm9yY2luZzogMFxufSk7XG5cbnZhciBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAvL25vdGU6IHdlIGNhbGwgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0d2Vlbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YXJ0TnVtcyxcbiAgICAgIGNvbG9yLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBzdGFydE51bSxcbiAgICAgIGhhc1JhbmRvbSxcbiAgICAgIGE7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICB9XG5cbiAgaWYgKHN0cmluZ0ZpbHRlcikge1xuICAgIGEgPSBbc3RhcnQsIGVuZF07XG4gICAgc3RyaW5nRmlsdGVyKGEsIHRhcmdldCwgcHJvcCk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblxuICAgIHN0YXJ0ID0gYVswXTtcbiAgICBlbmQgPSBhWzFdO1xuICB9XG5cbiAgc3RhcnROdW1zID0gc3RhcnQubWF0Y2goX2NvbXBsZXhTdHJpbmdOdW1FeHApIHx8IFtdO1xuXG4gIHdoaWxlIChyZXN1bHQgPSBfY29tcGxleFN0cmluZ051bUV4cC5leGVjKGVuZCkpIHtcbiAgICBlbmROdW0gPSByZXN1bHRbMF07XG4gICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIikge1xuICAgICAgY29sb3IgPSAxO1xuICAgIH1cblxuICAgIGlmIChlbmROdW0gIT09IHN0YXJ0TnVtc1ttYXRjaEluZGV4KytdKSB7XG4gICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW21hdGNoSW5kZXggLSAxXSkgfHwgMDsgLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG4gICAgICBwdC5fcHQgPSB7XG4gICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgIGM6IGVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZE51bSkgLSBzdGFydE51bSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG4gICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgIHB0O1xuXG4gIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICAgIH1cblxuICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgcHQgPSBfcGFyc2VSZWxhdGl2ZShwYXJzZWRTdGFydCwgZW5kKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcblxuICAgICAgaWYgKHB0IHx8IHB0ID09PSAwKSB7XG4gICAgICAgIC8vIHRvIGF2b2lkIGlzTmFOLCBsaWtlIGlmIHNvbWVvbmUgcGFzc2VzIGluIGEgdmFsdWUgbGlrZSBcIiE9IHdoYXRldmVyXCJcbiAgICAgICAgZW5kID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFN0YXJ0ICE9PSBlbmQgfHwgX2ZvcmNlQWxsUHJvcFR3ZWVucykge1xuICAgIGlmICghaXNOYU4ocGFyc2VkU3RhcnQgKiBlbmQpICYmIGVuZCAhPT0gXCJcIikge1xuICAgICAgLy8gZnVuIGZhY3Q6IGFueSBudW1iZXIgbXVsdGlwbGllZCBieSBcIlwiIGlzIGV2YWx1YXRlZCBhcyB0aGUgbnVtYmVyIDAhXG4gICAgICBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgK3BhcnNlZFN0YXJ0IHx8IDAsIGVuZCAtIChwYXJzZWRTdGFydCB8fCAwKSwgdHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gXCJib29sZWFuXCIgPyBfcmVuZGVyQm9vbGVhbiA6IF9yZW5kZXJQbGFpbiwgMCwgc2V0dGVyKTtcbiAgICAgIGZ1bmNQYXJhbSAmJiAocHQuZnAgPSBmdW5jUGFyYW0pO1xuICAgICAgbW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHRoaXMsIHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHQgPSBwdDtcbiAgICB9XG5cbiAgICAhY3VycmVudFZhbHVlICYmICEocHJvcCBpbiB0YXJnZXQpICYmIF9taXNzaW5nUGx1Z2luKHByb3AsIGVuZCk7XG4gICAgcmV0dXJuIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwcm9wLCBwYXJzZWRTdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciB8fCBfY29uZmlnLnN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKTtcbiAgfVxufSxcbiAgICAvL2NyZWF0ZXMgYSBjb3B5IG9mIHRoZSB2YXJzIG9iamVjdCBhbmQgcHJvY2Vzc2VzIGFueSBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgKHB1dHRpbmcgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgY29weSkgYXMgd2VsbCBhcyBzdHJpbmdzIHdpdGggXCJyYW5kb20oKVwiIGluIHRoZW0uIEl0IGRvZXMgTk9UIHByb2Nlc3MgcmVsYXRpdmUgdmFsdWVzLlxuX3Byb2Nlc3NWYXJzID0gZnVuY3Rpb24gX3Byb2Nlc3NWYXJzKHZhcnMsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSB7XG4gIF9pc0Z1bmN0aW9uKHZhcnMpICYmICh2YXJzID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKCFfaXNPYmplY3QodmFycykgfHwgdmFycy5zdHlsZSAmJiB2YXJzLm5vZGVUeXBlIHx8IF9pc0FycmF5KHZhcnMpIHx8IF9pc1R5cGVkQXJyYXkodmFycykpIHtcbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhcnMpID8gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHZhcnM7XG4gIH1cblxuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIGNvcHlbcF0gPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFyc1twXSwgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9jaGVja1BsdWdpbiA9IGZ1bmN0aW9uIF9jaGVja1BsdWdpbihwcm9wZXJ0eSwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgdmFyIHBsdWdpbiwgcHQsIHB0TG9va3VwLCBpO1xuXG4gIGlmIChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twcm9wZXJ0eV0oKSkuaW5pdCh0YXJnZXQsIHBsdWdpbi5yYXdWYXJzID8gdmFyc1twcm9wZXJ0eV0gOiBfcHJvY2Vzc1ZhcnModmFyc1twcm9wZXJ0eV0sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICBpZiAodHdlZW4gIT09IF9xdWlja1R3ZWVuKSB7XG4gICAgICBwdExvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cFt0d2Vlbi5fdGFyZ2V0cy5pbmRleE9mKHRhcmdldCldOyAvL25vdGU6IHdlIGNhbid0IHVzZSB0d2Vlbi5fcHRMb29rdXBbaW5kZXhdIGJlY2F1c2UgZm9yIHN0YWdnZXJlZCB0d2VlbnMsIHRoZSBpbmRleCBmcm9tIHRoZSBmdWxsVGFyZ2V0cyBhcnJheSB3b24ndCBtYXRjaCB3aGF0IGl0IGlzIGluIGVhY2ggaW5kaXZpZHVhbCB0d2VlbiB0aGF0IHNwYXducyBmcm9tIHRoZSBzdGFnZ2VyLlxuXG4gICAgICBpID0gcGx1Z2luLl9wcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHRMb29rdXBbcGx1Z2luLl9wcm9wc1tpXV0gPSBwdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSxcbiAgICBfb3ZlcndyaXRpbmdUd2VlbixcbiAgICAvL3N0b3JlIGEgcmVmZXJlbmNlIHRlbXBvcmFyaWx5IHNvIHdlIGNhbiBhdm9pZCBvdmVyd3JpdGluZyBpdHNlbGYuXG5fZm9yY2VBbGxQcm9wVHdlZW5zLFxuICAgIF9pbml0VHdlZW4gPSBmdW5jdGlvbiBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lKSB7XG4gIHZhciB2YXJzID0gdHdlZW4udmFycyxcbiAgICAgIGVhc2UgPSB2YXJzLmVhc2UsXG4gICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICBsYXp5ID0gdmFycy5sYXp5LFxuICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgb25VcGRhdGVQYXJhbXMgPSB2YXJzLm9uVXBkYXRlUGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZSA9IHZhcnMuY2FsbGJhY2tTY29wZSxcbiAgICAgIHJ1bkJhY2t3YXJkcyA9IHZhcnMucnVuQmFja3dhcmRzLFxuICAgICAgeW95b0Vhc2UgPSB2YXJzLnlveW9FYXNlLFxuICAgICAga2V5ZnJhbWVzID0gdmFycy5rZXlmcmFtZXMsXG4gICAgICBhdXRvUmV2ZXJ0ID0gdmFycy5hdXRvUmV2ZXJ0LFxuICAgICAgZHVyID0gdHdlZW4uX2R1cixcbiAgICAgIHByZXZTdGFydEF0ID0gdHdlZW4uX3N0YXJ0QXQsXG4gICAgICB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwYXJlbnQgPSB0d2Vlbi5wYXJlbnQsXG4gICAgICBmdWxsVGFyZ2V0cyA9IHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIiA/IHBhcmVudC5wYXJlbnQuX3RhcmdldHMgOiB0YXJnZXRzLFxuICAgICAgYXV0b092ZXJ3cml0ZSA9IHR3ZWVuLl9vdmVyd3JpdGUgPT09IFwiYXV0b1wiICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgICAgdGwgPSB0d2Vlbi50aW1lbGluZSxcbiAgICAgIGNsZWFuVmFycyxcbiAgICAgIGksXG4gICAgICBwLFxuICAgICAgcHQsXG4gICAgICB0YXJnZXQsXG4gICAgICBoYXNQcmlvcml0eSxcbiAgICAgIGdzRGF0YSxcbiAgICAgIGhhcm5lc3MsXG4gICAgICBwbHVnaW4sXG4gICAgICBwdExvb2t1cCxcbiAgICAgIGluZGV4LFxuICAgICAgaGFybmVzc1ZhcnMsXG4gICAgICBvdmVyd3JpdHRlbjtcbiAgdGwgJiYgKCFrZXlmcmFtZXMgfHwgIWVhc2UpICYmIChlYXNlID0gXCJub25lXCIpO1xuICB0d2Vlbi5fZWFzZSA9IF9wYXJzZUVhc2UoZWFzZSwgX2RlZmF1bHRzLmVhc2UpO1xuICB0d2Vlbi5feUVhc2UgPSB5b3lvRWFzZSA/IF9pbnZlcnRFYXNlKF9wYXJzZUVhc2UoeW95b0Vhc2UgPT09IHRydWUgPyBlYXNlIDogeW95b0Vhc2UsIF9kZWZhdWx0cy5lYXNlKSkgOiAwO1xuXG4gIGlmICh5b3lvRWFzZSAmJiB0d2Vlbi5feW95byAmJiAhdHdlZW4uX3JlcGVhdCkge1xuICAgIC8vdGhlcmUgbXVzdCBoYXZlIGJlZW4gYSBwYXJlbnQgdGltZWxpbmUgd2l0aCB5b3lvOnRydWUgdGhhdCBpcyBjdXJyZW50bHkgaW4gaXRzIHlveW8gcGhhc2UsIHNvIGZsaXAgdGhlIGVhc2VzLlxuICAgIHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xuICAgIHR3ZWVuLl95RWFzZSA9IHR3ZWVuLl9lYXNlO1xuICAgIHR3ZWVuLl9lYXNlID0geW95b0Vhc2U7XG4gIH1cblxuICB0d2Vlbi5fZnJvbSA9ICF0bCAmJiAhIXZhcnMucnVuQmFja3dhcmRzOyAvL25lc3RlZCB0aW1lbGluZXMgc2hvdWxkIG5ldmVyIHJ1biBiYWNrd2FyZHMgLSB0aGUgYmFja3dhcmRzLW5lc3MgaXMgaW4gdGhlIGNoaWxkIHR3ZWVucy5cblxuICBpZiAoIXRsIHx8IGtleWZyYW1lcyAmJiAhdmFycy5zdGFnZ2VyKSB7XG4gICAgLy9pZiB0aGVyZSdzIGFuIGludGVybmFsIHRpbWVsaW5lLCBza2lwIGFsbCB0aGUgcGFyc2luZyBiZWNhdXNlIHdlIHBhc3NlZCB0aGF0IHRhc2sgZG93biB0aGUgY2hhaW4uXG4gICAgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDA7XG4gICAgaGFybmVzc1ZhcnMgPSBoYXJuZXNzICYmIHZhcnNbaGFybmVzcy5wcm9wXTsgLy9zb21lb25lIG1heSBuZWVkIHRvIHNwZWNpZnkgQ1NTLXNwZWNpZmljIHZhbHVlcyBBTkQgbm9uLUNTUyB2YWx1ZXMsIGxpa2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFuIFwieFwiIHByb3BlcnR5IHBsdXMgaXQncyBhIHN0YW5kYXJkIERPTSBlbGVtZW50LiBXZSBhbGxvdyBwZW9wbGUgdG8gZGlzdGluZ3Vpc2ggYnkgd3JhcHBpbmcgcGx1Z2luLXNwZWNpZmljIHN0dWZmIGluIGEgY3NzOnt9IG9iamVjdCBmb3IgZXhhbXBsZS5cblxuICAgIGNsZWFuVmFycyA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9yZXNlcnZlZFByb3BzKTtcblxuICAgIGlmIChwcmV2U3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQocHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSk7XG5cbiAgICAgIHByZXZTdGFydEF0Ll9sYXp5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXG4gICAgICAgIGxhenk6IF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBvblVwZGF0ZVBhcmFtczogb25VcGRhdGVQYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrU2NvcGU6IGNhbGxiYWNrU2NvcGUsXG4gICAgICAgIHN0YWdnZXI6IDBcbiAgICAgIH0sIHN0YXJ0QXQpKSk7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCBmcm9tLCB0bykuZnJvbVRvKGUsIHRvLCBmcm9tKTtcblxuXG4gICAgICB0aW1lIDwgMCAmJiAhaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0ICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgdHdlZW4uXG5cbiAgICAgIGlmIChpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgdGltZSA+IDAgJiYgIWF1dG9SZXZlcnQgJiYgKHR3ZWVuLl9zdGFydEF0ID0gMCk7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lIGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlIG9yIHdoZW4gYXV0b1JldmVydCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuXG4gICAgICAgIGlmIChkdXIgJiYgdGltZSA8PSAwKSB7XG4gICAgICAgICAgdGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG4gICAgICAgICAgcmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuICAgICAgICB9IC8vIGlmICh0aW1lID4gMCkge1xuICAgICAgICAvLyBcdGF1dG9SZXZlcnQgfHwgKHR3ZWVuLl9zdGFydEF0ID0gMCk7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lIGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlIG9yIHdoZW4gYXV0b1JldmVydCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuICAgICAgICAvLyB9IGVsc2UgaWYgKGR1ciAmJiAhKHRpbWUgPCAwICYmIHByZXZTdGFydEF0KSkge1xuICAgICAgICAvLyBcdHRpbWUgJiYgKHR3ZWVuLl96VGltZSA9IHRpbWUpO1xuICAgICAgICAvLyBcdHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZSwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cbiAgICAgICAgLy8gfVxuXG4gICAgICB9IGVsc2UgaWYgKGF1dG9SZXZlcnQgPT09IGZhbHNlKSB7XG4gICAgICAgIHR3ZWVuLl9zdGFydEF0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJ1bkJhY2t3YXJkcyAmJiBkdXIpIHtcbiAgICAgIC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcbiAgICAgIGlmIChwcmV2U3RhcnRBdCkge1xuICAgICAgICAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWUgJiYgKGltbWVkaWF0ZVJlbmRlciA9IGZhbHNlKTsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblxuICAgICAgICBwID0gX3NldERlZmF1bHRzKHtcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGRhdGE6IFwiaXNGcm9tU3RhcnRcIixcbiAgICAgICAgICAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cbiAgICAgICAgICBsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuICAgICAgICAgIHN0YWdnZXI6IDAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OmdzYXAudXRpbHMud3JhcChbLTEwMCwxMDBdKX0pXG5cbiAgICAgICAgfSwgY2xlYW5WYXJzKTtcbiAgICAgICAgaGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTsgLy8gaW4gY2FzZSBzb21lb25lIGRvZXMgc29tZXRoaW5nIGxpa2UgLmZyb20oLi4uLCB7Y3NzOnt9fSlcblxuICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBwKSk7XG5cbiAgICAgICAgdGltZSA8IDAgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy8gcmFyZSBlZGdlIGNhc2UsIGxpa2UgaWYgYSByZW5kZXIgaXMgZm9yY2VkIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgYSBub24taW5pdHRlZCBmcm9tKCkgdHdlZW4uXG5cbiAgICAgICAgdHdlZW4uX3pUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0d2Vlbi5fcHQgPSB0d2Vlbi5fcHRDYWNoZSA9IDA7XG4gICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgIHR3ZWVuLl9wdExvb2t1cFtpXSA9IHB0TG9va3VwID0ge307XG4gICAgICBfbGF6eUxvb2t1cFtnc0RhdGEuaWRdICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXG4gICAgICBpbmRleCA9IGZ1bGxUYXJnZXRzID09PSB0YXJnZXRzID8gaSA6IGZ1bGxUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgICAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHBsdWdpbi5uYW1lLCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICAgICAgcGx1Z2luLl9wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcHRMb29rdXBbbmFtZV0gPSBwdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcm5lc3MgfHwgaGFybmVzc1ZhcnMpIHtcbiAgICAgICAgZm9yIChwIGluIGNsZWFuVmFycykge1xuICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcbiAgICAgICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fb3AgJiYgdHdlZW4uX29wW2ldICYmIHR3ZWVuLmtpbGwodGFyZ2V0LCB0d2Vlbi5fb3BbaV0pO1xuXG4gICAgICBpZiAoYXV0b092ZXJ3cml0ZSAmJiB0d2Vlbi5fcHQpIHtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSB0d2VlbjtcblxuICAgICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldCwgcHRMb29rdXAsIHR3ZWVuLmdsb2JhbFRpbWUodGltZSkpOyAvLyBtYWtlIHN1cmUgdGhlIG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb3ZlcndyaXRlIFRISVMgdHdlZW4hISFcblxuXG4gICAgICAgIG92ZXJ3cml0dGVuID0gIXR3ZWVuLnBhcmVudDtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fcHQgJiYgbGF6eSAmJiAoX2xhenlMb29rdXBbZ3NEYXRhLmlkXSA9IDEpO1xuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodHdlZW4pO1xuICAgIHR3ZWVuLl9vbkluaXQgJiYgdHdlZW4uX29uSW5pdCh0d2Vlbik7IC8vcGx1Z2lucyBsaWtlIFJvdW5kUHJvcHMgbXVzdCB3YWl0IHVudGlsIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyBhcmUgaW5zdGFudGlhdGVkLiBJbiB0aGUgcGx1Z2luJ3MgaW5pdCgpIGZ1bmN0aW9uLCBpdCBzZXRzIHRoZSBfb25Jbml0IG9uIHRoZSB0d2VlbiBpbnN0YW5jZS4gTWF5IG5vdCBiZSBwcmV0dHkvaW50dWl0aXZlLCBidXQgaXQncyBmYXN0IGFuZCBrZWVwcyBmaWxlIHNpemUgZG93bi5cbiAgfVxuXG4gIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICB0d2Vlbi5faW5pdHRlZCA9ICghdHdlZW4uX29wIHx8IHR3ZWVuLl9wdCkgJiYgIW92ZXJ3cml0dGVuOyAvLyBpZiBvdmVyd3JpdHRlblByb3BzIHJlc3VsdGVkIGluIHRoZSBlbnRpcmUgdHdlZW4gYmVpbmcga2lsbGVkLCBkbyBOT1QgZmxhZyBpdCBhcyBpbml0dGVkIG9yIGVsc2UgaXQgbWF5IHJlbmRlciBmb3Igb25lIHRpY2suXG5cbiAga2V5ZnJhbWVzICYmIHRpbWUgPD0gMCAmJiB0bC5yZW5kZXIoX2JpZ051bSwgdHJ1ZSwgdHJ1ZSk7IC8vIGlmIHRoZXJlJ3MgYSAwJSBrZXlmcmFtZSwgaXQnbGwgcmVuZGVyIGluIHRoZSBcImJlZm9yZVwiIHN0YXRlIGZvciBhbnkgc3RhZ2dlcmVkL2RlbGF5ZWQgYW5pbWF0aW9ucyB0aHVzIHdoZW4gdGhlIGZvbGxvd2luZyB0d2VlbiBpbml0aWFsaXplcywgaXQnbGwgdXNlIHRoZSBcImJlZm9yZVwiIHN0YXRlIGluc3RlYWQgb2YgdGhlIFwiYWZ0ZXJcIiBzdGF0ZSBhcyB0aGUgaW5pdGlhbCB2YWx1ZXMuXG59LFxuICAgIF91cGRhdGVQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3VwZGF0ZVByb3BUd2VlbnModHdlZW4sIHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSwgcmF0aW8sIHRpbWUpIHtcbiAgdmFyIHB0Q2FjaGUgPSAodHdlZW4uX3B0ICYmIHR3ZWVuLl9wdENhY2hlIHx8ICh0d2Vlbi5fcHRDYWNoZSA9IHt9KSlbcHJvcGVydHldLFxuICAgICAgcHQsXG4gICAgICBsb29rdXAsXG4gICAgICBpO1xuXG4gIGlmICghcHRDYWNoZSkge1xuICAgIHB0Q2FjaGUgPSB0d2Vlbi5fcHRDYWNoZVtwcm9wZXJ0eV0gPSBbXTtcbiAgICBsb29rdXAgPSB0d2Vlbi5fcHRMb29rdXA7XG4gICAgaSA9IHR3ZWVuLl90YXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHB0ID0gbG9va3VwW2ldW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKHB0ICYmIHB0LmQgJiYgcHQuZC5fcHQpIHtcbiAgICAgICAgLy8gaXQncyBhIHBsdWdpbiwgc28gZmluZCB0aGUgbmVzdGVkIFByb3BUd2VlblxuICAgICAgICBwdCA9IHB0LmQuX3B0O1xuXG4gICAgICAgIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wZXJ0eSkge1xuICAgICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwdCkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIHRoYXQgcHJvcGVydHksIHNvIHdlIG11c3QgRk9SQ0Ugb25lIHRvIGJlIGNyZWF0ZWQgYW5kIGRpdGNoIG91dCBvZiB0aGlzXG4gICAgICAgIC8vIGlmIHRoZSB0d2VlbiBoYXMgb3RoZXIgcHJvcGVydGllcyB0aGF0IGFscmVhZHkgcmVuZGVyZWQgYXQgbmV3IHBvc2l0aW9ucywgd2UnZCBub3JtYWxseSBoYXZlIHRvIHJld2luZCB0byBwdXQgdGhlbSBiYWNrIGxpa2UgdHdlZW4ucmVuZGVyKDAsIHRydWUpIGJlZm9yZSBmb3JjaW5nIGFuIF9pbml0VHdlZW4oKSwgYnV0IHRoYXQgY2FuIGNyZWF0ZSBhbm90aGVyIGVkZ2UgY2FzZSBsaWtlIHR3ZWVuaW5nIGEgdGltZWxpbmUncyBwcm9ncmVzcyB3b3VsZCB0cmlnZ2VyIG9uVXBkYXRlcyB0byBmaXJlIHdoaWNoIGNvdWxkIG1vdmUgb3RoZXIgdGhpbmdzIGFyb3VuZC4gSXQncyBiZXR0ZXIgdG8ganVzdCBpbmZvcm0gdXNlcnMgdGhhdCAucmVzZXRUbygpIHNob3VsZCBPTkxZIGJlIHVzZWQgZm9yIHR3ZWVucyB0aGF0IGFscmVhZHkgaGF2ZSB0aGF0IHByb3BlcnR5LiBGb3IgZXhhbXBsZSwgeW91IGNhbid0IGdzYXAudG8oLi4ueyB5OiAwIH0pIGFuZCB0aGVuIHR3ZWVuLnJlc3RUbyhcInhcIiwgMjAwKSBmb3IgZXhhbXBsZS5cbiAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDE7IC8vIG90aGVyd2lzZSwgd2hlbiB3ZSBfYWRkUHJvcFR3ZWVuKCkgYW5kIGl0IGZpbmRzIG5vIGNoYW5nZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcywgaXQgc2tpcHMgY3JlYXRpbmcgYSBQcm9wVHdlZW4gKGZvciBlZmZpY2llbmN5Li4ud2h5IHR3ZWVuIHdoZW4gdGhlcmUncyBubyBkaWZmZXJlbmNlPykgYnV0IGluIHRoaXMgY2FzZSB3ZSBORUVEIHRoYXQgUHJvcFR3ZWVuIGNyZWF0ZWQgc28gd2UgY2FuIGVkaXQgaXQuXG5cbiAgICAgICAgdHdlZW4udmFyc1twcm9wZXJ0eV0gPSBcIis9MFwiO1xuXG4gICAgICAgIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpO1xuXG4gICAgICAgIF9mb3JjZUFsbFByb3BUd2VlbnMgPSAwO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcHRDYWNoZS5wdXNoKHB0KTtcbiAgICB9XG4gIH1cblxuICBpID0gcHRDYWNoZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHB0ID0gcHRDYWNoZVtpXTtcbiAgICBwdC5zID0gKHN0YXJ0IHx8IHN0YXJ0ID09PSAwKSAmJiAhc3RhcnRJc1JlbGF0aXZlID8gc3RhcnQgOiBwdC5zICsgKHN0YXJ0IHx8IDApICsgcmF0aW8gKiBwdC5jO1xuICAgIHB0LmMgPSB2YWx1ZSAtIHB0LnM7XG4gICAgcHQuZSAmJiAocHQuZSA9IF9yb3VuZCh2YWx1ZSkgKyBnZXRVbml0KHB0LmUpKTsgLy8gbWFpbmx5IGZvciBDU1NQbHVnaW4gKGVuZCB2YWx1ZSlcblxuICAgIHB0LmIgJiYgKHB0LmIgPSBwdC5zICsgZ2V0VW5pdChwdC5iKSk7IC8vIChiZWdpbm5pbmcgdmFsdWUpXG4gIH1cbn0sXG4gICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMCxcbiAgICAgIHByb3BlcnR5QWxpYXNlcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzLFxuICAgICAgY29weSxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgYWxpYXNlcztcblxuICBpZiAoIXByb3BlcnR5QWxpYXNlcykge1xuICAgIHJldHVybiB2YXJzO1xuICB9XG5cbiAgY29weSA9IF9tZXJnZSh7fSwgdmFycyk7XG5cbiAgZm9yIChwIGluIHByb3BlcnR5QWxpYXNlcykge1xuICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgIGFsaWFzZXMgPSBwcm9wZXJ0eUFsaWFzZXNbcF0uc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IGFsaWFzZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICAvLyBwYXJzZXMgbXVsdGlwbGUgZm9ybWF0cywgbGlrZSB7XCIwJVwiOiB7eDogMTAwfSwge1wiNTAlXCI6IHt4OiAtMjB9fSBhbmQgeyB4OiB7XCIwJVwiOiAxMDAsIFwiNTAlXCI6IC0yMH0gfSwgYW5kIGFuIFwiZWFzZVwiIGNhbiBiZSBzZXQgb24gYW55IG9iamVjdC4gV2UgcG9wdWxhdGUgYW4gXCJhbGxQcm9wc1wiIG9iamVjdCB3aXRoIGFuIEFycmF5IGZvciBlYWNoIHByb3BlcnR5LCBsaWtlIHt4OiBbe30sIHt9XSwgeTpbe30sIHt9XX0gd2l0aCBkYXRhIGZvciBlYWNoIHByb3BlcnR5IHR3ZWVuLiBUaGUgb2JqZWN0cyBoYXZlIGEgXCJ0XCIgKHRpbWUpLCBcInZcIiwgKHZhbHVlKSwgYW5kIFwiZVwiIChlYXNlKSBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgdXMgdG8gcGllY2UgdG9nZXRoZXIgYSB0aW1lbGluZSBsYXRlci5cbl9wYXJzZUtleWZyYW1lID0gZnVuY3Rpb24gX3BhcnNlS2V5ZnJhbWUocHJvcCwgb2JqLCBhbGxQcm9wcywgZWFzZUVhY2gpIHtcbiAgdmFyIGVhc2UgPSBvYmouZWFzZSB8fCBlYXNlRWFjaCB8fCBcInBvd2VyMS5pbk91dFwiLFxuICAgICAgcCxcbiAgICAgIGE7XG5cbiAgaWYgKF9pc0FycmF5KG9iaikpIHtcbiAgICBhID0gYWxsUHJvcHNbcHJvcF0gfHwgKGFsbFByb3BzW3Byb3BdID0gW10pOyAvLyB0ID0gdGltZSAob3V0IG9mIDEwMCksIHYgPSB2YWx1ZSwgZSA9IGVhc2VcblxuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGEucHVzaCh7XG4gICAgICAgIHQ6IGkgLyAob2JqLmxlbmd0aCAtIDEpICogMTAwLFxuICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChwIGluIG9iaikge1xuICAgICAgYSA9IGFsbFByb3BzW3BdIHx8IChhbGxQcm9wc1twXSA9IFtdKTtcbiAgICAgIHAgPT09IFwiZWFzZVwiIHx8IGEucHVzaCh7XG4gICAgICAgIHQ6IHBhcnNlRmxvYXQocHJvcCksXG4gICAgICAgIHY6IG9ialtwXSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgfnZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpID8gX3JlcGxhY2VSYW5kb20odmFsdWUpIDogdmFsdWU7XG59LFxuICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlLGF1dG9SZXZlcnRcIixcbiAgICBfc3RhZ2dlclByb3BzVG9Ta2lwID0ge307XG5cbl9mb3JFYWNoTmFtZShfc3RhZ2dlclR3ZWVuUHJvcHMgKyBcIixpZCxzdGFnZ2VyLGRlbGF5LGR1cmF0aW9uLHBhdXNlZCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfc3RhZ2dlclByb3BzVG9Ta2lwW25hbWVdID0gMTtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFR3ZWVuLCBfQW5pbWF0aW9uMik7XG5cbiAgZnVuY3Rpb24gVHdlZW4odGFyZ2V0cywgdmFycywgcG9zaXRpb24sIHNraXBJbmhlcml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGlmICh0eXBlb2YgdmFycyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcG9zaXRpb24uZHVyYXRpb24gPSB2YXJzO1xuICAgICAgdmFycyA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSkgfHwgdGhpcztcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczMkdmFycy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBzdGFnZ2VyID0gX3RoaXMzJHZhcnMuc3RhZ2dlcixcbiAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMzJHZhcnMuZGVmYXVsdHMsXG4gICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICB5b3lvRWFzZSA9IF90aGlzMyR2YXJzLnlveW9FYXNlLFxuICAgICAgICBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICB0bCxcbiAgICAgICAgaSxcbiAgICAgICAgY29weSxcbiAgICAgICAgbCxcbiAgICAgICAgcCxcbiAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICBzdGFnZ2VyRnVuYyxcbiAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlO1xuICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9ncmVlbnNvY2suY29tXCIsICFfY29uZmlnLm51bGxUYXJnZXRXYXJuKSB8fCBbXTtcbiAgICBfdGhpczMuX3B0TG9va3VwID0gW107IC8vUHJvcFR3ZWVuIGxvb2t1cC4gQW4gYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QgZm9yIGVhY2ggdGFyZ2V0LCBoYXZpbmcga2V5cyBmb3IgZWFjaCB0d2VlbmluZyBwcm9wZXJ0eVxuXG4gICAgX3RoaXMzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG5cbiAgICBpZiAoa2V5ZnJhbWVzIHx8IHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICB2YXJzID0gX3RoaXMzLnZhcnM7XG4gICAgICB0bCA9IF90aGlzMy50aW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gICAgICAgIGRhdGE6IFwibmVzdGVkXCIsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyB8fCB7fVxuICAgICAgfSk7XG4gICAgICB0bC5raWxsKCk7XG4gICAgICB0bC5wYXJlbnQgPSB0bC5fZHAgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG4gICAgICB0bC5fc3RhcnQgPSAwO1xuXG4gICAgICBpZiAoc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgICAgbCA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuICAgICAgICBzdGFnZ2VyRnVuYyA9IHN0YWdnZXIgJiYgZGlzdHJpYnV0ZShzdGFnZ2VyKTtcblxuICAgICAgICBpZiAoX2lzT2JqZWN0KHN0YWdnZXIpKSB7XG4gICAgICAgICAgLy91c2VycyBjYW4gcGFzcyBpbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0L29uQ29tcGxldGUgaW4gdGhlIHN0YWdnZXIgb2JqZWN0LiBUaGVzZSBzaG91bGQgZmlyZSB3aXRoIGVhY2ggaW5kaXZpZHVhbCB0d2Vlbi5cbiAgICAgICAgICBmb3IgKHAgaW4gc3RhZ2dlcikge1xuICAgICAgICAgICAgaWYgKH5fc3RhZ2dlclR3ZWVuUHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgfHwgKHN0YWdnZXJWYXJzVG9NZXJnZSA9IHt9KTtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlW3BdID0gc3RhZ2dlcltwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29weSA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9zdGFnZ2VyUHJvcHNUb1NraXApO1xuICAgICAgICAgIGNvcHkuc3RhZ2dlciA9IDA7XG4gICAgICAgICAgeW95b0Vhc2UgJiYgKGNvcHkueW95b0Vhc2UgPSB5b3lvRWFzZSk7XG4gICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlICYmIF9tZXJnZShjb3B5LCBzdGFnZ2VyVmFyc1RvTWVyZ2UpO1xuICAgICAgICAgIGN1clRhcmdldCA9IHBhcnNlZFRhcmdldHNbaV07IC8vZG9uJ3QganVzdCBjb3B5IGR1cmF0aW9uIG9yIGRlbGF5IGJlY2F1c2UgaWYgdGhleSdyZSBhIHN0cmluZyBvciBmdW5jdGlvbiwgd2UnZCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIF9pc0Z1bmNPclN0cmluZygpIHdvdWxkIGV2YWx1YXRlIGFzIHRydWUgaW4gdGhlIGNoaWxkIHR3ZWVucywgZW50ZXJpbmcgdGhpcyBsb29wLCBldGMuIFNvIHdlIHBhcnNlIHRoZSB2YWx1ZSBzdHJhaWdodCBmcm9tIHZhcnMgYW5kIGRlZmF1bHQgdG8gMC5cblxuICAgICAgICAgIGNvcHkuZHVyYXRpb24gPSArX3BhcnNlRnVuY09yU3RyaW5nKGR1cmF0aW9uLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cyk7XG4gICAgICAgICAgY29weS5kZWxheSA9ICgrX3BhcnNlRnVuY09yU3RyaW5nKGRlbGF5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgfHwgMCkgLSBfdGhpczMuX2RlbGF5O1xuXG4gICAgICAgICAgaWYgKCFzdGFnZ2VyICYmIGwgPT09IDEgJiYgY29weS5kZWxheSkge1xuICAgICAgICAgICAgLy8gaWYgc29tZW9uZSBkb2VzIGRlbGF5OlwicmFuZG9tKDEsIDUpXCIsIHJlcGVhdDotMSwgZm9yIGV4YW1wbGUsIHRoZSBkZWxheSBzaG91bGRuJ3QgYmUgaW5zaWRlIHRoZSByZXBlYXQuXG4gICAgICAgICAgICBfdGhpczMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xuICAgICAgICAgICAgX3RoaXMzLl9zdGFydCArPSBkZWxheTtcbiAgICAgICAgICAgIGNvcHkuZGVsYXkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRsLnRvKGN1clRhcmdldCwgY29weSwgc3RhZ2dlckZ1bmMgPyBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIDogMCk7XG4gICAgICAgICAgdGwuX2Vhc2UgPSBfZWFzZU1hcC5ub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGwuZHVyYXRpb24oKSA/IGR1cmF0aW9uID0gZGVsYXkgPSAwIDogX3RoaXMzLnRpbWVsaW5lID0gMDsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXG4gICAgICB9IGVsc2UgaWYgKGtleWZyYW1lcykge1xuICAgICAgICBfaW5oZXJpdERlZmF1bHRzKF9zZXREZWZhdWx0cyh0bC52YXJzLmRlZmF1bHRzLCB7XG4gICAgICAgICAgZWFzZTogXCJub25lXCJcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRsLl9lYXNlID0gX3BhcnNlRWFzZShrZXlmcmFtZXMuZWFzZSB8fCB2YXJzLmVhc2UgfHwgXCJub25lXCIpO1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAga2YsXG4gICAgICAgICAgICB2O1xuXG4gICAgICAgIGlmIChfaXNBcnJheShrZXlmcmFtZXMpKSB7XG4gICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICBwID09PSBcImVhc2VcIiB8fCBwID09PSBcImVhc2VFYWNoXCIgfHwgX3BhcnNlS2V5ZnJhbWUocCwga2V5ZnJhbWVzW3BdLCBjb3B5LCBrZXlmcmFtZXMuZWFzZUVhY2gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAocCBpbiBjb3B5KSB7XG4gICAgICAgICAgICBhID0gY29weVtwXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnQgLSBiLnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWUgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBrZiA9IGFbaV07XG4gICAgICAgICAgICAgIHYgPSB7XG4gICAgICAgICAgICAgICAgZWFzZToga2YuZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogKGtmLnQgLSAoaSA/IGFbaSAtIDFdLnQgOiAwKSkgLyAxMDAgKiBkdXJhdGlvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2W3BdID0ga2YudjtcbiAgICAgICAgICAgICAgdGwudG8ocGFyc2VkVGFyZ2V0cywgdiwgdGltZSk7XG4gICAgICAgICAgICAgIHRpbWUgKz0gdi5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC5kdXJhdGlvbigpIDwgZHVyYXRpb24gJiYgdGwudG8oe30sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAtIHRsLmR1cmF0aW9uKClcbiAgICAgICAgICB9KTsgLy8gaW4gY2FzZSBrZXlmcmFtZXMgZGlkbid0IGdvIHRvIDEwMCVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGUgPT09IHRydWUgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMpIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUocGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHBvc2l0aW9uKTtcblxuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpczMucGF1c2VkKHRydWUpO1xuXG4gICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgX3RoaXMzLl90VGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXG4gICAgfVxuXG4gICAgc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgaXNZb3lvLFxuICAgICAgICByYXRpbyxcbiAgICAgICAgdGltZWxpbmUsXG4gICAgICAgIHlveW9FYXNlO1xuXG4gICAgaWYgKCFkdXIpIHtcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCkge1xuICAgICAgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xuICAgICAgICAgIC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcblxuICAgICAgICBpZiAoaXNZb3lvKSB7XG4gICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgIC8vY291bGQgYmUgZHVyaW5nIHRoZSByZXBlYXREZWxheSBwYXJ0LiBObyBuZWVkIHRvIHJlbmRlciBhbmQgZmlyZSBjYWxsYmFja3MuXG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7IC8vcmVwZWF0UmVmcmVzaCBmdW5jdGlvbmFsaXR5XG5cbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kUHJlY2lzZShjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkge1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gMDsgLy8gaW4gY29uc3RydWN0b3IgaWYgaW1tZWRpYXRlUmVuZGVyIGlzIHRydWUsIHdlIHNldCBfdFRpbWUgdG8gLV90aW55TnVtIHRvIGhhdmUgdGhlIHBsYXloZWFkIGNyb3NzIHRoZSBzdGFydGluZyBwb2ludCBidXQgd2UgY2FuJ3QgbGVhdmUgX3RUaW1lIGFzIGEgbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUpIHtcbiAgICAgICAgICAvLyByYXJlIGVkZ2UgY2FzZSAtIGR1cmluZyBpbml0aWFsaXphdGlvbiwgYW4gb25VcGRhdGUgaW4gdGhlIF9zdGFydEF0ICguZnJvbVRvKCkpIG1pZ2h0IGZvcmNlIHRoaXMgdHdlZW4gdG8gcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgZGl0Y2ggdGhpcyByZW5kZXIoKSBjYWxsIHNvIHRoYXQgaXQgZG9lc24ndCByZXZlcnQgdGhlIHZhbHVlcy5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXIgIT09IHRoaXMuX2R1cikge1xuICAgICAgICAgIC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgaWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcbiAgICAgICAgdGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgICAgdGhpcy5fbGF6eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZSAmJiAhcHJldlRpbWUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uU3RhcnRcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkge1xuICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG9uU3RhcnQgdHJpZ2dlcmVkIGEgcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QsIGVqZWN0LiBMaWtlIGlmIHNvbWVvbmUgZGlkIGFuaW1hdGlvbi5wYXVzZSgwLjUpIG9yIHNvbWV0aGluZyBpbnNpZGUgdGhlIG9uU3RhcnQuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHQgPSB0aGlzLl9wdDtcblxuICAgICAgd2hpbGUgKHB0KSB7XG4gICAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgICAgfVxuXG4gICAgICB0aW1lbGluZSAmJiB0aW1lbGluZS5yZW5kZXIodG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6ICF0aW1lICYmIGlzWW95byA/IC1fdGlueU51bSA6IHRpbWVsaW5lLl9kdXIgKiB0aW1lbGluZS5fZWFzZSh0aW1lIC8gdGhpcy5fZHVyKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB8fCB0aGlzLl9zdGFydEF0ICYmICh0aGlzLl96VGltZSA9IHRvdGFsVGltZSk7XG5cbiAgICAgIGlmICh0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBlYXQgJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmIHRoaXMudmFycy5vblJlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cbiAgICAgIGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcbiAgICAgICAgdG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdGhpcy5fdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB3ZSdyZSByZW5kZXJpbmcgYXQgZXhhY3RseSBhIHRpbWUgb2YgMCwgYXMgdGhlcmUgY291bGQgYmUgYXV0b1JldmVydCB2YWx1ZXMgdGhhdCBzaG91bGQgZ2V0IHNldCBvbiB0aGUgbmV4dCB0aWNrIChpZiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0VGltZSwgbmVnYXRpdmUgdG90YWxUaW1lKS4gRG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUpKSB7XG4gICAgICAgICAgLy8gaWYgcHJldlRpbWUgYW5kIHRUaW1lIGFyZSB6ZXJvLCB3ZSBzaG91bGRuJ3QgZmlyZSB0aGUgb25SZXZlcnNlQ29tcGxldGUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHlvdSBnc2FwLnRvKC4uLiB7cGF1c2VkOnRydWV9KS5wbGF5KCk7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMy50YXJnZXRzID0gZnVuY3Rpb24gdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cztcbiAgfTtcblxuICBfcHJvdG8zLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9sYXp5ID0gdGhpcy5yYXRpbyA9IDA7XG4gICAgdGhpcy5fcHRMb29rdXAgPSBbXTtcbiAgICB0aGlzLnRpbWVsaW5lICYmIHRoaXMudGltZWxpbmUuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiBfQW5pbWF0aW9uMi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzMucmVzZXRUbyA9IGZ1bmN0aW9uIHJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKSB7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICB0aGlzLl90cyB8fCB0aGlzLnBsYXkoKTtcbiAgICB2YXIgdGltZSA9IE1hdGgubWluKHRoaXMuX2R1ciwgKHRoaXMuX2RwLl90aW1lIC0gdGhpcy5fc3RhcnQpICogdGhpcy5fdHMpLFxuICAgICAgICByYXRpbztcbiAgICB0aGlzLl9pbml0dGVkIHx8IF9pbml0VHdlZW4odGhpcywgdGltZSk7XG4gICAgcmF0aW8gPSB0aGlzLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpOyAvLyBkb24ndCBqdXN0IGdldCB0d2Vlbi5yYXRpbyBiZWNhdXNlIGl0IG1heSBub3QgaGF2ZSByZW5kZXJlZCB5ZXQuXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIHRvIGFsbG93IGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHZhbHVlcyB0byB1cGRhdGUsIGxpa2UgdHdlZW4ucmVzZXRUbyh7eDogMTAwLCB5OiAyMDB9KTsgQXQgdGhpcyBwb2ludCwgaXQgZG9lc24ndCBzZWVtIHdvcnRoIHRoZSBhZGRlZCBrYiBnaXZlbiB0aGUgZmFjdCB0aGF0IG1vc3QgdXNlcnMgd2lsbCBsaWtlbHkgb3B0IGZvciB0aGUgY29udmVuaWVudCBnc2FwLnF1aWNrVG8oKSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIG1ldGhvZC5cbiAgICAvLyBpZiAoX2lzT2JqZWN0KHByb3BlcnR5KSkgeyAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAgICAvLyBcdGZvciAocCBpbiBwcm9wZXJ0eSkge1xuICAgIC8vIFx0XHRpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcCwgcHJvcGVydHlbcF0sIHZhbHVlID8gdmFsdWVbcF0gOiBudWxsLCBzdGFydCwgcmF0aW8sIHRpbWUpKSB7XG4gICAgLy8gXHRcdFx0cmV0dXJuIHRoaXMucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpOyAvLyBpZiBhIFByb3BUd2VlbiB3YXNuJ3QgZm91bmQgZm9yIHRoZSBwcm9wZXJ0eSwgaXQnbGwgZ2V0IGZvcmNlZCB3aXRoIGEgcmUtaW5pdGlhbGl6YXRpb24gc28gd2UgbmVlZCB0byBqdW1wIG91dCBhbmQgc3RhcnQgb3ZlciBhZ2Fpbi5cbiAgICAvLyBcdFx0fVxuICAgIC8vIFx0fVxuICAgIC8vIH0gZWxzZSB7XG5cbiAgICBpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKTsgLy8gaWYgYSBQcm9wVHdlZW4gd2Fzbid0IGZvdW5kIGZvciB0aGUgcHJvcGVydHksIGl0J2xsIGdldCBmb3JjZWQgd2l0aCBhIHJlLWluaXRpYWxpemF0aW9uIHNvIHdlIG5lZWQgdG8ganVtcCBvdXQgYW5kIHN0YXJ0IG92ZXIgYWdhaW4uXG4gICAgfSAvL31cblxuXG4gICAgX2FsaWduUGxheWhlYWQodGhpcywgMCk7XG5cbiAgICB0aGlzLnBhcmVudCB8fCBfYWRkTGlua2VkTGlzdEl0ZW0odGhpcy5fZHAsIHRoaXMsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGhpcy5fZHAuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKDApO1xuICB9O1xuXG4gIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSBcImFsbFwiO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0cyAmJiAoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikpIHtcbiAgICAgIHRoaXMuX2xhenkgPSB0aGlzLl9wdCA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyBfaW50ZXJydXB0KHRoaXMpIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lbGluZSkge1xuICAgICAgdmFyIHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcbiAgICAgIHRoaXMudGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHZhcnMsIF9vdmVyd3JpdGluZ1R3ZWVuICYmIF9vdmVyd3JpdGluZ1R3ZWVuLnZhcnMub3ZlcndyaXRlICE9PSB0cnVlKS5fZmlyc3QgfHwgX2ludGVycnVwdCh0aGlzKTsgLy8gaWYgbm90aGluZyBpcyBsZWZ0IHR3ZWVuaW5nLCBpbnRlcnJ1cHQuXG5cbiAgICAgIHRoaXMucGFyZW50ICYmIHREdXIgIT09IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpICYmIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9kdXIgKiB0aGlzLnRpbWVsaW5lLl90RHVyIC8gdER1ciwgMCwgMSk7IC8vIGlmIGEgbmVzdGVkIHR3ZWVuIGlzIGtpbGxlZCB0aGF0IGNoYW5nZXMgdGhlIGR1cmF0aW9uLCBpdCBzaG91bGQgYWZmZWN0IHRoaXMgdHdlZW4ncyBkdXJhdGlvbi4gV2UgbXVzdCB1c2UgdGhlIHJhdGlvLCB0aG91Z2gsIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBpbnRlcm5hbCB0aW1lbGluZSBpcyBzdHJldGNoZWQgbGlrZSBmb3Iga2V5ZnJhbWVzIHdoZXJlIHRoZXkgZG9uJ3QgYWxsIGFkZCB1cCB0byB3aGF0ZXZlciB0aGUgcGFyZW50IHR3ZWVuJ3MgZHVyYXRpb24gd2FzIHNldCB0by5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcbiAgICAgICAgcHJvcFR3ZWVuTG9va3VwID0gdGhpcy5fcHRMb29rdXAsXG4gICAgICAgIGZpcnN0UFQgPSB0aGlzLl9wdCxcbiAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcbiAgICAgICAgY3VyTG9va3VwLFxuICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHAsXG4gICAgICAgIHB0LFxuICAgICAgICBpO1xuXG4gICAgaWYgKCghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSAmJiBfYXJyYXlzTWF0Y2gocGFyc2VkVGFyZ2V0cywga2lsbGluZ1RhcmdldHMpKSB7XG4gICAgICB2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xuICAgICAgcmV0dXJuIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgfVxuXG4gICAgb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX29wID0gdGhpcy5fb3AgfHwgW107XG5cbiAgICBpZiAodmFycyAhPT0gXCJhbGxcIikge1xuICAgICAgLy9zbyBwZW9wbGUgY2FuIHBhc3MgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICBwID0ge307XG5cbiAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHBbbmFtZV0gPSAxO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXJzID0gcDtcbiAgICAgIH1cblxuICAgICAgdmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xuICAgIH1cblxuICAgIGkgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh+a2lsbGluZ1RhcmdldHMuaW5kZXhPZihwYXJzZWRUYXJnZXRzW2ldKSkge1xuICAgICAgICBjdXJMb29rdXAgPSBwcm9wVHdlZW5Mb29rdXBbaV07XG5cbiAgICAgICAgaWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICBvdmVyd3JpdHRlblByb3BzW2ldID0gdmFycztcbiAgICAgICAgICBwcm9wcyA9IGN1ckxvb2t1cDtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gfHwge307XG4gICAgICAgICAgcHJvcHMgPSB2YXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwIGluIHByb3BzKSB7XG4gICAgICAgICAgcHQgPSBjdXJMb29rdXAgJiYgY3VyTG9va3VwW3BdO1xuXG4gICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICBpZiAoIShcImtpbGxcIiBpbiBwdC5kKSB8fCBwdC5kLmtpbGwocCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGN1ckxvb2t1cFtwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VyT3ZlcndyaXRlUHJvcHMgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzW3BdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUICYmIF9pbnRlcnJ1cHQodGhpcyk7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgVHdlZW4udG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgxLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFR3ZWVuLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbihjYWxsYmFjaywgMCwge1xuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIG9uQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGU6IHNjb3BlXG4gICAgfSk7XG4gIH07XG5cbiAgVHdlZW4uZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFR3ZWVuLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgdmFycy5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMpO1xuICB9O1xuXG4gIFR3ZWVuLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKTtcbiAgfTtcblxuICByZXR1cm4gVHdlZW47XG59KEFuaW1hdGlvbik7XG5cbl9zZXREZWZhdWx0cyhUd2Vlbi5wcm90b3R5cGUsIHtcbiAgX3RhcmdldHM6IFtdLFxuICBfbGF6eTogMCxcbiAgX3N0YXJ0QXQ6IDAsXG4gIF9vcDogMCxcbiAgX29uSW5pdDogMFxufSk7IC8vYWRkIHRoZSBwZXJ0aW5lbnQgdGltZWxpbmUgbWV0aG9kcyB0byBUd2VlbiBpbnN0YW5jZXMgc28gdGhhdCB1c2VycyBjYW4gY2hhaW4gY29udmVuaWVudGx5IGFuZCBjcmVhdGUgYSB0aW1lbGluZSBhdXRvbWF0aWNhbGx5LiAocmVtb3ZlZCBkdWUgdG8gY29uY2VybnMgdGhhdCBpdCdkIHVsdGltYXRlbHkgYWRkIHRvIG1vcmUgY29uZnVzaW9uIGVzcGVjaWFsbHkgZm9yIGJlZ2lubmVycylcbi8vIF9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLHNldCxjYWxsLGFkZCxhZGRMYWJlbCxhZGRQYXVzZVwiLCBuYW1lID0+IHtcbi8vIFx0VHdlZW4ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4vLyBcdFx0bGV0IHRsID0gbmV3IFRpbWVsaW5lKCk7XG4vLyBcdFx0cmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRsLCB0aGlzKVtuYW1lXS5hcHBseSh0bCwgdG9BcnJheShhcmd1bWVudHMpKTtcbi8vIFx0fVxuLy8gfSk7XG4vL2ZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBMZXZlcmFnZSB0aGUgdGltZWxpbmUgY2FsbHMuXG5cblxuX2ZvckVhY2hOYW1lKFwic3RhZ2dlclRvLHN0YWdnZXJGcm9tLHN0YWdnZXJGcm9tVG9cIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgVHdlZW5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKCksXG4gICAgICAgIHBhcmFtcyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICBwYXJhbXMuc3BsaWNlKG5hbWUgPT09IFwic3RhZ2dlckZyb21Ub1wiID8gNSA6IDQsIDAsIDApO1xuICAgIHJldHVybiB0bFtuYW1lXS5hcHBseSh0bCwgcGFyYW1zKTtcbiAgfTtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQUk9QVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG52YXIgX3NldHRlclBsYWluID0gZnVuY3Rpb24gX3NldHRlclBsYWluKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJGdW5jID0gZnVuY3Rpb24gX3NldHRlckZ1bmModGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0odmFsdWUpO1xufSxcbiAgICBfc2V0dGVyRnVuY1dpdGhQYXJhbSA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jV2l0aFBhcmFtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKGRhdGEuZnAsIHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9zZXR0ZXJBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHZhbHVlKTtcbn0sXG4gICAgX2dldFNldHRlciA9IGZ1bmN0aW9uIF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odGFyZ2V0W3Byb3BlcnR5XSkgPyBfc2V0dGVyRnVuYyA6IF9pc1VuZGVmaW5lZCh0YXJnZXRbcHJvcGVydHldKSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlID8gX3NldHRlckF0dHJpYnV0ZSA6IF9zZXR0ZXJQbGFpbjtcbn0sXG4gICAgX3JlbmRlclBsYWluID0gZnVuY3Rpb24gX3JlbmRlclBsYWluKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDAwMCkgLyAxMDAwMDAwLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckJvb2xlYW4gPSBmdW5jdGlvbiBfcmVuZGVyQm9vbGVhbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsICEhKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDb21wbGV4U3RyaW5nID0gZnVuY3Rpb24gX3JlbmRlckNvbXBsZXhTdHJpbmcocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICBzID0gXCJcIjtcblxuICBpZiAoIXJhdGlvICYmIGRhdGEuYikge1xuICAgIC8vYiA9IGJlZ2lubmluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5iO1xuICB9IGVsc2UgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuZSkge1xuICAgIC8vZSA9IGVuZGluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5lO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChwdCkge1xuICAgICAgcyA9IHB0LnAgKyAocHQubSA/IHB0Lm0ocHQucyArIHB0LmMgKiByYXRpbykgOiBNYXRoLnJvdW5kKChwdC5zICsgcHQuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIHM7IC8vd2UgdXNlIHRoZSBcInBcIiBwcm9wZXJ0eSBmb3IgdGhlIHRleHQgaW5iZXR3ZWVuIChsaWtlIGEgc3VmZml4KS4gQW5kIGluIHRoZSBjb250ZXh0IG9mIGEgY29tcGxleCBzdHJpbmcsIHRoZSBtb2RpZmllciAobSkgaXMgdHlwaWNhbGx5IGp1c3QgTWF0aC5yb3VuZCgpLCBsaWtlIGZvciBSR0IgY29sb3JzLlxuXG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHMgKz0gZGF0YS5jOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgY2h1bmsgb2Ygbm9uLW51bWVyaWMgdGV4dC5cbiAgfVxuXG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBzLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFR3ZWVucyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG59LFxuICAgIF9hZGRQbHVnaW5Nb2RpZmllciA9IGZ1bmN0aW9uIF9hZGRQbHVnaW5Nb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdC5wID09PSBwcm9wZXJ0eSAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCk7XG4gICAgcHQgPSBuZXh0O1xuICB9XG59LFxuICAgIF9raWxsUHJvcFR3ZWVuc09mID0gZnVuY3Rpb24gX2tpbGxQcm9wVHdlZW5zT2YocHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcblxuICAgIGlmIChwdC5wID09PSBwcm9wZXJ0eSAmJiAhcHQub3AgfHwgcHQub3AgPT09IHByb3BlcnR5KSB7XG4gICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuICAgIH0gZWxzZSBpZiAoIXB0LmRlcCkge1xuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nID0gMTtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gIWhhc05vbkRlcGVuZGVudFJlbWFpbmluZztcbn0sXG4gICAgX3NldHRlcldpdGhNb2RpZmllciA9IGZ1bmN0aW9uIF9zZXR0ZXJXaXRoTW9kaWZpZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgZGF0YS5tU2V0KHRhcmdldCwgcHJvcGVydHksIGRhdGEubS5jYWxsKGRhdGEudHdlZW4sIHZhbHVlLCBkYXRhLm10KSwgZGF0YSk7XG59LFxuICAgIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkgPSBmdW5jdGlvbiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHBhcmVudCkge1xuICB2YXIgcHQgPSBwYXJlbnQuX3B0LFxuICAgICAgbmV4dCxcbiAgICAgIHB0MixcbiAgICAgIGZpcnN0LFxuICAgICAgbGFzdDsgLy9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gZG8gdGhlaXIgd29yayBhZnRlciBBTEwgb2YgdGhlIFByb3BUd2VlbnMgd2VyZSBjcmVhdGVkIChsaWtlIFJvdW5kUHJvcHNQbHVnaW4gYW5kIE1vZGlmaWVyc1BsdWdpbilcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQyID0gZmlyc3Q7XG5cbiAgICB3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG4gICAgICBwdDIgPSBwdDIuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkge1xuICAgICAgcHQuX3ByZXYuX25leHQgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3QgPSBwdDtcbiAgICB9XG5cbiAgICBpZiAocHQuX25leHQgPSBwdDIpIHtcbiAgICAgIHB0Mi5fcHJldiA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gcHQ7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcGFyZW50Ll9wdCA9IGZpcnN0O1xufTsgLy9Qcm9wVHdlZW4ga2V5OiB0ID0gdGFyZ2V0LCBwID0gcHJvcCwgciA9IHJlbmRlcmVyLCBkID0gZGF0YSwgcyA9IHN0YXJ0LCBjID0gY2hhbmdlLCBvcCA9IG92ZXJ3cml0ZVByb3BlcnR5IChPTkxZIHBvcHVsYXRlZCB3aGVuIGl0J3MgZGlmZmVyZW50IHRoYW4gcCksIHByID0gcHJpb3JpdHksIF9uZXh0L19wcmV2IGZvciB0aGUgbGlua2VkIGxpc3Qgc2libGluZ3MsIHNldCA9IHNldHRlciwgbSA9IG1vZGlmaWVyLCBtU2V0ID0gbW9kaWZpZXJTZXR0ZXIgKHRoZSBvcmlnaW5hbCBzZXR0ZXIsIGJlZm9yZSBhIG1vZGlmaWVyIHdhcyBhZGRlZClcblxuXG5leHBvcnQgdmFyIFByb3BUd2VlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BUd2VlbihuZXh0LCB0YXJnZXQsIHByb3AsIHN0YXJ0LCBjaGFuZ2UsIHJlbmRlcmVyLCBkYXRhLCBzZXR0ZXIsIHByaW9yaXR5KSB7XG4gICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgIHRoaXMucyA9IHN0YXJ0O1xuICAgIHRoaXMuYyA9IGNoYW5nZTtcbiAgICB0aGlzLnAgPSBwcm9wO1xuICAgIHRoaXMuciA9IHJlbmRlcmVyIHx8IF9yZW5kZXJQbGFpbjtcbiAgICB0aGlzLmQgPSBkYXRhIHx8IHRoaXM7XG4gICAgdGhpcy5zZXQgPSBzZXR0ZXIgfHwgX3NldHRlclBsYWluO1xuICAgIHRoaXMucHIgPSBwcmlvcml0eSB8fCAwO1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIG5leHQuX3ByZXYgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gUHJvcFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG80Lm1vZGlmaWVyID0gZnVuY3Rpb24gbW9kaWZpZXIoZnVuYywgdHdlZW4sIHRhcmdldCkge1xuICAgIHRoaXMubVNldCA9IHRoaXMubVNldCB8fCB0aGlzLnNldDsgLy9pbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHNldCAoYSBQcm9wVHdlZW4gY2FuIG9ubHkgaGF2ZSBvbmUgbW9kaWZpZXIpXG5cbiAgICB0aGlzLnNldCA9IF9zZXR0ZXJXaXRoTW9kaWZpZXI7XG4gICAgdGhpcy5tID0gZnVuYztcbiAgICB0aGlzLm10ID0gdGFyZ2V0OyAvL21vZGlmaWVyIHRhcmdldFxuXG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuICB9O1xuXG4gIHJldHVybiBQcm9wVHdlZW47XG59KCk7IC8vSW5pdGlhbGl6YXRpb24gdGFza3NcblxuX2ZvckVhY2hOYW1lKF9jYWxsYmFja05hbWVzICsgXCJwYXJlbnQsZHVyYXRpb24sZWFzZSxkZWxheSxvdmVyd3JpdGUscnVuQmFja3dhcmRzLHN0YXJ0QXQseW95byxpbW1lZGlhdGVSZW5kZXIscmVwZWF0LHJlcGVhdERlbGF5LGRhdGEscGF1c2VkLHJldmVyc2VkLGxhenksY2FsbGJhY2tTY29wZSxzdHJpbmdGaWx0ZXIsaWQseW95b0Vhc2Usc3RhZ2dlcixpbmhlcml0LHJlcGVhdFJlZnJlc2gsa2V5ZnJhbWVzLGF1dG9SZXZlcnQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xufSk7XG5cbl9nbG9iYWxzLlR3ZWVuTWF4ID0gX2dsb2JhbHMuVHdlZW5MaXRlID0gVHdlZW47XG5fZ2xvYmFscy5UaW1lbGluZUxpdGUgPSBfZ2xvYmFscy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xuX2dsb2JhbFRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgc29ydENoaWxkcmVuOiBmYWxzZSxcbiAgZGVmYXVsdHM6IF9kZWZhdWx0cyxcbiAgYXV0b1JlbW92ZUNoaWxkcmVuOiB0cnVlLFxuICBpZDogXCJyb290XCIsXG4gIHNtb290aENoaWxkVGltaW5nOiB0cnVlXG59KTtcbl9jb25maWcuc3RyaW5nRmlsdGVyID0gX2NvbG9yU3RyaW5nRmlsdGVyO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBHU0FQXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBfZ3NhcCA9IHtcbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZVBsdWdpbihjb25maWcpO1xuICAgIH0pO1xuICB9LFxuICB0aW1lbGluZTogZnVuY3Rpb24gdGltZWxpbmUodmFycykge1xuICAgIHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG4gIH0sXG4gIGdldFR3ZWVuc09mOiBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKTtcbiAgfSxcbiAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIGdldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTsgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG5cbiAgICB2YXIgZ2V0dGVyID0gX2dldENhY2hlKHRhcmdldCB8fCB7fSkuZ2V0LFxuICAgICAgICBmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXG4gICAgdW5pdCA9PT0gXCJuYXRpdmVcIiAmJiAodW5pdCA9IFwiXCIpO1xuICAgIHJldHVybiAhdGFyZ2V0ID8gdGFyZ2V0IDogIXByb3BlcnR5ID8gZnVuY3Rpb24gKHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgICB9IDogZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgfSxcbiAgcXVpY2tTZXR0ZXI6IGZ1bmN0aW9uIHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcbiAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldCk7XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZ3NhcC5xdWlja1NldHRlcih0LCBwcm9wZXJ0eSwgdW5pdCk7XG4gICAgICB9KSxcbiAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gbDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgc2V0dGVyc1tpXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0WzBdIHx8IHt9O1xuXG4gICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcbiAgICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgcCA9IGNhY2hlLmhhcm5lc3MgJiYgKGNhY2hlLmhhcm5lc3MuYWxpYXNlcyB8fCB7fSlbcHJvcGVydHldIHx8IHByb3BlcnR5LFxuICAgICAgICAvLyBpbiBjYXNlIGl0J3MgYW4gYWxpYXMsIGxpa2UgXCJyb3RhdGVcIiBmb3IgXCJyb3RhdGlvblwiLlxuICAgIHNldHRlciA9IFBsdWdpbiA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgPSAwO1xuICAgICAgcC5pbml0KHRhcmdldCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBfcXVpY2tUd2VlbiwgMCwgW3RhcmdldF0pO1xuICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xuICAgIH0gOiBjYWNoZS5zZXQodGFyZ2V0LCBwKTtcblxuICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIodGFyZ2V0LCBwLCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIGNhY2hlLCAxKTtcbiAgICB9O1xuICB9LFxuICBxdWlja1RvOiBmdW5jdGlvbiBxdWlja1RvKHRhcmdldCwgcHJvcGVydHksIHZhcnMpIHtcbiAgICB2YXIgX21lcmdlMjtcblxuICAgIHZhciB0d2VlbiA9IGdzYXAudG8odGFyZ2V0LCBfbWVyZ2UoKF9tZXJnZTIgPSB7fSwgX21lcmdlMltwcm9wZXJ0eV0gPSBcIis9MC4xXCIsIF9tZXJnZTIucGF1c2VkID0gdHJ1ZSwgX21lcmdlMiksIHZhcnMgfHwge30pKSxcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmModmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpIHtcbiAgICAgIHJldHVybiB0d2Vlbi5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSk7XG4gICAgfTtcblxuICAgIGZ1bmMudHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gZnVuYztcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICB2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmMy5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYzLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB3cmFwOiB3cmFwLFxuICAgIHdyYXBZb3lvOiB3cmFwWW95byxcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZ2V0VW5pdDogZ2V0VW5pdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgcGlwZTogcGlwZSxcbiAgICB1bml0aXplOiB1bml0aXplLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICBzaHVmZmxlOiBzaHVmZmxlXG4gIH0sXG4gIGluc3RhbGw6IF9pbnN0YWxsLFxuICBlZmZlY3RzOiBfZWZmZWN0cyxcbiAgdGlja2VyOiBfdGlja2VyLFxuICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICBwbHVnaW5zOiBfcGx1Z2lucyxcbiAgZ2xvYmFsVGltZWxpbmU6IF9nbG9iYWxUaW1lbGluZSxcbiAgY29yZToge1xuICAgIFByb3BUd2VlbjogUHJvcFR3ZWVuLFxuICAgIGdsb2JhbHM6IF9hZGRHbG9iYWwsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFRpbWVsaW5lOiBUaW1lbGluZSxcbiAgICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbTogX3JlbW92ZUxpbmtlZExpc3RJdGVtLFxuICAgIHN1cHByZXNzT3ZlcndyaXRlczogZnVuY3Rpb24gc3VwcHJlc3NPdmVyd3JpdGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sZGVsYXllZENhbGwsc2V0LGtpbGxUd2VlbnNPZlwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcbn0pO1xuXG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcblxuX3F1aWNrVHdlZW4gPSBfZ3NhcC50byh7fSwge1xuICBkdXJhdGlvbjogMFxufSk7IC8vIC0tLS0gRVhUUkEgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XG4gIHZhciBwdCA9IHBsdWdpbi5fcHQ7XG5cbiAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYWRkTW9kaWZpZXJzID0gZnVuY3Rpb24gX2FkZE1vZGlmaWVycyh0d2VlbiwgbW9kaWZpZXJzKSB7XG4gIHZhciB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIHB0O1xuXG4gIGZvciAocCBpbiBtb2RpZmllcnMpIHtcbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblxuICAgICAgaWYgKHB0ICYmIChwdCA9IHB0LmQpKSB7XG4gICAgICAgIGlmIChwdC5fcHQpIHtcbiAgICAgICAgICAvLyBpcyBhIHBsdWdpblxuICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdCAmJiBwdC5tb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllcnNbcF0sIHR3ZWVuLCB0YXJnZXRzW2ldLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2J1aWxkTW9kaWZpZXJQbHVnaW4gPSBmdW5jdGlvbiBfYnVpbGRNb2RpZmllclBsdWdpbihuYW1lLCBtb2RpZmllcikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3VmFyczogMSxcbiAgICAvL2Rvbid0IHByZS1wcm9jZXNzIGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBvciBcInJhbmRvbSgpXCIgc3RyaW5ncy5cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcbiAgICAgIHR3ZWVuLl9vbkluaXQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdmFyIHRlbXAsIHA7XG5cbiAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBbbmFtZV0gPSAxO1xuICAgICAgICAgIH0pOyAvL2lmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHRvIHJvdW5kUHJvcHMsIGxpa2UgXCJ4LHlcIiwgd2Ugcm91bmQgdG8gd2hvbGUgbnVtYmVycy5cblxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgdGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vcmVnaXN0ZXIgY29yZSBwbHVnaW5zXG5cblxuZXhwb3J0IHZhciBnc2FwID0gX2dzYXAucmVnaXN0ZXJQbHVnaW4oe1xuICBuYW1lOiBcImF0dHJcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwLCBwdDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICBwdCAmJiAocHQub3AgPSBwKTtcblxuICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogXCJlbmRBcnJheVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjEwLjRcIjtcbl9jb3JlUmVhZHkgPSAxO1xuX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG52YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcbiAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcbiAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcbiAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxuICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXG4gICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxuICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuZXhwb3J0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5cbmV4cG9ydCB7IF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX3JlcGxhY2VSYW5kb20sIF9jaGVja1BsdWdpbiwgX3BsdWdpbnMsIF90aWNrZXIsIF9jb25maWcsIF9yb3VuZE1vZGlmaWVyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUgfTsiLCJpbXBvcnQgeyBnc2FwLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMsIFR3ZWVuTGl0ZSwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCB9IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuaW1wb3J0IHsgQ1NTUGx1Z2luIH0gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG52YXIgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCxcbiAgICAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5Ud2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuZXhwb3J0IHsgZ3NhcFdpdGhDU1MgYXMgZ3NhcCwgZ3NhcFdpdGhDU1MgYXMgZGVmYXVsdCwgQ1NTUGx1Z2luLCBUd2Vlbk1heFdpdGhDU1MgYXMgVHdlZW5NYXgsIFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXgsIFRpbWVsaW5lTGl0ZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07IiwiaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBBTklNQVRJT05cbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vICBURVNUIEhFTExPXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBoZWxsbygpIHtcbiAgICBjb25zb2xlLmxvZyhcIkhFTExPXCIpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvLyAgQkxPQ0sgVEVYVFxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgdGV4dEluKHRhcmdldF8pIHtcbiAgICBsZXQgaWQgPSB0YXJnZXRfLmVsLmRhdGFzZXQuaWQ7XG4gICAgbGV0IHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIicgKyBpZCArICdcIl0nKTtcbiAgICBnc2FwLmZyb21UbyhcbiAgICAgIHQsXG4gICAgICB7XG4gICAgICAgIHlQZXJjZW50OiAyMCxcbiAgICAgICAgcm90YXRlOiAzLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZHVyYXRpb246IDIsXG4gICAgICAgIGVhc2U6IFwicG93ZXIyLm91dFwiLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICByb3RhdGU6IDAsXG4gICAgICAgIHlQZXJjZW50OiAwLFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vICBCTE9DSyBJTUFHRVNcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGltYWdlSW4odGFyZ2V0Xykge1xuICAgIGxldCBpZCA9IHRhcmdldF8uZWwuZGF0YXNldC5pZDtcbiAgICBsZXQgdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwiJyArIGlkICsgJ1wiXScpO1xuXG4gICAgZ3NhcC5mcm9tVG8oXG4gICAgICB0LFxuICAgICAge1xuICAgICAgICB5UGVyY2VudDogMjAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgZWFzZTogXCJwb3dlcjIub3V0XCIsXG4gICAgICAgIHlQZXJjZW50OiAwLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vICBCTE9DSyBWSURFT1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgdmlkZW9Jbih0YXJnZXRfKSB7XG4gICAgbGV0IGlkID0gdGFyZ2V0Xy5lbC5kYXRhc2V0LmlkO1xuICAgIGxldCB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCInICsgaWQgKyAnXCJdJyk7XG5cbiAgICBnc2FwLmZyb21UbyhcbiAgICAgIHQsXG4gICAgICB7XG4gICAgICAgIHlQZXJjZW50OiAyMCxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGR1cmF0aW9uOiAyLFxuICAgICAgICBlYXNlOiBcInBvd2VyMi5vdXRcIixcbiAgICAgICAgeVBlcmNlbnQ6IDAsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IG1lZGlhTG9hZGVkIGZyb20gXCJAbWFlZXJ0aW4vbWVkaWFsb2FkZWRcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBMT0FERVJcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9hZE1lZGlhKCk7XG4gIH1cblxuICBsb2FkTWVkaWEoKSB7XG4gICAgY29uc3QgcHJlbG9hZEltZyA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7fSk7XG5cbiAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIudmlkZW9cIik7XG4gICAgY29uc29sZS5sb2coZWxlbWVudHMpO1xuICAgIG1lZGlhTG9hZGVkKGVsZW1lbnRzLCAoaW5zdGFuY2UpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQWxsIG1lZGlhIGxvYWRlZFwiLCBpbnN0YW5jZSk7XG4gICAgfSk7XG5cbiAgICBsZXQgYWxsRG9uZSA9IFtwcmVsb2FkSW1nXTtcblxuICAgIFByb21pc2UuYWxsKGFsbERvbmUpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coXCJNRURJQSBMT0FERURcIik7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHJlc3BvbnNpdmUgZnJvbSBcIi4uL3V0aWxzL3Jlc3BvbnNpdmVcIjtcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG4vLyBpbXBvcnQgeyB0cmFuc2l0aW9uIH0gZnJvbSBcIi4uL2luZGV4XCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vLyAgTUVOVVxuLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWVudVwiKTtcbiAgICB0aGlzLm1lbnVfdHJpZ2dlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWVudV90cmlnZ2VyXCIpO1xuICAgIHRoaXMubWVudV9zdGF0dXMgPSBcIm9mZlwiO1xuICAgIHRoaXMubWVudV9hbmltYXRpb25fdGltZSA9IDE7XG4gICAgdGhpcy5tZW51X2Vhc2UgPSBcInBvd2VyMi5pbk91dFwiO1xuXG4gICAgdGhpcy5wcmltYXJ5X21lbnUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3ByaW1hcnktbWVudVwiKTtcbiAgICB0aGlzLmxpX2xpc3QgPSB0aGlzLnByaW1hcnlfbWVudS5xdWVyeVNlbGVjdG9yQWxsKFwibGlcIik7XG5cbiAgICB0aGlzLmhvbWVfdXJsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNsb2dvXCIpLmhyZWY7XG5cbiAgICB0aGlzLm1lbnVUcmlnZ2VyKCk7XG4gIH1cblxuICBtZW51VHJpZ2dlcigpIHtcbiAgICB0aGlzLm1lbnVfdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLm1lbnVfdHJpZ2dlci5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIikpIHtcbiAgICAgICAgdGhpcy5jbG9zZU1lbnUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVudV90cmlnZ2VyLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgIHRoaXMubWVudV9zdGF0dXMgPSBcIm9uXCI7XG4gICAgICAgIHRoaXMub3Blbk1lbnUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG9wZW5NZW51KCkge1xuICAgIHRoaXMubWVudV90cmlnZ2VyLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgdGhpcy5tZW51X3N0YXR1cyA9IFwib25cIjtcblxuICAgIGdzYXAudG8oXCIjbWVudVwiLCB7XG4gICAgICBkdXJhdGlvbjogdGhpcy5tZW51X2FuaW1hdGlvbl90aW1lLFxuICAgICAgZWFzZTogdGhpcy5tZW51X2Vhc2UsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIH0pO1xuXG4gICAgZ3NhcC5mcm9tVG8oXG4gICAgICBcIiNtZW51IGxpIGFcIixcbiAgICAgIHtcbiAgICAgICAgeVBlcmNlbnQ6IC0xMDAsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkZWxheTogMC41LFxuICAgICAgICBkdXJhdGlvbjogMC44LFxuICAgICAgICBlYXNlOiBcInBvd2VyMy5vdXRcIixcbiAgICAgICAgeVBlcmNlbnQ6IDAsXG4gICAgICAgIHN0YWdnZXI6IDAuMSxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgY2xvc2VNZW51KCkge1xuICAgIHRoaXMubWVudV90cmlnZ2VyLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgdGhpcy5tZW51X3N0YXR1cyA9IFwib2ZmXCI7XG5cbiAgICBnc2FwLnRvKFwiI21lbnVcIiwge1xuICAgICAgZHVyYXRpb246IHRoaXMubWVudV9hbmltYXRpb25fdGltZSxcbiAgICAgIGVhc2U6IHRoaXMubWVudV9lYXNlLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgIH0pO1xuICB9XG5cbiAgdGVzdCgpIHtcbiAgICBpZiAocmVzcG9uc2l2ZS5yc3AoUlNQX01EKSkge1xuICAgICAgY29uc29sZS5sb2coXCJCSUdHRVIgVEhBTiBNT0JJTEVcIik7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBzY3JvbGwgfSBmcm9tIFwiLi4vaW5kZXhcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBSQUZcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJBRiB7XG4gIGNvbnN0cnVjdG9yKCkge31cblxuICByZW5kZXIoKSB7XG4gICAgc2Nyb2xsLmluZm8oKTtcbiAgICBzY3JvbGwub3B0aW1pc2F0aW9uKCk7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgfVxufVxuIiwiaW1wb3J0IGJhcmJhIGZyb20gXCJAYmFyYmEvY29yZVwiO1xuLy8gaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgeyBzY3JvbGwgfSBmcm9tIFwiLi4vaW5kZXhcIjtcbi8vIGltcG9ydCB7IGFuaW1hdGlvbiB9IGZyb20gJy4uL2luZGV4Jztcbi8vIGltcG9ydCB7IG5hdmlnYXRpb24gfSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyB2aWRlb2Jsb2NrIH0gZnJvbSBcIi4uL2luZGV4XCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vLyAgVFJBTlNJVElPTlNcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zaXRpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgbGV0IHRoYXQgPSB0aGlzO1xuXG4gICAgYmFyYmEuaW5pdCh7XG4gICAgICBkZWJ1ZzogdHJ1ZSxcblxuICAgICAgdHJhbnNpdGlvbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICBERUZBVUxUXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICBuYW1lOiBcImRlZmF1bHQtdHJhbnNpdGlvblwiLFxuICAgICAgICAgIGxlYXZlKGRhdGEpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTEVBVkUnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudGVyKGRhdGEpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRU5URVInKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFmdGVyKGRhdGEpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQUZURVInKTtcbiAgICAgICAgICAgIHZpZGVvYmxvY2suc3RhcnRBdXRvcGxheSgpO1xuICAgICAgICAgICAgdmlkZW9ibG9jay5jb3ZlckFjdGlvbigpO1xuICAgICAgICAgICAgc2Nyb2xsLnJlc2V0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSk7XG4gIH1cblxuICBsaW5rKGxpbmtfKSB7XG4gICAgbGV0IGxpbmsgPSBsaW5rXztcbiAgICBiYXJiYS5nbyhsaW5rKTtcbiAgfVxufVxuIiwiaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBWSURFTyBCTE9DS1xuLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlkZW9ibG9jayB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgIHRoaXMuY292ZXJBY3Rpb24oKTtcbiAgfVxuXG4gIHN0YXJ0QXV0b3BsYXkoKSB7XG4gICAgbGV0IHZpZGVvX2xpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmJsb2NrX3ZpZGVvIC52aWRlb1wiKTtcbiAgICB2aWRlb19saXN0LmZvckVhY2goKG8pID0+IHtcbiAgICAgIG8ucGxheSgpO1xuICAgIH0pO1xuICB9XG5cbiAgY292ZXJBY3Rpb24oKSB7XG4gICAgbGV0IHZpZGVvX2xpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmJsb2NrX3ZpZGVvIC5jb3ZlclwiKTtcbiAgICB2aWRlb19saXN0LmZvckVhY2goKG8pID0+IHtcbiAgICAgIGxldCBwYXJlbnQgPSBvLnBhcmVudE5vZGU7XG4gICAgICBsZXQgZW1iZWRkZWQgPSBwYXJlbnQucXVlcnlTZWxlY3RvcihcIi5lbWJlZGRlZCBpZnJhbWVcIik7XG4gICAgICBvLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZW1iZWRkZWQuc3JjICs9IFwiJmF1dG9wbGF5PTFcIjtcbiAgICAgICAgdGhpcy5oaWRlQ292ZXIobyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGhpZGVDb3Zlcih0YXJnZXRfKSB7XG4gICAgbGV0IHQgPSB0YXJnZXRfO1xuXG4gICAgZ3NhcC50byh0LCB7XG4gICAgICBkdXJhdGlvbjogMSxcbiAgICAgIGVhc2U6IFwicG93ZXIyLmluT3V0XCIsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB0LnJlbW92ZSgpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vICBHTE9CQUxTXG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gIFJFU1BPTlNJVkUgQlJFQUtQT0lOVFMgKEJBU0VEIE9OIEJPT1RTVFJBUClcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmdsb2JhbC5SU1BfWFhTID0gMzIwO1xuZ2xvYmFsLlJTUF9YUyA9IDM3NTtcbmdsb2JhbC5SU1BfU00gPSA3Njg7XG5nbG9iYWwuUlNQX01EID0gOTkyO1xuZ2xvYmFsLlJTUF9MRyA9IDEyMDA7XG5nbG9iYWwuUlNQX1hMID0gMTQwMDtcbmdsb2JhbC5SU1BfWFhMID0gMTYwMDtcbiIsImltcG9ydCBHTE9CQUxTIGZyb20gXCIuL2dsb2JhbHNcIjtcbmltcG9ydCAqIGFzIHJlc3BvbnNpdmUgZnJvbSBcIi4vdXRpbHMvcmVzcG9uc2l2ZVwiO1xuaW1wb3J0IE5hdmlnYXRpb24gZnJvbSBcIi4vY2xhc3Nlcy9OYXZpZ2F0aW9uXCI7XG5pbXBvcnQgU2Nyb2xsIGZyb20gXCIuL2NsYXNzZXMvU2Nyb2xsXCI7XG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gXCIuL2NsYXNzZXMvQW5pbWF0aW9uXCI7XG5pbXBvcnQgVHJhbnNpdGlvbiBmcm9tIFwiLi9jbGFzc2VzL1RyYW5zaXRpb25cIjtcbmltcG9ydCBSQUYgZnJvbSBcIi4vY2xhc3Nlcy9SQUZcIjtcbmltcG9ydCBWaWRlb2Jsb2NrIGZyb20gXCIuL2NsYXNzZXMvVmlkZW9ibG9ja1wiO1xuaW1wb3J0IExvYWRlciBmcm9tIFwiLi9jbGFzc2VzL0xvYWRlclwiO1xuXG5yZXNwb25zaXZlLmNzc1NldFRvdWNoRGV2aWNlcyhcImh0bWxcIiwgXCJ0b3VjaFwiLCBcIm5vX3RvdWNoXCIpO1xuXG5leHBvcnQgY29uc3QgbmF2aWdhdGlvbiA9IG5ldyBOYXZpZ2F0aW9uKCk7XG5cbmV4cG9ydCBjb25zdCBzY3JvbGwgPSBuZXcgU2Nyb2xsKCk7XG5cbmV4cG9ydCBjb25zdCB0cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb24oKTtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcblxuY29uc3QgcmFmID0gbmV3IFJBRigpO1xuXG5leHBvcnQgY29uc3QgdmlkZW9ibG9jayA9IG5ldyBWaWRlb2Jsb2NrKCk7XG5cbmNvbnN0IGxvYWRlciA9IG5ldyBMb2FkZXIoKTtcblxuY29uc29sZS5sb2coc2Nyb2xsKTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgbG9hZGVyLmhpZGVMb2FkZXIoKTtcbiAgc2Nyb2xsLmluaXQoKTtcbiAgc2Nyb2xsLmFjdGlvbigpO1xuICByYWYucmVuZGVyKCk7XG59KTtcblxuY29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNoZWFkZXJcIik7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIChlKSA9PiB7XG4gIGlmICh3aW5kb3cuc2Nyb2xsWSA+PSAyMDApIHtcbiAgICBoZWFkZXIuY2xhc3NMaXN0LmFkZChcInN0aWNreVwiKTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIuY2xhc3NMaXN0LnJlbW92ZShcInN0aWNreVwiKTtcbiAgfVxufSk7XG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCJmOGJkNWYxZDg1NGE5ODgyMzc2NlwiKSJdLCJuYW1lcyI6WyJfY2F0Y2giLCJib2R5IiwicmVjb3ZlciIsInJlc3VsdCIsImUiLCJ0aGVuIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJhc3luY0l0ZXJhdG9yIiwiTG9nTGV2ZWxzIiwiSG9va01ldGhvZHMiLCJfbGV2ZWwiLCJvZmYiLCJMb2dnZXIiLCJzb3VyY2UiLCJ0aGlzIiwiX3NvdXJjZSIsImdldExldmVsIiwic2V0TGV2ZWwiLCJuYW1lIiwiZXJyb3IiLCJvYmplY3RzIiwiX2xvZyIsImNvbnNvbGUiLCJ3YXJuIiwid2FybmluZyIsImluZm8iLCJkZWJ1ZyIsImxvZyIsImZuIiwibGV2ZWwiLCJhcHBseSIsImNvbmNhdCIsInBhdGhUb1JlZ2V4cCIsInJlZ2V4cFRvRnVuY3Rpb24iLCJwYXJzZSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cCIsIkRFRkFVTFRfREVMSU1JVEVSIiwiUEFUSF9SRUdFWFAiLCJSZWdFeHAiLCJqb2luIiwic3RyIiwib3B0aW9ucyIsInJlcyIsInRva2VucyIsImtleSIsImluZGV4IiwicGF0aCIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJ3aGl0ZWxpc3QiLCJ1bmRlZmluZWQiLCJwYXRoRXNjYXBlZCIsImV4ZWMiLCJtIiwiZXNjYXBlZCIsIm9mZnNldCIsInNsaWNlIiwibGVuZ3RoIiwicHJldiIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiayIsImMiLCJpbmRleE9mIiwicHVzaCIsInBhdHRlcm4iLCJwcmVmaXgiLCJvcHRpb25hbCIsInJlcGVhdCIsImVzY2FwZUdyb3VwIiwiZXNjYXBlU3RyaW5nIiwic3Vic3RyIiwicmUiLCJrZXlzIiwicGF0aG5hbWUiLCJwYXJhbXMiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJpIiwic3BsaXQiLCJtYXAiLCJ2YWx1ZSIsIm1hdGNoZXMiLCJBcnJheSIsImZsYWdzIiwiZGF0YSIsImVuY29kZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInZhbGlkYXRlIiwidG9rZW4iLCJzZWdtZW50IiwiaXNBcnJheSIsIlR5cGVFcnJvciIsImoiLCJ0ZXN0IiwiU3RyaW5nIiwicmVwbGFjZSIsInNlbnNpdGl2ZSIsInN0cmljdCIsInN0YXJ0IiwiZW5kIiwiZW5kc1dpdGgiLCJyb3V0ZSIsImVuZFRva2VuIiwiaXNFbmREZWxpbWl0ZWQiLCJncm91cHMiLCJtYXRjaCIsInJlZ2V4cFRvUmVnZXhwIiwicGFydHMiLCJhcnJheVRvUmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzY2hlbWFBdHRyaWJ1dGUiLCJjb250YWluZXIiLCJoaXN0b3J5IiwibmFtZXNwYWNlIiwicHJldmVudCIsIndyYXBwZXIiLCJkb20iLCJET01QYXJzZXIiLCJ0b1N0cmluZyIsImVsIiwib3V0ZXJIVE1MIiwidG9Eb2N1bWVudCIsImh0bWxTdHJpbmciLCJfcGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwibiIsInRvRWxlbWVudCIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImdldEh0bWwiLCJkb2MiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRXcmFwcGVyIiwic2NvcGUiLCJxdWVyeVNlbGVjdG9yIiwiX2F0dHIiLCJnZXRDb250YWluZXIiLCJyZW1vdmVDb250YWluZXIiLCJjb250YWlucyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImFkZENvbnRhaW5lciIsImV4aXN0aW5nQ29udGFpbmVyIiwiX2luc2VydEFmdGVyIiwiYXBwZW5kQ2hpbGQiLCJnZXROYW1lc3BhY2UiLCJucyIsImdldEF0dHJpYnV0ZSIsImdldEhyZWYiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJocmVmIiwicmVzb2x2ZVVybCIsImJhc2VWYWwiLCJ1cmxzIiwibnVtVXJscyIsIkVycm9yIiwiYmFzZSIsImFyZ3VtZW50cyIsImhlYWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJyZXNvbHZlZCIsImEiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsIm5leHRTaWJsaW5nIiwiaW5pdCIsInVybCIsIl9zZXNzaW9uIiwic3RhdGUiLCJzY3JvbGwiLCJ4Iiwid2luZG93Iiwic2Nyb2xsWCIsInkiLCJzY3JvbGxZIiwiX3N0YXRlcyIsIl9wb2ludGVyIiwiaXRlbSIsImZyb20iLCJzdGF0ZXMiLCJyZXBsYWNlU3RhdGUiLCJjaGFuZ2UiLCJ0cmlnZ2VyIiwiX2dldERpcmVjdGlvbiIsImFkZCIsInNpemUiLCJhY3Rpb24iLCJfZ2V0QWN0aW9uIiwicHVzaFN0YXRlIiwidXBkYXRlIiwiZ2V0Iiwic2V0IiwicmVtb3ZlIiwic3BsaWNlIiwicG9wIiwiY2xlYXIiLCJuZXdTdGF0ZXMiLCJhdHRyIiwiaGFzQXR0cmlidXRlIiwiZGlmZiIsIk1hdGgiLCJhYnMiLCJwYWdlIiwibmV4dCIsImh0bWwiLCJuZXh0RG9jdW1lbnQiLCJ0aXRsZSIsInB0ciIsIlByb21pc2UiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZXNvbHZlIiwiZ2V0T3JpZ2luIiwibG9jYXRpb24iLCJvcmlnaW4iLCJnZXRQb3J0IiwicG9ydCIsInBvcnRTdHJpbmciLCJzdWJzdHJpbmciLCJwYXJzZUludCIsImhhc2giLCJxdWVyeSIsImhhc2hJbmRleCIsInF1ZXJ5SW5kZXgiLCJwYXJzZVF1ZXJ5IiwicmVkdWNlIiwiYWNjIiwiY2xlYW4iLCJIIiwiX19wcm90b19fIiwicmVxdWVzdCIsInR0bCIsInJlcXVlc3RFcnJvciIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0Iiwib250aW1lb3V0IiwiZXJyIiwib25lcnJvciIsIm9wZW4iLCJ0aW1lb3V0Iiwic2V0UmVxdWVzdEhlYWRlciIsInNlbmQiLCJvYmoiLCJydW5Bc3luYyIsImZ1bmMiLCJjdHgiLCJhcmdzIiwiYXN5bmMiLCJwcm9taXNlIiwiYW5zd2VyIiwiaXNQcm9taXNlIiwiaG9va3MiLCJfdGhpcyIsIk1hcCIsInJlZ2lzdGVyZWQiLCJhbGwiLCJmb3JFYWNoIiwiX3RoaXMyIiwiaG9vayIsImhhcyIsIlNldCIsImNoYWluIiwiX3RoaXMzIiwibG9nZ2VyIiwiX3RoaXM0IiwiaGVscCIsIklnbm9yZSIsImlnbm9yZSIsIl9pZ25vcmVBbGwiLCJwYXRocyIsIl9pZ25vcmVSZWdleGVzIiwicCIsImNoZWNrSHJlZiIsInNvbWUiLCJyZWdleCIsIkNhY2hlIiwiX3N0YXRlIiwiZ2V0UmVxdWVzdCIsImdldEFjdGlvbiIsImV4aXN0cyIsIm5ld1RhYiIsImV2ZW50Iiwid2hpY2giLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwiYmxhbmsiLCJ0YXJnZXQiLCJjb3JzRG9tYWluIiwicHJvdG9jb2wiLCJob3N0bmFtZSIsImNvcnNQb3J0IiwiZG93bmxvYWQiLCJwcmV2ZW50U2VsZiIsInByZXZlbnRBbGwiLCJCb29sZWFuIiwiY2xvc2VzdCIsInNhbWVVcmwiLCJQcmV2ZW50IiwiciIsImNoZWNrIiwic3VpdGUiLCJ0ZXN0cyIsInJ1biIsImNoZWNrTGluayIsIkJhcmJhRXJyb3IiLCJsYWJlbCIsImNhcHR1cmVTdGFja1RyYWNlIiwiZiIsIlN0b3JlIiwidHJhbnNpdGlvbnMiLCJ0eXBlIiwiX3J1bGVzIiwicG9zaXRpb24iLCJmaWx0ZXJzIiwib25jZSIsImZpbHRlciIsInNlbGYiLCJ0IiwibWF0Y2hpbmciLCJhY3RpdmUiLCJmaW5kIiwidmFsaWQiLCJyZXZlcnNlIiwiX2NoZWNrIiwicnVsZSIsInRvIiwiYWN0aXZlTWF0Y2giLCJ0cmFuc2l0aW9uVHlwZSIsImluZm9zIiwiT2JqZWN0IiwiX2FkZFByaW9yaXR5Iiwic29ydCIsImIiLCJwcmlvcml0eSIsImxlYXZlIiwiZW50ZXIiLCJ0cmFuc2l0aW9uIiwiZGlyZWN0aW9uIiwiaXNWYWxpZCIsImhhc01hdGNoIiwic3RyUnVsZSIsIm9ialJ1bGUiLCJmbk5hbWUiLCJjdXJyZW50IiwibmFtZXMiLCJfY2FsY3VsYXRlUHJpb3JpdHkiLCJydWxlTmFtZSIsInJ1bGVJbmRleCIsInBvdyIsIlRyYW5zaXRpb25zIiwic3RvcmUiLCJkb09uY2UiLCJfcnVubmluZyIsIl9kb0FzeW5jSG9vayIsImRvUGFnZSIsInUiLCJzeW5jIiwiX2lzVHJhbnNpdGlvbkVycm9yIiwibGVhdmVSZXN1bHQiLCJoZWxwZXJzIiwidmFsdWVzIiwibWVzc2FnZSIsIlZpZXdzIiwidmlld3MiLCJieU5hbWVzcGFjZSIsInZpZXciLCJfY3JlYXRlSG9vayIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJtc01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsInMiLCJwYXJlbnRFbGVtZW50Iiwibm9kZVR5cGUiLCJzY2hlbWFQYWdlIiwidmVyc2lvbiIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJwbHVnaW5zIiwiaW5zdGFsbCIsIm8iLCJzY2hlbWEiLCJ2IiwiY2FjaGVJZ25vcmUiLCJwcmVmZXRjaElnbm9yZSIsInByZXZlbnRSdW5uaW5nIiwicHJldmVudEN1c3RvbSIsImciLCJsb2dMZXZlbCIsIkUiLCJfcmVxdWVzdEN1c3RvbUVycm9yIiwiX3dyYXBwZXIiLCJzZXRBdHRyaWJ1dGUiLCJfcmVzZXREYXRhIiwiY2FjaGUiLCJfb25MaW5rRW50ZXIiLCJiaW5kIiwiX29uTGlua0NsaWNrIiwiX29uU3RhdGVDaGFuZ2UiLCJfYmluZCIsIm9uY2VEYXRhIiwiZGVzdHJveSIsIl91bmJpbmQiLCJmb3JjZSIsImFzc2lnbiIsImdvIiwiaXNSdW5uaW5nIiwiZ2V0UGF0aCIsImhhc1NlbGYiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInJlYWR5RGF0YSIsImhhc09uY2UiLCJvblJlcXVlc3RFcnJvciIsInNob3VsZFdhaXQiLCJyZXNwb25zZSIsInByZWZldGNoIiwiY2F0Y2giLCJfdGhpczUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpbmsiLCJfZ2V0TGlua0VsZW1lbnQiLCJfdGhpczYiLCJfZGF0YSIsImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiLCJleHBvcnRzIiwibWVkaWFMb2FkZWQiLCJtYWtlQXJyYXkiLCJpc0FycmF5TGlrZSIsImNhbGwiLCJvbkNvbXBsZXRlIiwiZWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW1hZ2VzIiwidmlkZW9zIiwicG9zdGVycyIsImVsZW1lbnQiLCJ1bnNoaWZ0IiwidmlkZW8iLCJwb3N0ZXIiLCJJbWFnZSIsInNyYyIsImlzVG91Y2giLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsImF1dG9wbGF5IiwidG90YWwiLCJoYXNCcm9rZW4iLCJjb3VudCIsImNvbXBsZXRlIiwiaGFuZGxlTWVkaWFMb2FkZWQiLCJpbWFnZSIsIm5hdHVyYWxXaWR0aCIsImdzYXAiLCJfZ2V0UHJvcGVydHkiLCJfbnVtRXhwIiwiX251bVdpdGhVbml0RXhwIiwiZ2V0VW5pdCIsIl9pc1N0cmluZyIsIl9pc1VuZGVmaW5lZCIsIl9yZW5kZXJDb21wbGV4U3RyaW5nIiwiX3JlbEV4cCIsIl9mb3JFYWNoTmFtZSIsIl9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkiLCJfY29sb3JTdHJpbmdGaWx0ZXIiLCJfY2hlY2tQbHVnaW4iLCJfcmVwbGFjZVJhbmRvbSIsIl9wbHVnaW5zIiwiR1NDYWNoZSIsIlByb3BUd2VlbiIsIl9jb25maWciLCJfdGlja2VyIiwiX3JvdW5kIiwiX21pc3NpbmdQbHVnaW4iLCJfZ2V0U2V0dGVyIiwiX2dldENhY2hlIiwiX2NvbG9yRXhwIiwiX3BhcnNlUmVsYXRpdmUiLCJfc2V0RGVmYXVsdHMiLCJfcmVtb3ZlTGlua2VkTGlzdEl0ZW0iLCJfd2luIiwiX2RvYyIsIl9kb2NFbGVtZW50IiwiX3BsdWdpbkluaXR0ZWQiLCJfdGVtcERpdiIsIl90ZW1wRGl2U3R5bGVyIiwiX3JlY2VudFNldHRlclBsdWdpbiIsIl93aW5kb3dFeGlzdHMiLCJfdHJhbnNmb3JtUHJvcHMiLCJfUkFEMkRFRyIsIlBJIiwiX0RFRzJSQUQiLCJfYXRhbjIiLCJhdGFuMiIsIl9iaWdOdW0iLCJfY2Fwc0V4cCIsIl9ob3Jpem9udGFsRXhwIiwiX2NvbXBsZXhFeHAiLCJfcHJvcGVydHlBbGlhc2VzIiwiYXV0b0FscGhhIiwic2NhbGUiLCJhbHBoYSIsIl9yZW5kZXJDU1NQcm9wIiwicmF0aW8iLCJyb3VuZCIsIl9yZW5kZXJQcm9wV2l0aEVuZCIsIl9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyIsIl9yZW5kZXJSb3VuZGVkQ1NTUHJvcCIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlIiwiX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQiLCJfc2V0dGVyQ1NTU3R5bGUiLCJwcm9wZXJ0eSIsInN0eWxlIiwiX3NldHRlckNTU1Byb3AiLCJzZXRQcm9wZXJ0eSIsIl9zZXR0ZXJUcmFuc2Zvcm0iLCJfZ3NhcCIsIl9zZXR0ZXJTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsIl9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIiLCJyZW5kZXJUcmFuc2Zvcm0iLCJfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciIsIl90cmFuc2Zvcm1Qcm9wIiwiX3RyYW5zZm9ybU9yaWdpblByb3AiLCJfc3VwcG9ydHMzRCIsIl9jcmVhdGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJjcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsInByZWZlclByZWZpeCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiX2luaXRDb3JlIiwiY3NzVGV4dCIsIl9nZXRCQm94SGFjayIsInN3YXBJZlBvc3NpYmxlIiwic3ZnIiwib3duZXJTVkdFbGVtZW50Iiwib2xkUGFyZW50Iiwib2xkU2libGluZyIsIm9sZENTUyIsImJib3giLCJkaXNwbGF5IiwiZ2V0QkJveCIsIl9nc2FwQkJveCIsIl9nZXRBdHRyaWJ1dGVGYWxsYmFja3MiLCJhdHRyaWJ1dGVzQXJyYXkiLCJfZ2V0QkJveCIsImJvdW5kcyIsIndpZHRoIiwiaGVpZ2h0IiwiX2lzU1ZHIiwiZ2V0Q1RNIiwiX3JlbW92ZVByb3BlcnR5IiwicmVtb3ZlUHJvcGVydHkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJfYWRkTm9uVHdlZW5pbmdQVCIsImJlZ2lubmluZyIsIm9ubHlTZXRBdEVuZCIsInB0IiwiX3B0IiwiX3Byb3BzIiwiX25vbkNvbnZlcnRpYmxlVW5pdHMiLCJkZWciLCJyYWQiLCJ0dXJuIiwiX2NvbnZlcnRUb1VuaXQiLCJ1bml0IiwiY3VyVmFsdWUiLCJwYXJzZUZsb2F0IiwiY3VyVW5pdCIsInRyaW0iLCJob3Jpem9udGFsIiwiaXNSb290U1ZHIiwibWVhc3VyZVByb3BlcnR5IiwiYW1vdW50IiwidG9QaXhlbHMiLCJ0b1BlcmNlbnQiLCJweCIsInBhcmVudCIsImlzU1ZHIiwidGltZSIsIl9nZXQiLCJ1bmNhY2hlIiwiX3BhcnNlVHJhbnNmb3JtIiwiX2ZpcnN0VHdvT25seSIsInpPcmlnaW4iLCJfc3BlY2lhbFByb3BzIiwiX3R3ZWVuQ29tcGxleENTU1N0cmluZyIsInByb3AiLCJtYXRjaEluZGV4Iiwic3RhcnRWYWx1ZXMiLCJzdGFydE51bSIsImNvbG9yIiwic3RhcnRWYWx1ZSIsImVuZFZhbHVlIiwiZW5kTnVtIiwiY2h1bmsiLCJlbmRVbml0Iiwic3RhcnRVbml0IiwiZW5kVmFsdWVzIiwibGFzdEluZGV4IiwidW5pdHMiLCJfbmV4dCIsIl9rZXl3b3JkVG9QZXJjZW50IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiY2VudGVyIiwiX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMiLCJfcmVuZGVyQ2xlYXJQcm9wcyIsInR3ZWVuIiwiX3RpbWUiLCJfZHVyIiwicHJvcHMiLCJjbGVhclRyYW5zZm9ybXMiLCJjbGVhclByb3BzIiwicHIiLCJfaWRlbnRpdHkyRE1hdHJpeCIsIl9yb3RhdGlvbmFsUHJvcGVydGllcyIsIl9pc051bGxUcmFuc2Zvcm0iLCJfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5IiwibWF0cml4U3RyaW5nIiwiX2dldE1hdHJpeCIsImZvcmNlMkQiLCJtYXRyaXgiLCJ0ZW1wIiwiYWRkZWRUb0RPTSIsInRyYW5zZm9ybSIsImNvbnNvbGlkYXRlIiwiZCIsIm9mZnNldFBhcmVudCIsIl9hcHBseVNWR09yaWdpbiIsIm9yaWdpbklzQWJzb2x1dGUiLCJzbW9vdGgiLCJtYXRyaXhBcnJheSIsInBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvIiwieE9yaWdpbk9sZCIsInhPcmlnaW4iLCJ5T3JpZ2luT2xkIiwieU9yaWdpbiIsInhPZmZzZXRPbGQiLCJ4T2Zmc2V0IiwieU9mZnNldE9sZCIsInlPZmZzZXQiLCJ0eCIsInR5Iiwib3JpZ2luU3BsaXQiLCJkZXRlcm1pbmFudCIsImludmVydGVkU2NhbGVYIiwieiIsInJvdGF0aW9uIiwicm90YXRpb25YIiwicm90YXRpb25ZIiwic2tld1giLCJza2V3WSIsInBlcnNwZWN0aXZlIiwiYW5nbGUiLCJjb3MiLCJzaW4iLCJhMTIiLCJhMjIiLCJ0MSIsInQyIiwidDMiLCJhMTMiLCJhMjMiLCJhMzMiLCJhNDIiLCJhNDMiLCJhMzIiLCJzcXJ0IiwiZm9yY2VDU1MiLCJ4UGVyY2VudCIsIm9mZnNldFdpZHRoIiwieVBlcmNlbnQiLCJvZmZzZXRIZWlnaHQiLCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZSIsImZvcmNlM0QiLCJfcmVuZGVyU1ZHVHJhbnNmb3JtcyIsIl9yZW5kZXJDU1NUcmFuc2Zvcm1zIiwiX3JlbmRlck5vbjNEVHJhbnNmb3JtcyIsIl9hZGRQeFRyYW5zbGF0ZSIsIl96ZXJvRGVnIiwiX3plcm9QeCIsIl9lbmRQYXJlbnRoZXNpcyIsIl9yZWYiLCJ0cmFuc2Zvcm1zIiwidXNlM0QiLCJfcmVmMiIsImExMSIsImEyMSIsInRhbiIsIl9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuIiwiY2FwIiwiaXNTdHJpbmciLCJmaW5hbFZhbHVlIiwiX2Fzc2lnbiIsIl9hZGRSYXdUcmFuc2Zvcm1QVHMiLCJzdGFydENhY2hlIiwiZXhjbHVkZSIsImVuZENhY2hlIiwibCIsInNpZGUiLCJ2YXJzIiwiQ1NTUGx1Z2luIiwicmVnaXN0ZXIiLCJ0YXJnZXRUZXN0IiwidGFyZ2V0cyIsInN0YXJ0QXQiLCJzcGVjaWFsUHJvcCIsInJlbGF0aXZlIiwiaXNUcmFuc2Zvcm1SZWxhdGVkIiwidHJhbnNmb3JtUHJvcFR3ZWVuIiwiaGFzUHJpb3JpdHkiLCJwYXJzZVRyYW5zZm9ybSIsInNtb290aE9yaWdpbiIsImRlcCIsImF1dG9Sb3VuZCIsImFsaWFzZXMiLCJnZXRTZXR0ZXIiLCJjb3JlIiwidXRpbHMiLCJjaGVja1ByZWZpeCIsInBvc2l0aW9uQW5kU2NhbGUiLCJvdGhlcnMiLCJyZWdpc3RlclBsdWdpbiIsImRlZmF1bHQiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiYXV0b1NsZWVwIiwibnVsbFRhcmdldFdhcm4iLCJsaW5lSGVpZ2h0IiwiX2RlZmF1bHRzIiwiZHVyYXRpb24iLCJvdmVyd3JpdGUiLCJkZWxheSIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfdGlueU51bSIsIl8yUEkiLCJfSEFMRl9QSSIsIl9nc0lEIiwiX3NxcnQiLCJfY29zIiwiX3NpbiIsIl9pc0Z1bmN0aW9uIiwiX2lzTnVtYmVyIiwiX2lzT2JqZWN0IiwiX2lzTm90RmFsc2UiLCJfaXNGdW5jT3JTdHJpbmciLCJfaXNUeXBlZEFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJfaXNBcnJheSIsIl9zdHJpY3ROdW1FeHAiLCJfY29tcGxleFN0cmluZ051bUV4cCIsIl9kZWxpbWl0ZWRWYWx1ZUV4cCIsIl91bml0RXhwIiwiX2dsb2JhbFRpbWVsaW5lIiwiX2NvcmVJbml0dGVkIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwiX21lcmdlIiwiX3dhcm4iLCJzdXBwcmVzcyIsIl9hZGRHbG9iYWwiLCJfZW1wdHlGdW5jIiwiX3Jlc2VydmVkUHJvcHMiLCJfbGF6eVR3ZWVucyIsIl9sYXp5TG9va3VwIiwiX2xhc3RSZW5kZXJlZEZyYW1lIiwiX2VmZmVjdHMiLCJfbmV4dEdDRnJhbWUiLCJfaGFybmVzc1BsdWdpbnMiLCJfY2FsbGJhY2tOYW1lcyIsIl9oYXJuZXNzIiwiaGFybmVzc1BsdWdpbiIsImhhcm5lc3MiLCJ0b0FycmF5IiwiX3JvdW5kUHJlY2lzZSIsIm9wZXJhdG9yIiwiX2FycmF5Q29udGFpbnNBbnkiLCJ0b1NlYXJjaCIsInRvRmluZCIsIl9sYXp5UmVuZGVyIiwiX2xhenkiLCJyZW5kZXIiLCJfbGF6eVNhZmVSZW5kZXIiLCJhbmltYXRpb24iLCJzdXBwcmVzc0V2ZW50cyIsIl9udW1lcmljSWZQb3NzaWJsZSIsIl9wYXNzVGhyb3VnaCIsImRlZmF1bHRzIiwiX3NldEtleWZyYW1lRGVmYXVsdHMiLCJleGNsdWRlRHVyYXRpb24iLCJ0b01lcmdlIiwiX21lcmdlRGVlcCIsIl9jb3B5RXhjbHVkaW5nIiwiZXhjbHVkaW5nIiwiY29weSIsIl9pbmhlcml0RGVmYXVsdHMiLCJrZXlmcmFtZXMiLCJpbmhlcml0IiwiX2RwIiwiX2FycmF5c01hdGNoIiwiYTEiLCJhMiIsIl9hZGRMaW5rZWRMaXN0SXRlbSIsImNoaWxkIiwiZmlyc3RQcm9wIiwibGFzdFByb3AiLCJzb3J0QnkiLCJfcHJldiIsIl9yZW1vdmVGcm9tUGFyZW50Iiwib25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSIsImF1dG9SZW1vdmVDaGlsZHJlbiIsIl9hY3QiLCJfdW5jYWNoZSIsIl9lbmQiLCJfc3RhcnQiLCJfZGlydHkiLCJfcmVjYWNoZUFuY2VzdG9ycyIsInRvdGFsRHVyYXRpb24iLCJfaGFzTm9QYXVzZWRBbmNlc3RvcnMiLCJfdHMiLCJfZWxhcHNlZEN5Y2xlRHVyYXRpb24iLCJfcmVwZWF0IiwiX2FuaW1hdGlvbkN5Y2xlIiwiX3RUaW1lIiwiX3JEZWxheSIsInRUaW1lIiwiY3ljbGVEdXJhdGlvbiIsIndob2xlIiwiZmxvb3IiLCJfcGFyZW50VG9DaGlsZFRvdGFsVGltZSIsInBhcmVudFRpbWUiLCJfdER1ciIsIl9zZXRFbmQiLCJfcnRzIiwiX2FsaWduUGxheWhlYWQiLCJ0b3RhbFRpbWUiLCJzbW9vdGhDaGlsZFRpbWluZyIsIl9wb3N0QWRkQ2hlY2tzIiwidGltZWxpbmUiLCJfaW5pdHRlZCIsInJhd1RpbWUiLCJfY2xhbXAiLCJfelRpbWUiLCJfYWRkVG9UaW1lbGluZSIsInNraXBDaGVja3MiLCJfcGFyc2VQb3NpdGlvbiIsIl9kZWxheSIsInRpbWVTY2FsZSIsIl9zb3J0IiwiX2lzRnJvbU9yRnJvbVN0YXJ0IiwiX3JlY2VudCIsIl9zY3JvbGxUcmlnZ2VyIiwiU2Nyb2xsVHJpZ2dlciIsIl9hdHRlbXB0SW5pdFR3ZWVuIiwiX2luaXRUd2VlbiIsImxhenkiLCJmcmFtZSIsIl9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQiLCJfbG9jayIsIl9yZW5kZXJaZXJvRHVyYXRpb25Ud2VlbiIsInByZXZSYXRpbyIsInJlcGVhdERlbGF5IiwiaXRlcmF0aW9uIiwicHJldkl0ZXJhdGlvbiIsIl95b3lvIiwicmVwZWF0UmVmcmVzaCIsImludmFsaWRhdGUiLCJfZnJvbSIsIl9zdGFydEF0IiwiX29uVXBkYXRlIiwiX2NhbGxiYWNrIiwiX3Byb20iLCJfZmluZE5leHRQYXVzZVR3ZWVuIiwicHJldlRpbWUiLCJfZmlyc3QiLCJfbGFzdCIsIl9zZXREdXJhdGlvbiIsInNraXBVbmNhY2hlIiwibGVhdmVQbGF5aGVhZCIsImR1ciIsInRvdGFsUHJvZ3Jlc3MiLCJfb25VcGRhdGVUb3RhbER1cmF0aW9uIiwiVGltZWxpbmUiLCJfemVyb1Bvc2l0aW9uIiwiZW5kVGltZSIsInBlcmNlbnRBbmltYXRpb24iLCJsYWJlbHMiLCJyZWNlbnQiLCJjbGlwcGVkRHVyYXRpb24iLCJpc1BlcmNlbnQiLCJpc05hTiIsIl9jcmVhdGVUd2VlblR5cGUiLCJpc0xlZ2FjeSIsInZhcnNJbmRleCIsImlyVmFycyIsImltbWVkaWF0ZVJlbmRlciIsInJ1bkJhY2t3YXJkcyIsIlR3ZWVuIiwiX2NvbmRpdGlvbmFsUmV0dXJuIiwibWluIiwibWF4IiwiY2xhbXAiLCJfc2xpY2UiLCJfaXNBcnJheUxpa2UiLCJub25FbXB0eSIsIl9mbGF0dGVuIiwiYXIiLCJsZWF2ZVN0cmluZ3MiLCJhY2N1bXVsYXRvciIsIl9hY2N1bXVsYXRvciIsIl93YWtlIiwic2VsZWN0b3IiLCJuYXRpdmVFbGVtZW50Iiwic2h1ZmZsZSIsInJhbmRvbSIsImRpc3RyaWJ1dGUiLCJlYWNoIiwiZWFzZSIsIl9wYXJzZUVhc2UiLCJpc0RlY2ltYWwiLCJyYXRpb3MiLCJheGlzIiwicmF0aW9YIiwicmF0aW9ZIiwiZWRnZXMiLCJkaXN0YW5jZXMiLCJvcmlnaW5YIiwib3JpZ2luWSIsIndyYXBBdCIsImdyaWQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfaW52ZXJ0RWFzZSIsIl9yb3VuZE1vZGlmaWVyIiwicmF3Iiwic25hcCIsInNuYXBUbyIsInJhZGl1cyIsImlzMkQiLCJpbmNyZW1lbnQiLCJkeCIsImR5Iiwicm91bmRpbmdJbmNyZW1lbnQiLCJyZXR1cm5GdW5jdGlvbiIsInBpcGUiLCJfbGVuIiwiZnVuY3Rpb25zIiwiX2tleSIsInVuaXRpemUiLCJub3JtYWxpemUiLCJtYXBSYW5nZSIsIl93cmFwQXJyYXkiLCJ3cmFwIiwicmFuZ2UiLCJ3cmFwWW95byIsIm51bXMiLCJpbk1pbiIsImluTWF4Iiwib3V0TWluIiwib3V0TWF4IiwiaW5SYW5nZSIsIm91dFJhbmdlIiwiaW50ZXJwb2xhdGUiLCJwcm9ncmVzcyIsIm11dGF0ZSIsIm1hc3RlciIsImludGVycG9sYXRvcnMiLCJpbCIsIl9hZGRQcm9wVHdlZW4iLCJfcmVuZGVyUHJvcFR3ZWVucyIsIl9nZXRMYWJlbEluRGlyZWN0aW9uIiwiZnJvbVRpbWUiLCJiYWNrd2FyZCIsImRpc3RhbmNlIiwiZXhlY3V0ZUxhenlGaXJzdCIsImNhbGxiYWNrIiwiY2FsbGJhY2tTY29wZSIsIl9pbnRlcnJ1cHQiLCJzY3JvbGxUcmlnZ2VyIiwia2lsbCIsIl9xdWlja1R3ZWVuIiwiX2NyZWF0ZVBsdWdpbiIsImNvbmZpZyIsImlzRnVuYyIsIlBsdWdpbiIsImluc3RhbmNlRGVmYXVsdHMiLCJfa2lsbFByb3BUd2VlbnNPZiIsIl9hZGRQbHVnaW5Nb2RpZmllciIsInJhd1ZhcnMiLCJzdGF0aWNzIiwiXzI1NSIsIl9jb2xvckxvb2t1cCIsImFxdWEiLCJsaW1lIiwic2lsdmVyIiwiYmxhY2siLCJtYXJvb24iLCJ0ZWFsIiwiYmx1ZSIsIm5hdnkiLCJ3aGl0ZSIsIm9saXZlIiwieWVsbG93Iiwib3JhbmdlIiwiZ3JheSIsInB1cnBsZSIsImdyZWVuIiwicmVkIiwicGluayIsImN5YW4iLCJ0cmFuc3BhcmVudCIsIl9odWUiLCJoIiwibTEiLCJtMiIsInNwbGl0Q29sb3IiLCJ0b0hTTCIsImZvcmNlQWxwaGEiLCJ3YXNIU0wiLCJOdW1iZXIiLCJfY29sb3JPcmRlckRhdGEiLCJfZm9ybWF0Q29sb3JzIiwib3JkZXJNYXRjaERhdGEiLCJjb2xvcnMiLCJzaGVsbCIsInNoaWZ0IiwiX2hzbEV4cCIsImNvbWJpbmVkIiwiX3RpY2tlckFjdGl2ZSIsIl9nZXRUaW1lIiwiRGF0ZSIsIm5vdyIsIl9sYWdUaHJlc2hvbGQiLCJfYWRqdXN0ZWRMYWciLCJfc3RhcnRUaW1lIiwiX2xhc3RVcGRhdGUiLCJfZ2FwIiwiX25leHRUaW1lIiwiX2xpc3RlbmVycyIsIl9pZCIsIl9yZXEiLCJfcmFmIiwiX3NlbGYiLCJfZGVsdGEiLCJfaSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsIm92ZXJsYXAiLCJkaXNwYXRjaCIsInRpY2siLCJkZWx0YVJhdGlvIiwiZnBzIiwid2FrZSIsImdzYXBWZXJzaW9ucyIsIkdyZWVuU29ja0dsb2JhbHMiLCJzbGVlcCIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImxhZ1Ntb290aGluZyIsInRocmVzaG9sZCIsImFkanVzdGVkTGFnIiwiX2ZwcyIsInByaW9yaXRpemUiLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwidmFsIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwiY2xvc2UiLCJuZXN0ZWQiLCJfY29uZmlnRWFzZUZyb21TdHJpbmciLCJfQ0UiLCJfcHJvcGFnYXRlWW95b0Vhc2UiLCJpc1lveW8iLCJ5b3lvRWFzZSIsIl9lYXNlIiwiX3lFYXNlIiwiZGVmYXVsdEVhc2UiLCJfaW5zZXJ0RWFzZSIsImVhc2VJbiIsImVhc2VPdXQiLCJlYXNlSW5PdXQiLCJsb3dlcmNhc2VOYW1lIiwiX2Vhc2VJbk91dEZyb21PdXQiLCJfY29uZmlnRWxhc3RpYyIsImFtcGxpdHVkZSIsInBlcmlvZCIsInAxIiwicDIiLCJwMyIsImFzaW4iLCJfY29uZmlnQmFjayIsIm92ZXJzaG9vdCIsInBvd2VyIiwiTGluZWFyIiwiZWFzZU5vbmUiLCJub25lIiwibjEiLCJuMiIsIm4zIiwiU3RlcHBlZEVhc2UiLCJzdGVwcyIsImltbWVkaWF0ZVN0YXJ0IiwiaWQiLCJBbmltYXRpb24iLCJJbmZpbml0eSIsInlveW8iLCJfcHJvdG8iLCJzdGFydFRpbWUiLCJfdG90YWxUaW1lIiwiX3B0TG9va3VwIiwiX3BUaW1lIiwiX3BzIiwicGF1c2VkIiwiaW5jbHVkZVJlcGVhdHMiLCJ3cmFwUmVwZWF0cyIsImdsb2JhbFRpbWUiLCJzZWVrIiwicmVzdGFydCIsImluY2x1ZGVEZWxheSIsInBsYXkiLCJyZXZlcnNlZCIsInBhdXNlIiwiYXRUaW1lIiwicmVzdW1lIiwiaXNBY3RpdmUiLCJldmVudENhbGxiYWNrIiwib25GdWxmaWxsZWQiLCJfcmVzb2x2ZSIsIl90aGVuIiwiX0FuaW1hdGlvbiIsInNvcnRDaGlsZHJlbiIsIl9wcm90bzIiLCJmcm9tVG8iLCJmcm9tVmFycyIsInRvVmFycyIsImRlbGF5ZWRDYWxsIiwic3RhZ2dlclRvIiwic3RhZ2dlciIsIm9uQ29tcGxldGVBbGwiLCJvbkNvbXBsZXRlQWxsUGFyYW1zIiwib25Db21wbGV0ZVBhcmFtcyIsInN0YWdnZXJGcm9tIiwic3RhZ2dlckZyb21UbyIsInREdXIiLCJjcm9zc2luZ1N0YXJ0IiwicHJldlBhdXNlZCIsInBhdXNlVHdlZW4iLCJwcmV2U3RhcnQiLCJyZXdpbmRpbmciLCJkb2VzV3JhcCIsIm9uUmVwZWF0IiwiX2hhc1BhdXNlIiwiX2ZvcmNpbmciLCJvblVwZGF0ZSIsImFkanVzdGVkVGltZSIsImFkZExhYmVsIiwiZ2V0Q2hpbGRyZW4iLCJ0d2VlbnMiLCJ0aW1lbGluZXMiLCJpZ25vcmVCZWZvcmVUaW1lIiwiZ2V0QnlJZCIsImFuaW1hdGlvbnMiLCJyZW1vdmVMYWJlbCIsImtpbGxUd2VlbnNPZiIsIl90b3RhbFRpbWUyIiwiYWRkUGF1c2UiLCJyZW1vdmVQYXVzZSIsIm9ubHlBY3RpdmUiLCJnZXRUd2VlbnNPZiIsIl9vdmVyd3JpdGluZ1R3ZWVuIiwicGFyc2VkVGFyZ2V0cyIsImlzR2xvYmFsVGltZSIsImNoaWxkcmVuIiwiX3RhcmdldHMiLCJ0d2VlblRvIiwidGwiLCJfdmFycyIsIl9vblN0YXJ0Iiwib25TdGFydCIsIm9uU3RhcnRQYXJhbXMiLCJpbml0dGVkIiwidHdlZW5Gcm9tVG8iLCJmcm9tUG9zaXRpb24iLCJ0b1Bvc2l0aW9uIiwibmV4dExhYmVsIiwiYWZ0ZXJUaW1lIiwicHJldmlvdXNMYWJlbCIsImJlZm9yZVRpbWUiLCJjdXJyZW50TGFiZWwiLCJzaGlmdENoaWxkcmVuIiwiYWRqdXN0TGFiZWxzIiwiaW5jbHVkZUxhYmVscyIsInVwZGF0ZVJvb3QiLCJfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiIsInNldHRlciIsInN0cmluZ0ZpbHRlciIsImZ1bmNQYXJhbSIsInN0YXJ0TnVtcyIsImhhc1JhbmRvbSIsImZwIiwiY3VycmVudFZhbHVlIiwicGFyc2VkU3RhcnQiLCJfc2V0dGVyUGxhaW4iLCJfc2V0dGVyRnVuY1dpdGhQYXJhbSIsIl9zZXR0ZXJGdW5jIiwiX2ZvcmNlQWxsUHJvcFR3ZWVucyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwicHRMb29rdXAiLCJvblVwZGF0ZVBhcmFtcyIsImF1dG9SZXZlcnQiLCJwcmV2U3RhcnRBdCIsImZ1bGxUYXJnZXRzIiwiYXV0b092ZXJ3cml0ZSIsIl9vdmVyd3JpdGUiLCJjbGVhblZhcnMiLCJnc0RhdGEiLCJoYXJuZXNzVmFycyIsIm92ZXJ3cml0dGVuIiwiX3B0Q2FjaGUiLCJfb3AiLCJfb25Jbml0IiwiX3VwZGF0ZVByb3BUd2VlbnMiLCJzdGFydElzUmVsYXRpdmUiLCJwdENhY2hlIiwibG9va3VwIiwiX2FkZEFsaWFzZXNUb1ZhcnMiLCJwcm9wZXJ0eUFsaWFzZXMiLCJfcGFyc2VLZXlmcmFtZSIsImFsbFByb3BzIiwiZWFzZUVhY2giLCJfc3RhZ2dlclR3ZWVuUHJvcHMiLCJfc3RhZ2dlclByb3BzVG9Ta2lwIiwiX0FuaW1hdGlvbjIiLCJza2lwSW5oZXJpdCIsIl90aGlzMyR2YXJzIiwiY3VyVGFyZ2V0Iiwic3RhZ2dlckZ1bmMiLCJzdGFnZ2VyVmFyc1RvTWVyZ2UiLCJrZiIsIl9wcm90bzMiLCJyZXNldFRvIiwia2lsbGluZ1RhcmdldHMiLCJwcm9wVHdlZW5Mb29rdXAiLCJmaXJzdFBUIiwib3ZlcndyaXR0ZW5Qcm9wcyIsImN1ckxvb2t1cCIsImN1ck92ZXJ3cml0ZVByb3BzIiwib25SZXZlcnNlQ29tcGxldGUiLCJvblJldmVyc2VDb21wbGV0ZVBhcmFtcyIsIl9zZXR0ZXJBdHRyaWJ1dGUiLCJoYXNOb25EZXBlbmRlbnRSZW1haW5pbmciLCJvcCIsIl9zZXR0ZXJXaXRoTW9kaWZpZXIiLCJtU2V0IiwibXQiLCJwdDIiLCJmaXJzdCIsImxhc3QiLCJyZW5kZXJlciIsIl9wcm90bzQiLCJUd2Vlbk1heCIsIlR3ZWVuTGl0ZSIsIlRpbWVsaW5lTGl0ZSIsIlRpbWVsaW5lTWF4IiwiX2xlbjIiLCJfa2V5MiIsImdldFByb3BlcnR5IiwiZ2V0dGVyIiwiZm9ybWF0IiwicXVpY2tTZXR0ZXIiLCJzZXR0ZXJzIiwicXVpY2tUbyIsIl9tZXJnZTIiLCJpc1R3ZWVuaW5nIiwicmVnaXN0ZXJFZmZlY3QiLCJfcmVmMyIsImVmZmVjdCIsImV4dGVuZFRpbWVsaW5lIiwicGx1Z2luTmFtZSIsInJlZ2lzdGVyRWFzZSIsInBhcnNlRWFzZSIsImV4cG9ydFJvb3QiLCJpbmNsdWRlRGVsYXllZENhbGxzIiwiZWZmZWN0cyIsInRpY2tlciIsImdsb2JhbFRpbWVsaW5lIiwiZ2xvYmFscyIsImdldENhY2hlIiwic3VwcHJlc3NPdmVyd3JpdGVzIiwiX2dldFBsdWdpblByb3BUd2VlbiIsIl9hZGRNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJfYnVpbGRNb2RpZmllclBsdWdpbiIsIlBvd2VyMCIsIlBvd2VyMSIsIlBvd2VyMiIsIlBvd2VyMyIsIlBvd2VyNCIsIlF1YWQiLCJDdWJpYyIsIlF1YXJ0IiwiUXVpbnQiLCJTdHJvbmciLCJFbGFzdGljIiwiQmFjayIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyIsImdzYXBXaXRoQ1NTIiwiVHdlZW5NYXhXaXRoQ1NTIiwiaGVsbG8iLCJ0ZXh0SW4iLCJ0YXJnZXRfIiwiZGF0YXNldCIsInJvdGF0ZSIsIm9wYWNpdHkiLCJpbWFnZUluIiwidmlkZW9JbiIsIkxvYWRlciIsImxvYWRNZWRpYSIsInByZWxvYWRJbWciLCJpbnN0YW5jZSIsImFsbERvbmUiLCJyZXNwb25zaXZlIiwiTmF2aWdhdGlvbiIsIm1lbnUiLCJtZW51X3RyaWdnZXIiLCJtZW51X3N0YXR1cyIsIm1lbnVfYW5pbWF0aW9uX3RpbWUiLCJtZW51X2Vhc2UiLCJwcmltYXJ5X21lbnUiLCJsaV9saXN0IiwiaG9tZV91cmwiLCJtZW51VHJpZ2dlciIsImNsYXNzTGlzdCIsImNsb3NlTWVudSIsIm9wZW5NZW51IiwicnNwIiwiUlNQX01EIiwiUkFGIiwib3B0aW1pc2F0aW9uIiwiYmFyYmEiLCJ2aWRlb2Jsb2NrIiwiVHJhbnNpdGlvbiIsInRoYXQiLCJhZnRlciIsInN0YXJ0QXV0b3BsYXkiLCJjb3ZlckFjdGlvbiIsInJlc2V0IiwibGlua18iLCJWaWRlb2Jsb2NrIiwidmlkZW9fbGlzdCIsImVtYmVkZGVkIiwiaGlkZUNvdmVyIiwiZ2xvYmFsIiwiUlNQX1hYUyIsIlJTUF9YUyIsIlJTUF9TTSIsIlJTUF9MRyIsIlJTUF9YTCIsIlJTUF9YWEwiLCJHTE9CQUxTIiwiU2Nyb2xsIiwiY3NzU2V0VG91Y2hEZXZpY2VzIiwibmF2aWdhdGlvbiIsInJhZiIsImxvYWRlciIsImhpZGVMb2FkZXIiLCJoZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9